// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: steammessages.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GCProtoBufMsgSrc int32

const (
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_Unspecified GCProtoBufMsgSrc = 0
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromSystem  GCProtoBufMsgSrc = 1
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromSteamID GCProtoBufMsgSrc = 2
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromGC      GCProtoBufMsgSrc = 3
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_ReplySystem GCProtoBufMsgSrc = 4
)

var GCProtoBufMsgSrc_name = map[int32]string{
	0: "GCProtoBufMsgSrc_Unspecified",
	1: "GCProtoBufMsgSrc_FromSystem",
	2: "GCProtoBufMsgSrc_FromSteamID",
	3: "GCProtoBufMsgSrc_FromGC",
	4: "GCProtoBufMsgSrc_ReplySystem",
}

var GCProtoBufMsgSrc_value = map[string]int32{
	"GCProtoBufMsgSrc_Unspecified": 0,
	"GCProtoBufMsgSrc_FromSystem":  1,
	"GCProtoBufMsgSrc_FromSteamID": 2,
	"GCProtoBufMsgSrc_FromGC":      3,
	"GCProtoBufMsgSrc_ReplySystem": 4,
}

func (x GCProtoBufMsgSrc) Enum() *GCProtoBufMsgSrc {
	p := new(GCProtoBufMsgSrc)
	*p = x
	return p
}

func (x GCProtoBufMsgSrc) String() string {
	return proto.EnumName(GCProtoBufMsgSrc_name, int32(x))
}

func (x *GCProtoBufMsgSrc) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GCProtoBufMsgSrc_value, data, "GCProtoBufMsgSrc")
	if err != nil {
		return err
	}
	*x = GCProtoBufMsgSrc(value)
	return nil
}

func (GCProtoBufMsgSrc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{0}
}

type CMsgGCRoutingInfo_RoutingMethod int32

const (
	CMsgGCRoutingInfo_RANDOM                CMsgGCRoutingInfo_RoutingMethod = 0
	CMsgGCRoutingInfo_DISCARD               CMsgGCRoutingInfo_RoutingMethod = 1
	CMsgGCRoutingInfo_CLIENT_STEAMID        CMsgGCRoutingInfo_RoutingMethod = 2
	CMsgGCRoutingInfo_PROTOBUF_FIELD_UINT64 CMsgGCRoutingInfo_RoutingMethod = 3
	CMsgGCRoutingInfo_WEBAPI_PARAM_UINT64   CMsgGCRoutingInfo_RoutingMethod = 4
)

var CMsgGCRoutingInfo_RoutingMethod_name = map[int32]string{
	0: "RANDOM",
	1: "DISCARD",
	2: "CLIENT_STEAMID",
	3: "PROTOBUF_FIELD_UINT64",
	4: "WEBAPI_PARAM_UINT64",
}

var CMsgGCRoutingInfo_RoutingMethod_value = map[string]int32{
	"RANDOM":                0,
	"DISCARD":               1,
	"CLIENT_STEAMID":        2,
	"PROTOBUF_FIELD_UINT64": 3,
	"WEBAPI_PARAM_UINT64":   4,
}

func (x CMsgGCRoutingInfo_RoutingMethod) Enum() *CMsgGCRoutingInfo_RoutingMethod {
	p := new(CMsgGCRoutingInfo_RoutingMethod)
	*p = x
	return p
}

func (x CMsgGCRoutingInfo_RoutingMethod) String() string {
	return proto.EnumName(CMsgGCRoutingInfo_RoutingMethod_name, int32(x))
}

func (x *CMsgGCRoutingInfo_RoutingMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgGCRoutingInfo_RoutingMethod_value, data, "CMsgGCRoutingInfo_RoutingMethod")
	if err != nil {
		return err
	}
	*x = CMsgGCRoutingInfo_RoutingMethod(value)
	return nil
}

func (CMsgGCRoutingInfo_RoutingMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{51, 0}
}

type CMsgGCMsgSetOptions_Option int32

const (
	CMsgGCMsgSetOptions_NOTIFY_USER_SESSIONS   CMsgGCMsgSetOptions_Option = 0
	CMsgGCMsgSetOptions_NOTIFY_SERVER_SESSIONS CMsgGCMsgSetOptions_Option = 1
	CMsgGCMsgSetOptions_NOTIFY_ACHIEVEMENTS    CMsgGCMsgSetOptions_Option = 2
	CMsgGCMsgSetOptions_NOTIFY_VAC_ACTION      CMsgGCMsgSetOptions_Option = 3
)

var CMsgGCMsgSetOptions_Option_name = map[int32]string{
	0: "NOTIFY_USER_SESSIONS",
	1: "NOTIFY_SERVER_SESSIONS",
	2: "NOTIFY_ACHIEVEMENTS",
	3: "NOTIFY_VAC_ACTION",
}

var CMsgGCMsgSetOptions_Option_value = map[string]int32{
	"NOTIFY_USER_SESSIONS":   0,
	"NOTIFY_SERVER_SESSIONS": 1,
	"NOTIFY_ACHIEVEMENTS":    2,
	"NOTIFY_VAC_ACTION":      3,
}

func (x CMsgGCMsgSetOptions_Option) Enum() *CMsgGCMsgSetOptions_Option {
	p := new(CMsgGCMsgSetOptions_Option)
	*p = x
	return p
}

func (x CMsgGCMsgSetOptions_Option) String() string {
	return proto.EnumName(CMsgGCMsgSetOptions_Option_name, int32(x))
}

func (x *CMsgGCMsgSetOptions_Option) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgGCMsgSetOptions_Option_value, data, "CMsgGCMsgSetOptions_Option")
	if err != nil {
		return err
	}
	*x = CMsgGCMsgSetOptions_Option(value)
	return nil
}

func (CMsgGCMsgSetOptions_Option) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{56, 0}
}

type CMsgDPPartnerMicroTxnsResponse_EErrorCode int32

const (
	CMsgDPPartnerMicroTxnsResponse_k_MsgValid                   CMsgDPPartnerMicroTxnsResponse_EErrorCode = 0
	CMsgDPPartnerMicroTxnsResponse_k_MsgInvalidAppID            CMsgDPPartnerMicroTxnsResponse_EErrorCode = 1
	CMsgDPPartnerMicroTxnsResponse_k_MsgInvalidPartnerInfo      CMsgDPPartnerMicroTxnsResponse_EErrorCode = 2
	CMsgDPPartnerMicroTxnsResponse_k_MsgNoTransactions          CMsgDPPartnerMicroTxnsResponse_EErrorCode = 3
	CMsgDPPartnerMicroTxnsResponse_k_MsgSQLFailure              CMsgDPPartnerMicroTxnsResponse_EErrorCode = 4
	CMsgDPPartnerMicroTxnsResponse_k_MsgPartnerInfoDiscrepancy  CMsgDPPartnerMicroTxnsResponse_EErrorCode = 5
	CMsgDPPartnerMicroTxnsResponse_k_MsgTransactionInsertFailed CMsgDPPartnerMicroTxnsResponse_EErrorCode = 7
	CMsgDPPartnerMicroTxnsResponse_k_MsgAlreadyRunning          CMsgDPPartnerMicroTxnsResponse_EErrorCode = 8
	CMsgDPPartnerMicroTxnsResponse_k_MsgInvalidTransactionData  CMsgDPPartnerMicroTxnsResponse_EErrorCode = 9
)

var CMsgDPPartnerMicroTxnsResponse_EErrorCode_name = map[int32]string{
	0: "k_MsgValid",
	1: "k_MsgInvalidAppID",
	2: "k_MsgInvalidPartnerInfo",
	3: "k_MsgNoTransactions",
	4: "k_MsgSQLFailure",
	5: "k_MsgPartnerInfoDiscrepancy",
	7: "k_MsgTransactionInsertFailed",
	8: "k_MsgAlreadyRunning",
	9: "k_MsgInvalidTransactionData",
}

var CMsgDPPartnerMicroTxnsResponse_EErrorCode_value = map[string]int32{
	"k_MsgValid":                   0,
	"k_MsgInvalidAppID":            1,
	"k_MsgInvalidPartnerInfo":      2,
	"k_MsgNoTransactions":          3,
	"k_MsgSQLFailure":              4,
	"k_MsgPartnerInfoDiscrepancy":  5,
	"k_MsgTransactionInsertFailed": 7,
	"k_MsgAlreadyRunning":          8,
	"k_MsgInvalidTransactionData":  9,
}

func (x CMsgDPPartnerMicroTxnsResponse_EErrorCode) Enum() *CMsgDPPartnerMicroTxnsResponse_EErrorCode {
	p := new(CMsgDPPartnerMicroTxnsResponse_EErrorCode)
	*p = x
	return p
}

func (x CMsgDPPartnerMicroTxnsResponse_EErrorCode) String() string {
	return proto.EnumName(CMsgDPPartnerMicroTxnsResponse_EErrorCode_name, int32(x))
}

func (x *CMsgDPPartnerMicroTxnsResponse_EErrorCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgDPPartnerMicroTxnsResponse_EErrorCode_value, data, "CMsgDPPartnerMicroTxnsResponse_EErrorCode")
	if err != nil {
		return err
	}
	*x = CMsgDPPartnerMicroTxnsResponse_EErrorCode(value)
	return nil
}

func (CMsgDPPartnerMicroTxnsResponse_EErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{60, 0}
}

type CMsgProtoBufHeader struct {
	ClientSteamId    uint64            `protobuf:"fixed64,1,opt,name=client_steam_id,json=clientSteamId" json:"client_steam_id"`
	ClientSessionId  int32             `protobuf:"varint,2,opt,name=client_session_id,json=clientSessionId" json:"client_session_id"`
	SourceAppId      uint32            `protobuf:"varint,3,opt,name=source_app_id,json=sourceAppId" json:"source_app_id"`
	JobIdSource      *uint64           `protobuf:"fixed64,10,opt,name=job_id_source,json=jobIdSource,def=18446744073709551615" json:"job_id_source,omitempty"`
	JobIdTarget      *uint64           `protobuf:"fixed64,11,opt,name=job_id_target,json=jobIdTarget,def=18446744073709551615" json:"job_id_target,omitempty"`
	TargetJobName    string            `protobuf:"bytes,12,opt,name=target_job_name,json=targetJobName" json:"target_job_name"`
	Eresult          *int32            `protobuf:"varint,13,opt,name=eresult,def=2" json:"eresult,omitempty"`
	ErrorMessage     string            `protobuf:"bytes,14,opt,name=error_message,json=errorMessage" json:"error_message"`
	Ip               uint32            `protobuf:"varint,15,opt,name=ip" json:"ip"`
	GcMsgSrc         *GCProtoBufMsgSrc `protobuf:"varint,200,opt,name=gc_msg_src,json=gcMsgSrc,enum=GCProtoBufMsgSrc,def=0" json:"gc_msg_src,omitempty"`
	GcDirIndexSource uint32            `protobuf:"varint,201,opt,name=gc_dir_index_source,json=gcDirIndexSource" json:"gc_dir_index_source"`
}

func (m *CMsgProtoBufHeader) Reset()         { *m = CMsgProtoBufHeader{} }
func (m *CMsgProtoBufHeader) String() string { return proto.CompactTextString(m) }
func (*CMsgProtoBufHeader) ProtoMessage()    {}
func (*CMsgProtoBufHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{0}
}
func (m *CMsgProtoBufHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgProtoBufHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgProtoBufHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgProtoBufHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgProtoBufHeader.Merge(m, src)
}
func (m *CMsgProtoBufHeader) XXX_Size() int {
	return m.Size()
}
func (m *CMsgProtoBufHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgProtoBufHeader.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgProtoBufHeader proto.InternalMessageInfo

const Default_CMsgProtoBufHeader_JobIdSource uint64 = 18446744073709551615
const Default_CMsgProtoBufHeader_JobIdTarget uint64 = 18446744073709551615
const Default_CMsgProtoBufHeader_Eresult int32 = 2
const Default_CMsgProtoBufHeader_GcMsgSrc GCProtoBufMsgSrc = GCProtoBufMsgSrc_GCProtoBufMsgSrc_Unspecified

func (m *CMsgProtoBufHeader) GetClientSteamId() uint64 {
	if m != nil {
		return m.ClientSteamId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetClientSessionId() int32 {
	if m != nil {
		return m.ClientSessionId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetSourceAppId() uint32 {
	if m != nil {
		return m.SourceAppId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetJobIdSource() uint64 {
	if m != nil && m.JobIdSource != nil {
		return *m.JobIdSource
	}
	return Default_CMsgProtoBufHeader_JobIdSource
}

func (m *CMsgProtoBufHeader) GetJobIdTarget() uint64 {
	if m != nil && m.JobIdTarget != nil {
		return *m.JobIdTarget
	}
	return Default_CMsgProtoBufHeader_JobIdTarget
}

func (m *CMsgProtoBufHeader) GetTargetJobName() string {
	if m != nil {
		return m.TargetJobName
	}
	return ""
}

func (m *CMsgProtoBufHeader) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgProtoBufHeader_Eresult
}

func (m *CMsgProtoBufHeader) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CMsgProtoBufHeader) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetGcMsgSrc() GCProtoBufMsgSrc {
	if m != nil && m.GcMsgSrc != nil {
		return *m.GcMsgSrc
	}
	return Default_CMsgProtoBufHeader_GcMsgSrc
}

func (m *CMsgProtoBufHeader) GetGcDirIndexSource() uint32 {
	if m != nil {
		return m.GcDirIndexSource
	}
	return 0
}

type CMsgWebAPIKey struct {
	Status           *uint32 `protobuf:"varint,1,opt,name=status,def=255" json:"status,omitempty"`
	AccountId        *uint32 `protobuf:"varint,2,opt,name=account_id,json=accountId,def=0" json:"account_id,omitempty"`
	PublisherGroupId *uint32 `protobuf:"varint,3,opt,name=publisher_group_id,json=publisherGroupId,def=0" json:"publisher_group_id,omitempty"`
	KeyId            uint32  `protobuf:"varint,4,opt,name=key_id,json=keyId" json:"key_id"`
	Domain           string  `protobuf:"bytes,5,opt,name=domain" json:"domain"`
}

func (m *CMsgWebAPIKey) Reset()         { *m = CMsgWebAPIKey{} }
func (m *CMsgWebAPIKey) String() string { return proto.CompactTextString(m) }
func (*CMsgWebAPIKey) ProtoMessage()    {}
func (*CMsgWebAPIKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{1}
}
func (m *CMsgWebAPIKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgWebAPIKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgWebAPIKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgWebAPIKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgWebAPIKey.Merge(m, src)
}
func (m *CMsgWebAPIKey) XXX_Size() int {
	return m.Size()
}
func (m *CMsgWebAPIKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgWebAPIKey.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgWebAPIKey proto.InternalMessageInfo

const Default_CMsgWebAPIKey_Status uint32 = 255
const Default_CMsgWebAPIKey_AccountId uint32 = 0
const Default_CMsgWebAPIKey_PublisherGroupId uint32 = 0

func (m *CMsgWebAPIKey) GetStatus() uint32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_CMsgWebAPIKey_Status
}

func (m *CMsgWebAPIKey) GetAccountId() uint32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return Default_CMsgWebAPIKey_AccountId
}

func (m *CMsgWebAPIKey) GetPublisherGroupId() uint32 {
	if m != nil && m.PublisherGroupId != nil {
		return *m.PublisherGroupId
	}
	return Default_CMsgWebAPIKey_PublisherGroupId
}

func (m *CMsgWebAPIKey) GetKeyId() uint32 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *CMsgWebAPIKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

type CMsgHttpRequest struct {
	RequestMethod   uint32                           `protobuf:"varint,1,opt,name=request_method,json=requestMethod" json:"request_method"`
	Hostname        string                           `protobuf:"bytes,2,opt,name=hostname" json:"hostname"`
	Url             string                           `protobuf:"bytes,3,opt,name=url" json:"url"`
	Headers         []*CMsgHttpRequest_RequestHeader `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
	GetParams       []*CMsgHttpRequest_QueryParam    `protobuf:"bytes,5,rep,name=get_params,json=getParams" json:"get_params,omitempty"`
	PostParams      []*CMsgHttpRequest_QueryParam    `protobuf:"bytes,6,rep,name=post_params,json=postParams" json:"post_params,omitempty"`
	Body            []byte                           `protobuf:"bytes,7,opt,name=body" json:"body"`
	AbsoluteTimeout uint32                           `protobuf:"varint,8,opt,name=absolute_timeout,json=absoluteTimeout" json:"absolute_timeout"`
}

func (m *CMsgHttpRequest) Reset()         { *m = CMsgHttpRequest{} }
func (m *CMsgHttpRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpRequest) ProtoMessage()    {}
func (*CMsgHttpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{2}
}
func (m *CMsgHttpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgHttpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgHttpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgHttpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgHttpRequest.Merge(m, src)
}
func (m *CMsgHttpRequest) XXX_Size() int {
	return m.Size()
}
func (m *CMsgHttpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgHttpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgHttpRequest proto.InternalMessageInfo

func (m *CMsgHttpRequest) GetRequestMethod() uint32 {
	if m != nil {
		return m.RequestMethod
	}
	return 0
}

func (m *CMsgHttpRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *CMsgHttpRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *CMsgHttpRequest) GetHeaders() []*CMsgHttpRequest_RequestHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CMsgHttpRequest) GetGetParams() []*CMsgHttpRequest_QueryParam {
	if m != nil {
		return m.GetParams
	}
	return nil
}

func (m *CMsgHttpRequest) GetPostParams() []*CMsgHttpRequest_QueryParam {
	if m != nil {
		return m.PostParams
	}
	return nil
}

func (m *CMsgHttpRequest) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *CMsgHttpRequest) GetAbsoluteTimeout() uint32 {
	if m != nil {
		return m.AbsoluteTimeout
	}
	return 0
}

type CMsgHttpRequest_RequestHeader struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpRequest_RequestHeader) Reset()         { *m = CMsgHttpRequest_RequestHeader{} }
func (m *CMsgHttpRequest_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpRequest_RequestHeader) ProtoMessage()    {}
func (*CMsgHttpRequest_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{2, 0}
}
func (m *CMsgHttpRequest_RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgHttpRequest_RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgHttpRequest_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgHttpRequest_RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgHttpRequest_RequestHeader.Merge(m, src)
}
func (m *CMsgHttpRequest_RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *CMsgHttpRequest_RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgHttpRequest_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgHttpRequest_RequestHeader proto.InternalMessageInfo

func (m *CMsgHttpRequest_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpRequest_RequestHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgHttpRequest_QueryParam struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpRequest_QueryParam) Reset()         { *m = CMsgHttpRequest_QueryParam{} }
func (m *CMsgHttpRequest_QueryParam) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpRequest_QueryParam) ProtoMessage()    {}
func (*CMsgHttpRequest_QueryParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{2, 1}
}
func (m *CMsgHttpRequest_QueryParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgHttpRequest_QueryParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgHttpRequest_QueryParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgHttpRequest_QueryParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgHttpRequest_QueryParam.Merge(m, src)
}
func (m *CMsgHttpRequest_QueryParam) XXX_Size() int {
	return m.Size()
}
func (m *CMsgHttpRequest_QueryParam) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgHttpRequest_QueryParam.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgHttpRequest_QueryParam proto.InternalMessageInfo

func (m *CMsgHttpRequest_QueryParam) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpRequest_QueryParam) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CMsgWebAPIRequest struct {
	UNUSEDJobName string           `protobuf:"bytes,1,opt,name=UNUSED_job_name,json=UNUSEDJobName" json:"UNUSED_job_name"`
	InterfaceName string           `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName" json:"interface_name"`
	MethodName    string           `protobuf:"bytes,3,opt,name=method_name,json=methodName" json:"method_name"`
	Version       uint32           `protobuf:"varint,4,opt,name=version" json:"version"`
	ApiKey        *CMsgWebAPIKey   `protobuf:"bytes,5,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
	Request       *CMsgHttpRequest `protobuf:"bytes,6,opt,name=request" json:"request,omitempty"`
	RoutingAppId  uint32           `protobuf:"varint,7,opt,name=routing_app_id,json=routingAppId" json:"routing_app_id"`
}

func (m *CMsgWebAPIRequest) Reset()         { *m = CMsgWebAPIRequest{} }
func (m *CMsgWebAPIRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgWebAPIRequest) ProtoMessage()    {}
func (*CMsgWebAPIRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{3}
}
func (m *CMsgWebAPIRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgWebAPIRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgWebAPIRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgWebAPIRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgWebAPIRequest.Merge(m, src)
}
func (m *CMsgWebAPIRequest) XXX_Size() int {
	return m.Size()
}
func (m *CMsgWebAPIRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgWebAPIRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgWebAPIRequest proto.InternalMessageInfo

func (m *CMsgWebAPIRequest) GetUNUSEDJobName() string {
	if m != nil {
		return m.UNUSEDJobName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgWebAPIRequest) GetApiKey() *CMsgWebAPIKey {
	if m != nil {
		return m.ApiKey
	}
	return nil
}

func (m *CMsgWebAPIRequest) GetRequest() *CMsgHttpRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CMsgWebAPIRequest) GetRoutingAppId() uint32 {
	if m != nil {
		return m.RoutingAppId
	}
	return 0
}

type CMsgHttpResponse struct {
	StatusCode uint32                             `protobuf:"varint,1,opt,name=status_code,json=statusCode" json:"status_code"`
	Headers    []*CMsgHttpResponse_ResponseHeader `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Body       []byte                             `protobuf:"bytes,3,opt,name=body" json:"body"`
}

func (m *CMsgHttpResponse) Reset()         { *m = CMsgHttpResponse{} }
func (m *CMsgHttpResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpResponse) ProtoMessage()    {}
func (*CMsgHttpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{4}
}
func (m *CMsgHttpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgHttpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgHttpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgHttpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgHttpResponse.Merge(m, src)
}
func (m *CMsgHttpResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgHttpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgHttpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgHttpResponse proto.InternalMessageInfo

func (m *CMsgHttpResponse) GetStatusCode() uint32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *CMsgHttpResponse) GetHeaders() []*CMsgHttpResponse_ResponseHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CMsgHttpResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type CMsgHttpResponse_ResponseHeader struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpResponse_ResponseHeader) Reset()         { *m = CMsgHttpResponse_ResponseHeader{} }
func (m *CMsgHttpResponse_ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpResponse_ResponseHeader) ProtoMessage()    {}
func (*CMsgHttpResponse_ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{4, 0}
}
func (m *CMsgHttpResponse_ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgHttpResponse_ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgHttpResponse_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgHttpResponse_ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgHttpResponse_ResponseHeader.Merge(m, src)
}
func (m *CMsgHttpResponse_ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *CMsgHttpResponse_ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgHttpResponse_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgHttpResponse_ResponseHeader proto.InternalMessageInfo

func (m *CMsgHttpResponse_ResponseHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpResponse_ResponseHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgAMFindAccounts struct {
	SearchType   uint32 `protobuf:"varint,1,opt,name=search_type,json=searchType" json:"search_type"`
	SearchString string `protobuf:"bytes,2,opt,name=search_string,json=searchString" json:"search_string"`
}

func (m *CMsgAMFindAccounts) Reset()         { *m = CMsgAMFindAccounts{} }
func (m *CMsgAMFindAccounts) String() string { return proto.CompactTextString(m) }
func (*CMsgAMFindAccounts) ProtoMessage()    {}
func (*CMsgAMFindAccounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{5}
}
func (m *CMsgAMFindAccounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMFindAccounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMFindAccounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMFindAccounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMFindAccounts.Merge(m, src)
}
func (m *CMsgAMFindAccounts) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMFindAccounts) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMFindAccounts.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMFindAccounts proto.InternalMessageInfo

func (m *CMsgAMFindAccounts) GetSearchType() uint32 {
	if m != nil {
		return m.SearchType
	}
	return 0
}

func (m *CMsgAMFindAccounts) GetSearchString() string {
	if m != nil {
		return m.SearchString
	}
	return ""
}

type CMsgAMFindAccountsResponse struct {
	SteamId []uint64 `protobuf:"fixed64,1,rep,name=steam_id,json=steamId" json:"steam_id,omitempty"`
}

func (m *CMsgAMFindAccountsResponse) Reset()         { *m = CMsgAMFindAccountsResponse{} }
func (m *CMsgAMFindAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMFindAccountsResponse) ProtoMessage()    {}
func (*CMsgAMFindAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{6}
}
func (m *CMsgAMFindAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMFindAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMFindAccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMFindAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMFindAccountsResponse.Merge(m, src)
}
func (m *CMsgAMFindAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMFindAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMFindAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMFindAccountsResponse proto.InternalMessageInfo

func (m *CMsgAMFindAccountsResponse) GetSteamId() []uint64 {
	if m != nil {
		return m.SteamId
	}
	return nil
}

type CMsgNotifyWatchdog struct {
	Source           uint32 `protobuf:"varint,1,opt,name=source" json:"source"`
	AlertType        uint32 `protobuf:"varint,2,opt,name=alert_type,json=alertType" json:"alert_type"`
	AlertDestination uint32 `protobuf:"varint,3,opt,name=alert_destination,json=alertDestination" json:"alert_destination"`
	Critical         bool   `protobuf:"varint,4,opt,name=critical" json:"critical"`
	Time             uint32 `protobuf:"varint,5,opt,name=time" json:"time"`
	Appid            uint32 `protobuf:"varint,6,opt,name=appid" json:"appid"`
	Text             string `protobuf:"bytes,7,opt,name=text" json:"text"`
}

func (m *CMsgNotifyWatchdog) Reset()         { *m = CMsgNotifyWatchdog{} }
func (m *CMsgNotifyWatchdog) String() string { return proto.CompactTextString(m) }
func (*CMsgNotifyWatchdog) ProtoMessage()    {}
func (*CMsgNotifyWatchdog) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{7}
}
func (m *CMsgNotifyWatchdog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgNotifyWatchdog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgNotifyWatchdog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgNotifyWatchdog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgNotifyWatchdog.Merge(m, src)
}
func (m *CMsgNotifyWatchdog) XXX_Size() int {
	return m.Size()
}
func (m *CMsgNotifyWatchdog) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgNotifyWatchdog.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgNotifyWatchdog proto.InternalMessageInfo

func (m *CMsgNotifyWatchdog) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAlertType() uint32 {
	if m != nil {
		return m.AlertType
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAlertDestination() uint32 {
	if m != nil {
		return m.AlertDestination
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetCritical() bool {
	if m != nil {
		return m.Critical
	}
	return false
}

func (m *CMsgNotifyWatchdog) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CMsgAMGetLicenses struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CMsgAMGetLicenses) Reset()         { *m = CMsgAMGetLicenses{} }
func (m *CMsgAMGetLicenses) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetLicenses) ProtoMessage()    {}
func (*CMsgAMGetLicenses) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{8}
}
func (m *CMsgAMGetLicenses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetLicenses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetLicenses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetLicenses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetLicenses.Merge(m, src)
}
func (m *CMsgAMGetLicenses) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetLicenses) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetLicenses.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetLicenses proto.InternalMessageInfo

func (m *CMsgAMGetLicenses) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CMsgPackageLicense struct {
	PackageId   uint32 `protobuf:"varint,1,opt,name=package_id,json=packageId" json:"package_id"`
	TimeCreated uint32 `protobuf:"varint,2,opt,name=time_created,json=timeCreated" json:"time_created"`
	OwnerId     uint32 `protobuf:"varint,3,opt,name=owner_id,json=ownerId" json:"owner_id"`
}

func (m *CMsgPackageLicense) Reset()         { *m = CMsgPackageLicense{} }
func (m *CMsgPackageLicense) String() string { return proto.CompactTextString(m) }
func (*CMsgPackageLicense) ProtoMessage()    {}
func (*CMsgPackageLicense) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{9}
}
func (m *CMsgPackageLicense) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgPackageLicense) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgPackageLicense.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgPackageLicense) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgPackageLicense.Merge(m, src)
}
func (m *CMsgPackageLicense) XXX_Size() int {
	return m.Size()
}
func (m *CMsgPackageLicense) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgPackageLicense.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgPackageLicense proto.InternalMessageInfo

func (m *CMsgPackageLicense) GetPackageId() uint32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *CMsgPackageLicense) GetTimeCreated() uint32 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *CMsgPackageLicense) GetOwnerId() uint32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

type CMsgAMGetLicensesResponse struct {
	License []*CMsgPackageLicense `protobuf:"bytes,1,rep,name=license" json:"license,omitempty"`
	Result  uint32                `protobuf:"varint,2,opt,name=result" json:"result"`
}

func (m *CMsgAMGetLicensesResponse) Reset()         { *m = CMsgAMGetLicensesResponse{} }
func (m *CMsgAMGetLicensesResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetLicensesResponse) ProtoMessage()    {}
func (*CMsgAMGetLicensesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{10}
}
func (m *CMsgAMGetLicensesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetLicensesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetLicensesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetLicensesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetLicensesResponse.Merge(m, src)
}
func (m *CMsgAMGetLicensesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetLicensesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetLicensesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetLicensesResponse proto.InternalMessageInfo

func (m *CMsgAMGetLicensesResponse) GetLicense() []*CMsgPackageLicense {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *CMsgAMGetLicensesResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type CMsgAMGetUserGameStats struct {
	SteamId uint64   `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	GameId  uint64   `protobuf:"fixed64,2,opt,name=game_id,json=gameId" json:"game_id"`
	Stats   []uint32 `protobuf:"varint,3,rep,name=stats" json:"stats,omitempty"`
}

func (m *CMsgAMGetUserGameStats) Reset()         { *m = CMsgAMGetUserGameStats{} }
func (m *CMsgAMGetUserGameStats) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStats) ProtoMessage()    {}
func (*CMsgAMGetUserGameStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{11}
}
func (m *CMsgAMGetUserGameStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetUserGameStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetUserGameStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetUserGameStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetUserGameStats.Merge(m, src)
}
func (m *CMsgAMGetUserGameStats) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetUserGameStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetUserGameStats.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetUserGameStats proto.InternalMessageInfo

func (m *CMsgAMGetUserGameStats) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGetUserGameStats) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *CMsgAMGetUserGameStats) GetStats() []uint32 {
	if m != nil {
		return m.Stats
	}
	return nil
}

type CMsgAMGetUserGameStatsResponse struct {
	SteamId           uint64                                               `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	GameId            uint64                                               `protobuf:"fixed64,2,opt,name=game_id,json=gameId" json:"game_id"`
	Eresult           *int32                                               `protobuf:"varint,3,opt,name=eresult,def=2" json:"eresult,omitempty"`
	Stats             []*CMsgAMGetUserGameStatsResponse_Stats              `protobuf:"bytes,4,rep,name=stats" json:"stats,omitempty"`
	AchievementBlocks []*CMsgAMGetUserGameStatsResponse_Achievement_Blocks `protobuf:"bytes,5,rep,name=achievement_blocks,json=achievementBlocks" json:"achievement_blocks,omitempty"`
}

func (m *CMsgAMGetUserGameStatsResponse) Reset()         { *m = CMsgAMGetUserGameStatsResponse{} }
func (m *CMsgAMGetUserGameStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStatsResponse) ProtoMessage()    {}
func (*CMsgAMGetUserGameStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{12}
}
func (m *CMsgAMGetUserGameStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetUserGameStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetUserGameStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetUserGameStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse.Merge(m, src)
}
func (m *CMsgAMGetUserGameStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetUserGameStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetUserGameStatsResponse proto.InternalMessageInfo

const Default_CMsgAMGetUserGameStatsResponse_Eresult int32 = 2

func (m *CMsgAMGetUserGameStatsResponse) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMGetUserGameStatsResponse_Eresult
}

func (m *CMsgAMGetUserGameStatsResponse) GetStats() []*CMsgAMGetUserGameStatsResponse_Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *CMsgAMGetUserGameStatsResponse) GetAchievementBlocks() []*CMsgAMGetUserGameStatsResponse_Achievement_Blocks {
	if m != nil {
		return m.AchievementBlocks
	}
	return nil
}

type CMsgAMGetUserGameStatsResponse_Stats struct {
	StatId    uint32 `protobuf:"varint,1,opt,name=stat_id,json=statId" json:"stat_id"`
	StatValue uint32 `protobuf:"varint,2,opt,name=stat_value,json=statValue" json:"stat_value"`
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Reset()         { *m = CMsgAMGetUserGameStatsResponse_Stats{} }
func (m *CMsgAMGetUserGameStatsResponse_Stats) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStatsResponse_Stats) ProtoMessage()    {}
func (*CMsgAMGetUserGameStatsResponse_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{12, 0}
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Stats.Merge(m, src)
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Stats proto.InternalMessageInfo

func (m *CMsgAMGetUserGameStatsResponse_Stats) GetStatId() uint32 {
	if m != nil {
		return m.StatId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) GetStatValue() uint32 {
	if m != nil {
		return m.StatValue
	}
	return 0
}

type CMsgAMGetUserGameStatsResponse_Achievement_Blocks struct {
	AchievementId    uint32 `protobuf:"varint,1,opt,name=achievement_id,json=achievementId" json:"achievement_id"`
	AchievementBitId uint32 `protobuf:"varint,2,opt,name=achievement_bit_id,json=achievementBitId" json:"achievement_bit_id"`
	UnlockTime       uint32 `protobuf:"fixed32,3,opt,name=unlock_time,json=unlockTime" json:"unlock_time"`
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Reset() {
	*m = CMsgAMGetUserGameStatsResponse_Achievement_Blocks{}
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgAMGetUserGameStatsResponse_Achievement_Blocks) ProtoMessage() {}
func (*CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{12, 1}
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Achievement_Blocks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Achievement_Blocks.Merge(m, src)
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Achievement_Blocks.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGetUserGameStatsResponse_Achievement_Blocks proto.InternalMessageInfo

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetAchievementId() uint32 {
	if m != nil {
		return m.AchievementId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetAchievementBitId() uint32 {
	if m != nil {
		return m.AchievementBitId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetUnlockTime() uint32 {
	if m != nil {
		return m.UnlockTime
	}
	return 0
}

type CMsgGCGetCommandList struct {
	AppId         uint32 `protobuf:"varint,1,opt,name=app_id,json=appId" json:"app_id"`
	CommandPrefix string `protobuf:"bytes,2,opt,name=command_prefix,json=commandPrefix" json:"command_prefix"`
}

func (m *CMsgGCGetCommandList) Reset()         { *m = CMsgGCGetCommandList{} }
func (m *CMsgGCGetCommandList) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetCommandList) ProtoMessage()    {}
func (*CMsgGCGetCommandList) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{13}
}
func (m *CMsgGCGetCommandList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetCommandList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetCommandList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetCommandList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetCommandList.Merge(m, src)
}
func (m *CMsgGCGetCommandList) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetCommandList) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetCommandList.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetCommandList proto.InternalMessageInfo

func (m *CMsgGCGetCommandList) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCGetCommandList) GetCommandPrefix() string {
	if m != nil {
		return m.CommandPrefix
	}
	return ""
}

type CMsgGCGetCommandListResponse struct {
	CommandName []string `protobuf:"bytes,1,rep,name=command_name,json=commandName" json:"command_name,omitempty"`
}

func (m *CMsgGCGetCommandListResponse) Reset()         { *m = CMsgGCGetCommandListResponse{} }
func (m *CMsgGCGetCommandListResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetCommandListResponse) ProtoMessage()    {}
func (*CMsgGCGetCommandListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{14}
}
func (m *CMsgGCGetCommandListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetCommandListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetCommandListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetCommandListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetCommandListResponse.Merge(m, src)
}
func (m *CMsgGCGetCommandListResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetCommandListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetCommandListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetCommandListResponse proto.InternalMessageInfo

func (m *CMsgGCGetCommandListResponse) GetCommandName() []string {
	if m != nil {
		return m.CommandName
	}
	return nil
}

type CGCMsgMemCachedGet struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedGet) Reset()         { *m = CGCMsgMemCachedGet{} }
func (m *CGCMsgMemCachedGet) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGet) ProtoMessage()    {}
func (*CGCMsgMemCachedGet) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{15}
}
func (m *CGCMsgMemCachedGet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedGet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedGet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedGet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedGet.Merge(m, src)
}
func (m *CGCMsgMemCachedGet) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedGet) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedGet.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedGet proto.InternalMessageInfo

func (m *CGCMsgMemCachedGet) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedGetResponse struct {
	Values []*CGCMsgMemCachedGetResponse_ValueTag `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *CGCMsgMemCachedGetResponse) Reset()         { *m = CGCMsgMemCachedGetResponse{} }
func (m *CGCMsgMemCachedGetResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGetResponse) ProtoMessage()    {}
func (*CGCMsgMemCachedGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{16}
}
func (m *CGCMsgMemCachedGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedGetResponse.Merge(m, src)
}
func (m *CGCMsgMemCachedGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedGetResponse proto.InternalMessageInfo

func (m *CGCMsgMemCachedGetResponse) GetValues() []*CGCMsgMemCachedGetResponse_ValueTag {
	if m != nil {
		return m.Values
	}
	return nil
}

type CGCMsgMemCachedGetResponse_ValueTag struct {
	Found bool   `protobuf:"varint,1,opt,name=found" json:"found"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Reset()         { *m = CGCMsgMemCachedGetResponse_ValueTag{} }
func (m *CGCMsgMemCachedGetResponse_ValueTag) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGetResponse_ValueTag) ProtoMessage()    {}
func (*CGCMsgMemCachedGetResponse_ValueTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{16, 0}
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedGetResponse_ValueTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedGetResponse_ValueTag.Merge(m, src)
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedGetResponse_ValueTag.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedGetResponse_ValueTag proto.InternalMessageInfo

func (m *CGCMsgMemCachedGetResponse_ValueTag) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CGCMsgMemCachedSet struct {
	Keys []*CGCMsgMemCachedSet_KeyPair `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedSet) Reset()         { *m = CGCMsgMemCachedSet{} }
func (m *CGCMsgMemCachedSet) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedSet) ProtoMessage()    {}
func (*CGCMsgMemCachedSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{17}
}
func (m *CGCMsgMemCachedSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedSet.Merge(m, src)
}
func (m *CGCMsgMemCachedSet) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedSet) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedSet.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedSet proto.InternalMessageInfo

func (m *CGCMsgMemCachedSet) GetKeys() []*CGCMsgMemCachedSet_KeyPair {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedSet_KeyPair struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CGCMsgMemCachedSet_KeyPair) Reset()         { *m = CGCMsgMemCachedSet_KeyPair{} }
func (m *CGCMsgMemCachedSet_KeyPair) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedSet_KeyPair) ProtoMessage()    {}
func (*CGCMsgMemCachedSet_KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{17, 0}
}
func (m *CGCMsgMemCachedSet_KeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedSet_KeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedSet_KeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedSet_KeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedSet_KeyPair.Merge(m, src)
}
func (m *CGCMsgMemCachedSet_KeyPair) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedSet_KeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedSet_KeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedSet_KeyPair proto.InternalMessageInfo

func (m *CGCMsgMemCachedSet_KeyPair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CGCMsgMemCachedSet_KeyPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CGCMsgMemCachedDelete struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedDelete) Reset()         { *m = CGCMsgMemCachedDelete{} }
func (m *CGCMsgMemCachedDelete) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedDelete) ProtoMessage()    {}
func (*CGCMsgMemCachedDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{18}
}
func (m *CGCMsgMemCachedDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedDelete.Merge(m, src)
}
func (m *CGCMsgMemCachedDelete) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedDelete.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedDelete proto.InternalMessageInfo

func (m *CGCMsgMemCachedDelete) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedStats struct {
}

func (m *CGCMsgMemCachedStats) Reset()         { *m = CGCMsgMemCachedStats{} }
func (m *CGCMsgMemCachedStats) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedStats) ProtoMessage()    {}
func (*CGCMsgMemCachedStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{19}
}
func (m *CGCMsgMemCachedStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedStats.Merge(m, src)
}
func (m *CGCMsgMemCachedStats) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedStats.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedStats proto.InternalMessageInfo

type CGCMsgMemCachedStatsResponse struct {
	CurrConnections uint64 `protobuf:"varint,1,opt,name=curr_connections,json=currConnections" json:"curr_connections"`
	CmdGet          uint64 `protobuf:"varint,2,opt,name=cmd_get,json=cmdGet" json:"cmd_get"`
	CmdSet          uint64 `protobuf:"varint,3,opt,name=cmd_set,json=cmdSet" json:"cmd_set"`
	CmdFlush        uint64 `protobuf:"varint,4,opt,name=cmd_flush,json=cmdFlush" json:"cmd_flush"`
	GetHits         uint64 `protobuf:"varint,5,opt,name=get_hits,json=getHits" json:"get_hits"`
	GetMisses       uint64 `protobuf:"varint,6,opt,name=get_misses,json=getMisses" json:"get_misses"`
	DeleteHits      uint64 `protobuf:"varint,7,opt,name=delete_hits,json=deleteHits" json:"delete_hits"`
	DeleteMisses    uint64 `protobuf:"varint,8,opt,name=delete_misses,json=deleteMisses" json:"delete_misses"`
	BytesRead       uint64 `protobuf:"varint,9,opt,name=bytes_read,json=bytesRead" json:"bytes_read"`
	BytesWritten    uint64 `protobuf:"varint,10,opt,name=bytes_written,json=bytesWritten" json:"bytes_written"`
	LimitMaxbytes   uint64 `protobuf:"varint,11,opt,name=limit_maxbytes,json=limitMaxbytes" json:"limit_maxbytes"`
	CurrItems       uint64 `protobuf:"varint,12,opt,name=curr_items,json=currItems" json:"curr_items"`
	Evictions       uint64 `protobuf:"varint,13,opt,name=evictions" json:"evictions"`
	Bytes           uint64 `protobuf:"varint,14,opt,name=bytes" json:"bytes"`
}

func (m *CGCMsgMemCachedStatsResponse) Reset()         { *m = CGCMsgMemCachedStatsResponse{} }
func (m *CGCMsgMemCachedStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedStatsResponse) ProtoMessage()    {}
func (*CGCMsgMemCachedStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{20}
}
func (m *CGCMsgMemCachedStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgMemCachedStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgMemCachedStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgMemCachedStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgMemCachedStatsResponse.Merge(m, src)
}
func (m *CGCMsgMemCachedStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgMemCachedStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgMemCachedStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgMemCachedStatsResponse proto.InternalMessageInfo

func (m *CGCMsgMemCachedStatsResponse) GetCurrConnections() uint64 {
	if m != nil {
		return m.CurrConnections
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdGet() uint64 {
	if m != nil {
		return m.CmdGet
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdSet() uint64 {
	if m != nil {
		return m.CmdSet
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdFlush() uint64 {
	if m != nil {
		return m.CmdFlush
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetGetHits() uint64 {
	if m != nil {
		return m.GetHits
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetGetMisses() uint64 {
	if m != nil {
		return m.GetMisses
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetDeleteHits() uint64 {
	if m != nil {
		return m.DeleteHits
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetDeleteMisses() uint64 {
	if m != nil {
		return m.DeleteMisses
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetLimitMaxbytes() uint64 {
	if m != nil {
		return m.LimitMaxbytes
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCurrItems() uint64 {
	if m != nil {
		return m.CurrItems
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetEvictions() uint64 {
	if m != nil {
		return m.Evictions
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type CGCMsgSQLStats struct {
	SchemaCatalog uint32 `protobuf:"varint,1,opt,name=schema_catalog,json=schemaCatalog" json:"schema_catalog"`
}

func (m *CGCMsgSQLStats) Reset()         { *m = CGCMsgSQLStats{} }
func (m *CGCMsgSQLStats) String() string { return proto.CompactTextString(m) }
func (*CGCMsgSQLStats) ProtoMessage()    {}
func (*CGCMsgSQLStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{21}
}
func (m *CGCMsgSQLStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgSQLStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgSQLStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgSQLStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgSQLStats.Merge(m, src)
}
func (m *CGCMsgSQLStats) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgSQLStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgSQLStats.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgSQLStats proto.InternalMessageInfo

func (m *CGCMsgSQLStats) GetSchemaCatalog() uint32 {
	if m != nil {
		return m.SchemaCatalog
	}
	return 0
}

type CGCMsgSQLStatsResponse struct {
	Threads                       uint32 `protobuf:"varint,1,opt,name=threads" json:"threads"`
	ThreadsConnected              uint32 `protobuf:"varint,2,opt,name=threads_connected,json=threadsConnected" json:"threads_connected"`
	ThreadsActive                 uint32 `protobuf:"varint,3,opt,name=threads_active,json=threadsActive" json:"threads_active"`
	OperationsSubmitted           uint32 `protobuf:"varint,4,opt,name=operations_submitted,json=operationsSubmitted" json:"operations_submitted"`
	PreparedStatementsExecuted    uint32 `protobuf:"varint,5,opt,name=prepared_statements_executed,json=preparedStatementsExecuted" json:"prepared_statements_executed"`
	NonPreparedStatementsExecuted uint32 `protobuf:"varint,6,opt,name=non_prepared_statements_executed,json=nonPreparedStatementsExecuted" json:"non_prepared_statements_executed"`
	DeadlockRetries               uint32 `protobuf:"varint,7,opt,name=deadlock_retries,json=deadlockRetries" json:"deadlock_retries"`
	OperationsTimedOutInQueue     uint32 `protobuf:"varint,8,opt,name=operations_timed_out_in_queue,json=operationsTimedOutInQueue" json:"operations_timed_out_in_queue"`
	Errors                        uint32 `protobuf:"varint,9,opt,name=errors" json:"errors"`
}

func (m *CGCMsgSQLStatsResponse) Reset()         { *m = CGCMsgSQLStatsResponse{} }
func (m *CGCMsgSQLStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgSQLStatsResponse) ProtoMessage()    {}
func (*CGCMsgSQLStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{22}
}
func (m *CGCMsgSQLStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgSQLStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgSQLStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgSQLStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgSQLStatsResponse.Merge(m, src)
}
func (m *CGCMsgSQLStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgSQLStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgSQLStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgSQLStatsResponse proto.InternalMessageInfo

func (m *CGCMsgSQLStatsResponse) GetThreads() uint32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetThreadsConnected() uint32 {
	if m != nil {
		return m.ThreadsConnected
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetThreadsActive() uint32 {
	if m != nil {
		return m.ThreadsActive
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetOperationsSubmitted() uint32 {
	if m != nil {
		return m.OperationsSubmitted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetPreparedStatementsExecuted() uint32 {
	if m != nil {
		return m.PreparedStatementsExecuted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetNonPreparedStatementsExecuted() uint32 {
	if m != nil {
		return m.NonPreparedStatementsExecuted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetDeadlockRetries() uint32 {
	if m != nil {
		return m.DeadlockRetries
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetOperationsTimedOutInQueue() uint32 {
	if m != nil {
		return m.OperationsTimedOutInQueue
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetErrors() uint32 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type CMsgAMAddFreeLicense struct {
	Steamid          uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	IpPublic         uint32 `protobuf:"varint,2,opt,name=ip_public,json=ipPublic" json:"ip_public"`
	Packageid        uint32 `protobuf:"varint,3,opt,name=packageid" json:"packageid"`
	StoreCountryCode string `protobuf:"bytes,4,opt,name=store_country_code,json=storeCountryCode" json:"store_country_code"`
}

func (m *CMsgAMAddFreeLicense) Reset()         { *m = CMsgAMAddFreeLicense{} }
func (m *CMsgAMAddFreeLicense) String() string { return proto.CompactTextString(m) }
func (*CMsgAMAddFreeLicense) ProtoMessage()    {}
func (*CMsgAMAddFreeLicense) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{23}
}
func (m *CMsgAMAddFreeLicense) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMAddFreeLicense) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMAddFreeLicense.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMAddFreeLicense) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMAddFreeLicense.Merge(m, src)
}
func (m *CMsgAMAddFreeLicense) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMAddFreeLicense) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMAddFreeLicense.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMAddFreeLicense proto.InternalMessageInfo

func (m *CMsgAMAddFreeLicense) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetIpPublic() uint32 {
	if m != nil {
		return m.IpPublic
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetPackageid() uint32 {
	if m != nil {
		return m.Packageid
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetStoreCountryCode() string {
	if m != nil {
		return m.StoreCountryCode
	}
	return ""
}

type CMsgAMAddFreeLicenseResponse struct {
	Eresult              *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	PurchaseResultDetail int32  `protobuf:"varint,2,opt,name=purchase_result_detail,json=purchaseResultDetail" json:"purchase_result_detail"`
	Transid              uint64 `protobuf:"fixed64,3,opt,name=transid" json:"transid"`
}

func (m *CMsgAMAddFreeLicenseResponse) Reset()         { *m = CMsgAMAddFreeLicenseResponse{} }
func (m *CMsgAMAddFreeLicenseResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMAddFreeLicenseResponse) ProtoMessage()    {}
func (*CMsgAMAddFreeLicenseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{24}
}
func (m *CMsgAMAddFreeLicenseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMAddFreeLicenseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMAddFreeLicenseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMAddFreeLicenseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMAddFreeLicenseResponse.Merge(m, src)
}
func (m *CMsgAMAddFreeLicenseResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMAddFreeLicenseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMAddFreeLicenseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMAddFreeLicenseResponse proto.InternalMessageInfo

const Default_CMsgAMAddFreeLicenseResponse_Eresult int32 = 2

func (m *CMsgAMAddFreeLicenseResponse) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMAddFreeLicenseResponse_Eresult
}

func (m *CMsgAMAddFreeLicenseResponse) GetPurchaseResultDetail() int32 {
	if m != nil {
		return m.PurchaseResultDetail
	}
	return 0
}

func (m *CMsgAMAddFreeLicenseResponse) GetTransid() uint64 {
	if m != nil {
		return m.Transid
	}
	return 0
}

type CGCMsgGetIPLocation struct {
	Ips []uint32 `protobuf:"fixed32,1,rep,name=ips" json:"ips,omitempty"`
}

func (m *CGCMsgGetIPLocation) Reset()         { *m = CGCMsgGetIPLocation{} }
func (m *CGCMsgGetIPLocation) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetIPLocation) ProtoMessage()    {}
func (*CGCMsgGetIPLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{25}
}
func (m *CGCMsgGetIPLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgGetIPLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgGetIPLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgGetIPLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgGetIPLocation.Merge(m, src)
}
func (m *CGCMsgGetIPLocation) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgGetIPLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgGetIPLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgGetIPLocation proto.InternalMessageInfo

func (m *CGCMsgGetIPLocation) GetIps() []uint32 {
	if m != nil {
		return m.Ips
	}
	return nil
}

type CIPLocationInfo struct {
	Ip        uint32  `protobuf:"varint,1,opt,name=ip" json:"ip"`
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude" json:"latitude"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude" json:"longitude"`
	Country   string  `protobuf:"bytes,4,opt,name=country" json:"country"`
	State     string  `protobuf:"bytes,5,opt,name=state" json:"state"`
	City      string  `protobuf:"bytes,6,opt,name=city" json:"city"`
}

func (m *CIPLocationInfo) Reset()         { *m = CIPLocationInfo{} }
func (m *CIPLocationInfo) String() string { return proto.CompactTextString(m) }
func (*CIPLocationInfo) ProtoMessage()    {}
func (*CIPLocationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{26}
}
func (m *CIPLocationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CIPLocationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CIPLocationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CIPLocationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CIPLocationInfo.Merge(m, src)
}
func (m *CIPLocationInfo) XXX_Size() int {
	return m.Size()
}
func (m *CIPLocationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CIPLocationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CIPLocationInfo proto.InternalMessageInfo

func (m *CIPLocationInfo) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *CIPLocationInfo) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *CIPLocationInfo) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *CIPLocationInfo) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CIPLocationInfo) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *CIPLocationInfo) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

type CGCMsgGetIPLocationResponse struct {
	Infos []*CIPLocationInfo `protobuf:"bytes,1,rep,name=infos" json:"infos,omitempty"`
}

func (m *CGCMsgGetIPLocationResponse) Reset()         { *m = CGCMsgGetIPLocationResponse{} }
func (m *CGCMsgGetIPLocationResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetIPLocationResponse) ProtoMessage()    {}
func (*CGCMsgGetIPLocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{27}
}
func (m *CGCMsgGetIPLocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgGetIPLocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgGetIPLocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgGetIPLocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgGetIPLocationResponse.Merge(m, src)
}
func (m *CGCMsgGetIPLocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgGetIPLocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgGetIPLocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgGetIPLocationResponse proto.InternalMessageInfo

func (m *CGCMsgGetIPLocationResponse) GetInfos() []*CIPLocationInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type CGCMsgSystemStatsSchema struct {
	GcAppId  uint32 `protobuf:"varint,1,opt,name=gc_app_id,json=gcAppId" json:"gc_app_id"`
	SchemaKv []byte `protobuf:"bytes,2,opt,name=schema_kv,json=schemaKv" json:"schema_kv"`
}

func (m *CGCMsgSystemStatsSchema) Reset()         { *m = CGCMsgSystemStatsSchema{} }
func (m *CGCMsgSystemStatsSchema) String() string { return proto.CompactTextString(m) }
func (*CGCMsgSystemStatsSchema) ProtoMessage()    {}
func (*CGCMsgSystemStatsSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{28}
}
func (m *CGCMsgSystemStatsSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgSystemStatsSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgSystemStatsSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgSystemStatsSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgSystemStatsSchema.Merge(m, src)
}
func (m *CGCMsgSystemStatsSchema) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgSystemStatsSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgSystemStatsSchema.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgSystemStatsSchema proto.InternalMessageInfo

func (m *CGCMsgSystemStatsSchema) GetGcAppId() uint32 {
	if m != nil {
		return m.GcAppId
	}
	return 0
}

func (m *CGCMsgSystemStatsSchema) GetSchemaKv() []byte {
	if m != nil {
		return m.SchemaKv
	}
	return nil
}

type CGCMsgGetSystemStats struct {
}

func (m *CGCMsgGetSystemStats) Reset()         { *m = CGCMsgGetSystemStats{} }
func (m *CGCMsgGetSystemStats) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetSystemStats) ProtoMessage()    {}
func (*CGCMsgGetSystemStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{29}
}
func (m *CGCMsgGetSystemStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgGetSystemStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgGetSystemStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgGetSystemStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgGetSystemStats.Merge(m, src)
}
func (m *CGCMsgGetSystemStats) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgGetSystemStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgGetSystemStats.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgGetSystemStats proto.InternalMessageInfo

type CGCMsgGetSystemStatsResponse struct {
	GcAppId            uint32 `protobuf:"varint,1,opt,name=gc_app_id,json=gcAppId" json:"gc_app_id"`
	StatsKv            []byte `protobuf:"bytes,2,opt,name=stats_kv,json=statsKv" json:"stats_kv"`
	ActiveJobs         uint32 `protobuf:"varint,3,opt,name=active_jobs,json=activeJobs" json:"active_jobs"`
	YieldingJobs       uint32 `protobuf:"varint,4,opt,name=yielding_jobs,json=yieldingJobs" json:"yielding_jobs"`
	UserSessions       uint32 `protobuf:"varint,5,opt,name=user_sessions,json=userSessions" json:"user_sessions"`
	GameServerSessions uint32 `protobuf:"varint,6,opt,name=game_server_sessions,json=gameServerSessions" json:"game_server_sessions"`
	Socaches           uint32 `protobuf:"varint,7,opt,name=socaches" json:"socaches"`
	SocachesToUnload   uint32 `protobuf:"varint,8,opt,name=socaches_to_unload,json=socachesToUnload" json:"socaches_to_unload"`
	SocachesLoading    uint32 `protobuf:"varint,9,opt,name=socaches_loading,json=socachesLoading" json:"socaches_loading"`
	WritebackQueue     uint32 `protobuf:"varint,10,opt,name=writeback_queue,json=writebackQueue" json:"writeback_queue"`
	SteamidLocks       uint32 `protobuf:"varint,11,opt,name=steamid_locks,json=steamidLocks" json:"steamid_locks"`
	LogonQueue         uint32 `protobuf:"varint,12,opt,name=logon_queue,json=logonQueue" json:"logon_queue"`
	LogonJobs          uint32 `protobuf:"varint,13,opt,name=logon_jobs,json=logonJobs" json:"logon_jobs"`
}

func (m *CGCMsgGetSystemStatsResponse) Reset()         { *m = CGCMsgGetSystemStatsResponse{} }
func (m *CGCMsgGetSystemStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetSystemStatsResponse) ProtoMessage()    {}
func (*CGCMsgGetSystemStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{30}
}
func (m *CGCMsgGetSystemStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCMsgGetSystemStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCMsgGetSystemStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCMsgGetSystemStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCMsgGetSystemStatsResponse.Merge(m, src)
}
func (m *CGCMsgGetSystemStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CGCMsgGetSystemStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCMsgGetSystemStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CGCMsgGetSystemStatsResponse proto.InternalMessageInfo

func (m *CGCMsgGetSystemStatsResponse) GetGcAppId() uint32 {
	if m != nil {
		return m.GcAppId
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetStatsKv() []byte {
	if m != nil {
		return m.StatsKv
	}
	return nil
}

func (m *CGCMsgGetSystemStatsResponse) GetActiveJobs() uint32 {
	if m != nil {
		return m.ActiveJobs
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetYieldingJobs() uint32 {
	if m != nil {
		return m.YieldingJobs
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetUserSessions() uint32 {
	if m != nil {
		return m.UserSessions
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetGameServerSessions() uint32 {
	if m != nil {
		return m.GameServerSessions
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocaches() uint32 {
	if m != nil {
		return m.Socaches
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocachesToUnload() uint32 {
	if m != nil {
		return m.SocachesToUnload
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocachesLoading() uint32 {
	if m != nil {
		return m.SocachesLoading
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetWritebackQueue() uint32 {
	if m != nil {
		return m.WritebackQueue
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSteamidLocks() uint32 {
	if m != nil {
		return m.SteamidLocks
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetLogonQueue() uint32 {
	if m != nil {
		return m.LogonQueue
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetLogonJobs() uint32 {
	if m != nil {
		return m.LogonJobs
	}
	return 0
}

type CMsgAMSendEmail struct {
	Steamid           uint64                                         `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	EmailMsgType      uint32                                         `protobuf:"varint,2,opt,name=email_msg_type,json=emailMsgType" json:"email_msg_type"`
	EmailFormat       uint32                                         `protobuf:"varint,3,opt,name=email_format,json=emailFormat" json:"email_format"`
	PersonaNameTokens []*CMsgAMSendEmail_PersonaNameReplacementToken `protobuf:"bytes,5,rep,name=persona_name_tokens,json=personaNameTokens" json:"persona_name_tokens,omitempty"`
	SourceGc          uint32                                         `protobuf:"varint,6,opt,name=source_gc,json=sourceGc" json:"source_gc"`
	Tokens            []*CMsgAMSendEmail_ReplacementToken            `protobuf:"bytes,7,rep,name=tokens" json:"tokens,omitempty"`
}

func (m *CMsgAMSendEmail) Reset()         { *m = CMsgAMSendEmail{} }
func (m *CMsgAMSendEmail) String() string { return proto.CompactTextString(m) }
func (*CMsgAMSendEmail) ProtoMessage()    {}
func (*CMsgAMSendEmail) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{31}
}
func (m *CMsgAMSendEmail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMSendEmail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMSendEmail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMSendEmail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMSendEmail.Merge(m, src)
}
func (m *CMsgAMSendEmail) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMSendEmail) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMSendEmail.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMSendEmail proto.InternalMessageInfo

func (m *CMsgAMSendEmail) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMSendEmail) GetEmailMsgType() uint32 {
	if m != nil {
		return m.EmailMsgType
	}
	return 0
}

func (m *CMsgAMSendEmail) GetEmailFormat() uint32 {
	if m != nil {
		return m.EmailFormat
	}
	return 0
}

func (m *CMsgAMSendEmail) GetPersonaNameTokens() []*CMsgAMSendEmail_PersonaNameReplacementToken {
	if m != nil {
		return m.PersonaNameTokens
	}
	return nil
}

func (m *CMsgAMSendEmail) GetSourceGc() uint32 {
	if m != nil {
		return m.SourceGc
	}
	return 0
}

func (m *CMsgAMSendEmail) GetTokens() []*CMsgAMSendEmail_ReplacementToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type CMsgAMSendEmail_ReplacementToken struct {
	TokenName  string `protobuf:"bytes,1,opt,name=token_name,json=tokenName" json:"token_name"`
	TokenValue string `protobuf:"bytes,2,opt,name=token_value,json=tokenValue" json:"token_value"`
}

func (m *CMsgAMSendEmail_ReplacementToken) Reset()         { *m = CMsgAMSendEmail_ReplacementToken{} }
func (m *CMsgAMSendEmail_ReplacementToken) String() string { return proto.CompactTextString(m) }
func (*CMsgAMSendEmail_ReplacementToken) ProtoMessage()    {}
func (*CMsgAMSendEmail_ReplacementToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{31, 0}
}
func (m *CMsgAMSendEmail_ReplacementToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMSendEmail_ReplacementToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMSendEmail_ReplacementToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMSendEmail_ReplacementToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMSendEmail_ReplacementToken.Merge(m, src)
}
func (m *CMsgAMSendEmail_ReplacementToken) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMSendEmail_ReplacementToken) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMSendEmail_ReplacementToken.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMSendEmail_ReplacementToken proto.InternalMessageInfo

func (m *CMsgAMSendEmail_ReplacementToken) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *CMsgAMSendEmail_ReplacementToken) GetTokenValue() string {
	if m != nil {
		return m.TokenValue
	}
	return ""
}

type CMsgAMSendEmail_PersonaNameReplacementToken struct {
	Steamid   uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	TokenName string `protobuf:"bytes,2,opt,name=token_name,json=tokenName" json:"token_name"`
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Reset() {
	*m = CMsgAMSendEmail_PersonaNameReplacementToken{}
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgAMSendEmail_PersonaNameReplacementToken) ProtoMessage() {}
func (*CMsgAMSendEmail_PersonaNameReplacementToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{31, 1}
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMSendEmail_PersonaNameReplacementToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMSendEmail_PersonaNameReplacementToken.Merge(m, src)
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMSendEmail_PersonaNameReplacementToken.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMSendEmail_PersonaNameReplacementToken proto.InternalMessageInfo

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

type CMsgAMSendEmailResponse struct {
	Eresult *uint32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgAMSendEmailResponse) Reset()         { *m = CMsgAMSendEmailResponse{} }
func (m *CMsgAMSendEmailResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMSendEmailResponse) ProtoMessage()    {}
func (*CMsgAMSendEmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{32}
}
func (m *CMsgAMSendEmailResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMSendEmailResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMSendEmailResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMSendEmailResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMSendEmailResponse.Merge(m, src)
}
func (m *CMsgAMSendEmailResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMSendEmailResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMSendEmailResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMSendEmailResponse proto.InternalMessageInfo

const Default_CMsgAMSendEmailResponse_Eresult uint32 = 2

func (m *CMsgAMSendEmailResponse) GetEresult() uint32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMSendEmailResponse_Eresult
}

type CMsgGCGetEmailTemplate struct {
	AppId        uint32 `protobuf:"varint,1,opt,name=app_id,json=appId" json:"app_id"`
	EmailMsgType uint32 `protobuf:"varint,2,opt,name=email_msg_type,json=emailMsgType" json:"email_msg_type"`
	EmailLang    int32  `protobuf:"varint,3,opt,name=email_lang,json=emailLang" json:"email_lang"`
	EmailFormat  int32  `protobuf:"varint,4,opt,name=email_format,json=emailFormat" json:"email_format"`
}

func (m *CMsgGCGetEmailTemplate) Reset()         { *m = CMsgGCGetEmailTemplate{} }
func (m *CMsgGCGetEmailTemplate) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetEmailTemplate) ProtoMessage()    {}
func (*CMsgGCGetEmailTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{33}
}
func (m *CMsgGCGetEmailTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetEmailTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetEmailTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetEmailTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetEmailTemplate.Merge(m, src)
}
func (m *CMsgGCGetEmailTemplate) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetEmailTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetEmailTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetEmailTemplate proto.InternalMessageInfo

func (m *CMsgGCGetEmailTemplate) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailMsgType() uint32 {
	if m != nil {
		return m.EmailMsgType
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailLang() int32 {
	if m != nil {
		return m.EmailLang
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailFormat() int32 {
	if m != nil {
		return m.EmailFormat
	}
	return 0
}

type CMsgGCGetEmailTemplateResponse struct {
	Eresult        *uint32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	TemplateExists bool    `protobuf:"varint,2,opt,name=template_exists,json=templateExists" json:"template_exists"`
	Template       string  `protobuf:"bytes,3,opt,name=template" json:"template"`
}

func (m *CMsgGCGetEmailTemplateResponse) Reset()         { *m = CMsgGCGetEmailTemplateResponse{} }
func (m *CMsgGCGetEmailTemplateResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetEmailTemplateResponse) ProtoMessage()    {}
func (*CMsgGCGetEmailTemplateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{34}
}
func (m *CMsgGCGetEmailTemplateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetEmailTemplateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetEmailTemplateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetEmailTemplateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetEmailTemplateResponse.Merge(m, src)
}
func (m *CMsgGCGetEmailTemplateResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetEmailTemplateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetEmailTemplateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetEmailTemplateResponse proto.InternalMessageInfo

const Default_CMsgGCGetEmailTemplateResponse_Eresult uint32 = 2

func (m *CMsgGCGetEmailTemplateResponse) GetEresult() uint32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCGetEmailTemplateResponse_Eresult
}

func (m *CMsgGCGetEmailTemplateResponse) GetTemplateExists() bool {
	if m != nil {
		return m.TemplateExists
	}
	return false
}

func (m *CMsgGCGetEmailTemplateResponse) GetTemplate() string {
	if m != nil {
		return m.Template
	}
	return ""
}

type CMsgAMGrantGuestPasses2 struct {
	SteamId          uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	PackageId        uint32 `protobuf:"varint,2,opt,name=package_id,json=packageId" json:"package_id"`
	PassesToGrant    int32  `protobuf:"varint,3,opt,name=passes_to_grant,json=passesToGrant" json:"passes_to_grant"`
	DaysToExpiration int32  `protobuf:"varint,4,opt,name=days_to_expiration,json=daysToExpiration" json:"days_to_expiration"`
	Action           int32  `protobuf:"varint,5,opt,name=action" json:"action"`
}

func (m *CMsgAMGrantGuestPasses2) Reset()         { *m = CMsgAMGrantGuestPasses2{} }
func (m *CMsgAMGrantGuestPasses2) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGrantGuestPasses2) ProtoMessage()    {}
func (*CMsgAMGrantGuestPasses2) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{35}
}
func (m *CMsgAMGrantGuestPasses2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGrantGuestPasses2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGrantGuestPasses2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGrantGuestPasses2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGrantGuestPasses2.Merge(m, src)
}
func (m *CMsgAMGrantGuestPasses2) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGrantGuestPasses2) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGrantGuestPasses2.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGrantGuestPasses2 proto.InternalMessageInfo

func (m *CMsgAMGrantGuestPasses2) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetPackageId() uint32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetPassesToGrant() int32 {
	if m != nil {
		return m.PassesToGrant
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetDaysToExpiration() int32 {
	if m != nil {
		return m.DaysToExpiration
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

type CMsgAMGrantGuestPasses2Response struct {
	Eresult       *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	PassesGranted *int32 `protobuf:"varint,2,opt,name=passes_granted,json=passesGranted,def=0" json:"passes_granted,omitempty"`
}

func (m *CMsgAMGrantGuestPasses2Response) Reset()         { *m = CMsgAMGrantGuestPasses2Response{} }
func (m *CMsgAMGrantGuestPasses2Response) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGrantGuestPasses2Response) ProtoMessage()    {}
func (*CMsgAMGrantGuestPasses2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{36}
}
func (m *CMsgAMGrantGuestPasses2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgAMGrantGuestPasses2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgAMGrantGuestPasses2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgAMGrantGuestPasses2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgAMGrantGuestPasses2Response.Merge(m, src)
}
func (m *CMsgAMGrantGuestPasses2Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgAMGrantGuestPasses2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgAMGrantGuestPasses2Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgAMGrantGuestPasses2Response proto.InternalMessageInfo

const Default_CMsgAMGrantGuestPasses2Response_Eresult int32 = 2
const Default_CMsgAMGrantGuestPasses2Response_PassesGranted int32 = 0

func (m *CMsgAMGrantGuestPasses2Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMGrantGuestPasses2Response_Eresult
}

func (m *CMsgAMGrantGuestPasses2Response) GetPassesGranted() int32 {
	if m != nil && m.PassesGranted != nil {
		return *m.PassesGranted
	}
	return Default_CMsgAMGrantGuestPasses2Response_PassesGranted
}

type CGCSystemMsg_GetAccountDetails struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	Appid   uint32 `protobuf:"varint,2,opt,name=appid" json:"appid"`
}

func (m *CGCSystemMsg_GetAccountDetails) Reset()         { *m = CGCSystemMsg_GetAccountDetails{} }
func (m *CGCSystemMsg_GetAccountDetails) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetAccountDetails) ProtoMessage()    {}
func (*CGCSystemMsg_GetAccountDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{37}
}
func (m *CGCSystemMsg_GetAccountDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCSystemMsg_GetAccountDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCSystemMsg_GetAccountDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCSystemMsg_GetAccountDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCSystemMsg_GetAccountDetails.Merge(m, src)
}
func (m *CGCSystemMsg_GetAccountDetails) XXX_Size() int {
	return m.Size()
}
func (m *CGCSystemMsg_GetAccountDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCSystemMsg_GetAccountDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CGCSystemMsg_GetAccountDetails proto.InternalMessageInfo

func (m *CGCSystemMsg_GetAccountDetails) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

type CGCSystemMsg_GetAccountDetails_Response struct {
	EresultDeprecated      *uint32 `protobuf:"varint,1,opt,name=eresult_deprecated,json=eresultDeprecated,def=2" json:"eresult_deprecated,omitempty"`
	AccountName            string  `protobuf:"bytes,2,opt,name=account_name,json=accountName" json:"account_name"`
	PersonaName            string  `protobuf:"bytes,3,opt,name=persona_name,json=personaName" json:"persona_name"`
	IsProfilePublic        bool    `protobuf:"varint,4,opt,name=is_profile_public,json=isProfilePublic" json:"is_profile_public"`
	IsInventoryPublic      bool    `protobuf:"varint,5,opt,name=is_inventory_public,json=isInventoryPublic" json:"is_inventory_public"`
	IsVacBanned            bool    `protobuf:"varint,7,opt,name=is_vac_banned,json=isVacBanned" json:"is_vac_banned"`
	IsCyberCafe            bool    `protobuf:"varint,8,opt,name=is_cyber_cafe,json=isCyberCafe" json:"is_cyber_cafe"`
	IsSchoolAccount        bool    `protobuf:"varint,9,opt,name=is_school_account,json=isSchoolAccount" json:"is_school_account"`
	IsLimited              bool    `protobuf:"varint,10,opt,name=is_limited,json=isLimited" json:"is_limited"`
	IsSubscribed           bool    `protobuf:"varint,11,opt,name=is_subscribed,json=isSubscribed" json:"is_subscribed"`
	Package                uint32  `protobuf:"varint,12,opt,name=package" json:"package"`
	IsFreeTrialAccount     bool    `protobuf:"varint,13,opt,name=is_free_trial_account,json=isFreeTrialAccount" json:"is_free_trial_account"`
	FreeTrialExpiration    uint32  `protobuf:"varint,14,opt,name=free_trial_expiration,json=freeTrialExpiration" json:"free_trial_expiration"`
	IsLowViolence          bool    `protobuf:"varint,15,opt,name=is_low_violence,json=isLowViolence" json:"is_low_violence"`
	IsAccountLockedDown    bool    `protobuf:"varint,16,opt,name=is_account_locked_down,json=isAccountLockedDown" json:"is_account_locked_down"`
	IsCommunityBanned      bool    `protobuf:"varint,17,opt,name=is_community_banned,json=isCommunityBanned" json:"is_community_banned"`
	IsTradeBanned          bool    `protobuf:"varint,18,opt,name=is_trade_banned,json=isTradeBanned" json:"is_trade_banned"`
	TradeBanExpiration     uint32  `protobuf:"varint,19,opt,name=trade_ban_expiration,json=tradeBanExpiration" json:"trade_ban_expiration"`
	Accountid              uint32  `protobuf:"varint,20,opt,name=accountid" json:"accountid"`
	SuspensionEndTime      uint32  `protobuf:"varint,21,opt,name=suspension_end_time,json=suspensionEndTime" json:"suspension_end_time"`
	Currency               string  `protobuf:"bytes,22,opt,name=currency" json:"currency"`
	SteamLevel             uint32  `protobuf:"varint,23,opt,name=steam_level,json=steamLevel" json:"steam_level"`
	FriendCount            uint32  `protobuf:"varint,24,opt,name=friend_count,json=friendCount" json:"friend_count"`
	AccountCreationTime    uint32  `protobuf:"varint,25,opt,name=account_creation_time,json=accountCreationTime" json:"account_creation_time"`
	IsSteamguardEnabled    bool    `protobuf:"varint,27,opt,name=is_steamguard_enabled,json=isSteamguardEnabled" json:"is_steamguard_enabled"`
	IsPhoneVerified        bool    `protobuf:"varint,28,opt,name=is_phone_verified,json=isPhoneVerified" json:"is_phone_verified"`
	IsTwoFactorAuthEnabled bool    `protobuf:"varint,29,opt,name=is_two_factor_auth_enabled,json=isTwoFactorAuthEnabled" json:"is_two_factor_auth_enabled"`
	TwoFactorEnabledTime   uint32  `protobuf:"varint,30,opt,name=two_factor_enabled_time,json=twoFactorEnabledTime" json:"two_factor_enabled_time"`
	PhoneVerificationTime  uint32  `protobuf:"varint,31,opt,name=phone_verification_time,json=phoneVerificationTime" json:"phone_verification_time"`
	PhoneId                uint64  `protobuf:"varint,33,opt,name=phone_id,json=phoneId" json:"phone_id"`
	IsPhoneIdentifying     bool    `protobuf:"varint,34,opt,name=is_phone_identifying,json=isPhoneIdentifying" json:"is_phone_identifying"`
	RtIdentityLinked       uint32  `protobuf:"varint,35,opt,name=rt_identity_linked,json=rtIdentityLinked" json:"rt_identity_linked"`
	RtBirthDate            uint32  `protobuf:"varint,36,opt,name=rt_birth_date,json=rtBirthDate" json:"rt_birth_date"`
	TxnCountryCode         string  `protobuf:"bytes,37,opt,name=txn_country_code,json=txnCountryCode" json:"txn_country_code"`
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Reset() {
	*m = CGCSystemMsg_GetAccountDetails_Response{}
}
func (m *CGCSystemMsg_GetAccountDetails_Response) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetAccountDetails_Response) ProtoMessage()    {}
func (*CGCSystemMsg_GetAccountDetails_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{38}
}
func (m *CGCSystemMsg_GetAccountDetails_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCSystemMsg_GetAccountDetails_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCSystemMsg_GetAccountDetails_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCSystemMsg_GetAccountDetails_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCSystemMsg_GetAccountDetails_Response.Merge(m, src)
}
func (m *CGCSystemMsg_GetAccountDetails_Response) XXX_Size() int {
	return m.Size()
}
func (m *CGCSystemMsg_GetAccountDetails_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCSystemMsg_GetAccountDetails_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CGCSystemMsg_GetAccountDetails_Response proto.InternalMessageInfo

const Default_CGCSystemMsg_GetAccountDetails_Response_EresultDeprecated uint32 = 2

func (m *CGCSystemMsg_GetAccountDetails_Response) GetEresultDeprecated() uint32 {
	if m != nil && m.EresultDeprecated != nil {
		return *m.EresultDeprecated
	}
	return Default_CGCSystemMsg_GetAccountDetails_Response_EresultDeprecated
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPersonaName() string {
	if m != nil {
		return m.PersonaName
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsProfilePublic() bool {
	if m != nil {
		return m.IsProfilePublic
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsInventoryPublic() bool {
	if m != nil {
		return m.IsInventoryPublic
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsVacBanned() bool {
	if m != nil {
		return m.IsVacBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsCyberCafe() bool {
	if m != nil {
		return m.IsCyberCafe
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSchoolAccount() bool {
	if m != nil {
		return m.IsSchoolAccount
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsLimited() bool {
	if m != nil {
		return m.IsLimited
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSubscribed() bool {
	if m != nil {
		return m.IsSubscribed
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPackage() uint32 {
	if m != nil {
		return m.Package
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsFreeTrialAccount() bool {
	if m != nil {
		return m.IsFreeTrialAccount
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetFreeTrialExpiration() uint32 {
	if m != nil {
		return m.FreeTrialExpiration
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsLowViolence() bool {
	if m != nil {
		return m.IsLowViolence
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsAccountLockedDown() bool {
	if m != nil {
		return m.IsAccountLockedDown
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsCommunityBanned() bool {
	if m != nil {
		return m.IsCommunityBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsTradeBanned() bool {
	if m != nil {
		return m.IsTradeBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetTradeBanExpiration() uint32 {
	if m != nil {
		return m.TradeBanExpiration
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountid() uint32 {
	if m != nil {
		return m.Accountid
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetSuspensionEndTime() uint32 {
	if m != nil {
		return m.SuspensionEndTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetSteamLevel() uint32 {
	if m != nil {
		return m.SteamLevel
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetFriendCount() uint32 {
	if m != nil {
		return m.FriendCount
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountCreationTime() uint32 {
	if m != nil {
		return m.AccountCreationTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSteamguardEnabled() bool {
	if m != nil {
		return m.IsSteamguardEnabled
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsPhoneVerified() bool {
	if m != nil {
		return m.IsPhoneVerified
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsTwoFactorAuthEnabled() bool {
	if m != nil {
		return m.IsTwoFactorAuthEnabled
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetTwoFactorEnabledTime() uint32 {
	if m != nil {
		return m.TwoFactorEnabledTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPhoneVerificationTime() uint32 {
	if m != nil {
		return m.PhoneVerificationTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPhoneId() uint64 {
	if m != nil {
		return m.PhoneId
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsPhoneIdentifying() bool {
	if m != nil {
		return m.IsPhoneIdentifying
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetRtIdentityLinked() uint32 {
	if m != nil {
		return m.RtIdentityLinked
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetRtBirthDate() uint32 {
	if m != nil {
		return m.RtBirthDate
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetTxnCountryCode() string {
	if m != nil {
		return m.TxnCountryCode
	}
	return ""
}

type CMsgGCGetPersonaNames struct {
	Steamids []uint64 `protobuf:"fixed64,1,rep,name=steamids" json:"steamids,omitempty"`
}

func (m *CMsgGCGetPersonaNames) Reset()         { *m = CMsgGCGetPersonaNames{} }
func (m *CMsgGCGetPersonaNames) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPersonaNames) ProtoMessage()    {}
func (*CMsgGCGetPersonaNames) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{39}
}
func (m *CMsgGCGetPersonaNames) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetPersonaNames) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetPersonaNames.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetPersonaNames) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetPersonaNames.Merge(m, src)
}
func (m *CMsgGCGetPersonaNames) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetPersonaNames) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetPersonaNames.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetPersonaNames proto.InternalMessageInfo

func (m *CMsgGCGetPersonaNames) GetSteamids() []uint64 {
	if m != nil {
		return m.Steamids
	}
	return nil
}

type CMsgGCGetPersonaNames_Response struct {
	SucceededLookups     []*CMsgGCGetPersonaNames_Response_PersonaName `protobuf:"bytes,1,rep,name=succeeded_lookups,json=succeededLookups" json:"succeeded_lookups,omitempty"`
	FailedLookupSteamids []uint64                                      `protobuf:"fixed64,2,rep,name=failed_lookup_steamids,json=failedLookupSteamids" json:"failed_lookup_steamids,omitempty"`
}

func (m *CMsgGCGetPersonaNames_Response) Reset()         { *m = CMsgGCGetPersonaNames_Response{} }
func (m *CMsgGCGetPersonaNames_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPersonaNames_Response) ProtoMessage()    {}
func (*CMsgGCGetPersonaNames_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{40}
}
func (m *CMsgGCGetPersonaNames_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetPersonaNames_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetPersonaNames_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetPersonaNames_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetPersonaNames_Response.Merge(m, src)
}
func (m *CMsgGCGetPersonaNames_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetPersonaNames_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetPersonaNames_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetPersonaNames_Response proto.InternalMessageInfo

func (m *CMsgGCGetPersonaNames_Response) GetSucceededLookups() []*CMsgGCGetPersonaNames_Response_PersonaName {
	if m != nil {
		return m.SucceededLookups
	}
	return nil
}

func (m *CMsgGCGetPersonaNames_Response) GetFailedLookupSteamids() []uint64 {
	if m != nil {
		return m.FailedLookupSteamids
	}
	return nil
}

type CMsgGCGetPersonaNames_Response_PersonaName struct {
	Steamid     uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	PersonaName string `protobuf:"bytes,2,opt,name=persona_name,json=personaName" json:"persona_name"`
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Reset() {
	*m = CMsgGCGetPersonaNames_Response_PersonaName{}
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgGCGetPersonaNames_Response_PersonaName) ProtoMessage() {}
func (*CMsgGCGetPersonaNames_Response_PersonaName) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{40, 0}
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetPersonaNames_Response_PersonaName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetPersonaNames_Response_PersonaName.Merge(m, src)
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetPersonaNames_Response_PersonaName.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetPersonaNames_Response_PersonaName proto.InternalMessageInfo

func (m *CMsgGCGetPersonaNames_Response_PersonaName) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) GetPersonaName() string {
	if m != nil {
		return m.PersonaName
	}
	return ""
}

type CMsgGCCheckFriendship struct {
	SteamidLeft  uint64 `protobuf:"fixed64,1,opt,name=steamid_left,json=steamidLeft" json:"steamid_left"`
	SteamidRight uint64 `protobuf:"fixed64,2,opt,name=steamid_right,json=steamidRight" json:"steamid_right"`
}

func (m *CMsgGCCheckFriendship) Reset()         { *m = CMsgGCCheckFriendship{} }
func (m *CMsgGCCheckFriendship) String() string { return proto.CompactTextString(m) }
func (*CMsgGCCheckFriendship) ProtoMessage()    {}
func (*CMsgGCCheckFriendship) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{41}
}
func (m *CMsgGCCheckFriendship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCCheckFriendship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCCheckFriendship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCCheckFriendship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCCheckFriendship.Merge(m, src)
}
func (m *CMsgGCCheckFriendship) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCCheckFriendship) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCCheckFriendship.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCCheckFriendship proto.InternalMessageInfo

func (m *CMsgGCCheckFriendship) GetSteamidLeft() uint64 {
	if m != nil {
		return m.SteamidLeft
	}
	return 0
}

func (m *CMsgGCCheckFriendship) GetSteamidRight() uint64 {
	if m != nil {
		return m.SteamidRight
	}
	return 0
}

type CMsgGCCheckFriendship_Response struct {
	Success         bool `protobuf:"varint,1,opt,name=success" json:"success"`
	FoundFriendship bool `protobuf:"varint,2,opt,name=found_friendship,json=foundFriendship" json:"found_friendship"`
}

func (m *CMsgGCCheckFriendship_Response) Reset()         { *m = CMsgGCCheckFriendship_Response{} }
func (m *CMsgGCCheckFriendship_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCCheckFriendship_Response) ProtoMessage()    {}
func (*CMsgGCCheckFriendship_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{42}
}
func (m *CMsgGCCheckFriendship_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCCheckFriendship_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCCheckFriendship_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCCheckFriendship_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCCheckFriendship_Response.Merge(m, src)
}
func (m *CMsgGCCheckFriendship_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCCheckFriendship_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCCheckFriendship_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCCheckFriendship_Response proto.InternalMessageInfo

func (m *CMsgGCCheckFriendship_Response) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CMsgGCCheckFriendship_Response) GetFoundFriendship() bool {
	if m != nil {
		return m.FoundFriendship
	}
	return false
}

type CMsgGCMsgMasterSetDirectory struct {
	MasterDirIndex uint32                               `protobuf:"varint,1,opt,name=master_dir_index,json=masterDirIndex" json:"master_dir_index"`
	Dir            []*CMsgGCMsgMasterSetDirectory_SubGC `protobuf:"bytes,2,rep,name=dir" json:"dir,omitempty"`
}

func (m *CMsgGCMsgMasterSetDirectory) Reset()         { *m = CMsgGCMsgMasterSetDirectory{} }
func (m *CMsgGCMsgMasterSetDirectory) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{43}
}
func (m *CMsgGCMsgMasterSetDirectory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetDirectory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetDirectory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetDirectory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetDirectory) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetDirectory) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetDirectory proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetDirectory) GetMasterDirIndex() uint32 {
	if m != nil {
		return m.MasterDirIndex
	}
	return 0
}

func (m *CMsgGCMsgMasterSetDirectory) GetDir() []*CMsgGCMsgMasterSetDirectory_SubGC {
	if m != nil {
		return m.Dir
	}
	return nil
}

type CMsgGCMsgMasterSetDirectory_SubGC struct {
	DirIndex    uint32 `protobuf:"varint,1,opt,name=dir_index,json=dirIndex" json:"dir_index"`
	Name        string `protobuf:"bytes,2,opt,name=name" json:"name"`
	Box         string `protobuf:"bytes,3,opt,name=box" json:"box"`
	CommandLine string `protobuf:"bytes,4,opt,name=command_line,json=commandLine" json:"command_line"`
	GcBinary    string `protobuf:"bytes,5,opt,name=gc_binary,json=gcBinary" json:"gc_binary"`
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Reset()         { *m = CMsgGCMsgMasterSetDirectory_SubGC{} }
func (m *CMsgGCMsgMasterSetDirectory_SubGC) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory_SubGC) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory_SubGC) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{43, 0}
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetDirectory_SubGC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory_SubGC.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory_SubGC.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetDirectory_SubGC proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetDirIndex() uint32 {
	if m != nil {
		return m.DirIndex
	}
	return 0
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetBox() string {
	if m != nil {
		return m.Box
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetCommandLine() string {
	if m != nil {
		return m.CommandLine
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetGcBinary() string {
	if m != nil {
		return m.GcBinary
	}
	return ""
}

type CMsgGCMsgMasterSetDirectory_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Reset()         { *m = CMsgGCMsgMasterSetDirectory_Response{} }
func (m *CMsgGCMsgMasterSetDirectory_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory_Response) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{44}
}
func (m *CMsgGCMsgMasterSetDirectory_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetDirectory_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetDirectory_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetDirectory_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory_Response.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetDirectory_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetDirectory_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetDirectory_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetDirectory_Response proto.InternalMessageInfo

const Default_CMsgGCMsgMasterSetDirectory_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetDirectory_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetDirectory_Response_Eresult
}

type CMsgGCMsgWebAPIJobRequestForwardResponse struct {
	DirIndex uint32 `protobuf:"varint,1,opt,name=dir_index,json=dirIndex" json:"dir_index"`
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Reset() {
	*m = CMsgGCMsgWebAPIJobRequestForwardResponse{}
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgWebAPIJobRequestForwardResponse) ProtoMessage()    {}
func (*CMsgGCMsgWebAPIJobRequestForwardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{45}
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgWebAPIJobRequestForwardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgWebAPIJobRequestForwardResponse.Merge(m, src)
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgWebAPIJobRequestForwardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgWebAPIJobRequestForwardResponse proto.InternalMessageInfo

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) GetDirIndex() uint32 {
	if m != nil {
		return m.DirIndex
	}
	return 0
}

type CGCSystemMsg_GetPurchaseTrust_Request struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Reset()         { *m = CGCSystemMsg_GetPurchaseTrust_Request{} }
func (m *CGCSystemMsg_GetPurchaseTrust_Request) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetPurchaseTrust_Request) ProtoMessage()    {}
func (*CGCSystemMsg_GetPurchaseTrust_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{46}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Request.Merge(m, src)
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) XXX_Size() int {
	return m.Size()
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Request.DiscardUnknown(m)
}

var xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Request proto.InternalMessageInfo

func (m *CGCSystemMsg_GetPurchaseTrust_Request) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CGCSystemMsg_GetPurchaseTrust_Response struct {
	HasPriorPurchaseHistory   bool   `protobuf:"varint,1,opt,name=has_prior_purchase_history,json=hasPriorPurchaseHistory" json:"has_prior_purchase_history"`
	HasNoRecentPasswordResets bool   `protobuf:"varint,2,opt,name=has_no_recent_password_resets,json=hasNoRecentPasswordResets" json:"has_no_recent_password_resets"`
	IsWalletCashTrusted       bool   `protobuf:"varint,3,opt,name=is_wallet_cash_trusted,json=isWalletCashTrusted" json:"is_wallet_cash_trusted"`
	TimeAllTrusted            uint32 `protobuf:"varint,4,opt,name=time_all_trusted,json=timeAllTrusted" json:"time_all_trusted"`
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Reset() {
	*m = CGCSystemMsg_GetPurchaseTrust_Response{}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetPurchaseTrust_Response) ProtoMessage()    {}
func (*CGCSystemMsg_GetPurchaseTrust_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{47}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Response.Merge(m, src)
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) XXX_Size() int {
	return m.Size()
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CGCSystemMsg_GetPurchaseTrust_Response proto.InternalMessageInfo

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetHasPriorPurchaseHistory() bool {
	if m != nil {
		return m.HasPriorPurchaseHistory
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetHasNoRecentPasswordResets() bool {
	if m != nil {
		return m.HasNoRecentPasswordResets
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetIsWalletCashTrusted() bool {
	if m != nil {
		return m.IsWalletCashTrusted
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetTimeAllTrusted() uint32 {
	if m != nil {
		return m.TimeAllTrusted
	}
	return 0
}

type CMsgGCHAccountVacStatusChange struct {
	SteamId           uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	AppId             uint32 `protobuf:"varint,2,opt,name=app_id,json=appId" json:"app_id"`
	RtimeVacbanStarts uint32 `protobuf:"varint,3,opt,name=rtime_vacban_starts,json=rtimeVacbanStarts" json:"rtime_vacban_starts"`
	IsBannedNow       bool   `protobuf:"varint,4,opt,name=is_banned_now,json=isBannedNow" json:"is_banned_now"`
	IsBannedFuture    bool   `protobuf:"varint,5,opt,name=is_banned_future,json=isBannedFuture" json:"is_banned_future"`
}

func (m *CMsgGCHAccountVacStatusChange) Reset()         { *m = CMsgGCHAccountVacStatusChange{} }
func (m *CMsgGCHAccountVacStatusChange) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHAccountVacStatusChange) ProtoMessage()    {}
func (*CMsgGCHAccountVacStatusChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{48}
}
func (m *CMsgGCHAccountVacStatusChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCHAccountVacStatusChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCHAccountVacStatusChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCHAccountVacStatusChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCHAccountVacStatusChange.Merge(m, src)
}
func (m *CMsgGCHAccountVacStatusChange) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCHAccountVacStatusChange) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCHAccountVacStatusChange.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCHAccountVacStatusChange proto.InternalMessageInfo

func (m *CMsgGCHAccountVacStatusChange) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetRtimeVacbanStarts() uint32 {
	if m != nil {
		return m.RtimeVacbanStarts
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetIsBannedNow() bool {
	if m != nil {
		return m.IsBannedNow
	}
	return false
}

func (m *CMsgGCHAccountVacStatusChange) GetIsBannedFuture() bool {
	if m != nil {
		return m.IsBannedFuture
	}
	return false
}

type CMsgGCGetPartnerAccountLink struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CMsgGCGetPartnerAccountLink) Reset()         { *m = CMsgGCGetPartnerAccountLink{} }
func (m *CMsgGCGetPartnerAccountLink) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPartnerAccountLink) ProtoMessage()    {}
func (*CMsgGCGetPartnerAccountLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{49}
}
func (m *CMsgGCGetPartnerAccountLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetPartnerAccountLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetPartnerAccountLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetPartnerAccountLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetPartnerAccountLink.Merge(m, src)
}
func (m *CMsgGCGetPartnerAccountLink) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetPartnerAccountLink) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetPartnerAccountLink.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetPartnerAccountLink proto.InternalMessageInfo

func (m *CMsgGCGetPartnerAccountLink) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CMsgGCGetPartnerAccountLink_Response struct {
	Pwid    uint32 `protobuf:"varint,1,opt,name=pwid" json:"pwid"`
	Nexonid uint32 `protobuf:"varint,2,opt,name=nexonid" json:"nexonid"`
}

func (m *CMsgGCGetPartnerAccountLink_Response) Reset()         { *m = CMsgGCGetPartnerAccountLink_Response{} }
func (m *CMsgGCGetPartnerAccountLink_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPartnerAccountLink_Response) ProtoMessage()    {}
func (*CMsgGCGetPartnerAccountLink_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{50}
}
func (m *CMsgGCGetPartnerAccountLink_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCGetPartnerAccountLink_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCGetPartnerAccountLink_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCGetPartnerAccountLink_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCGetPartnerAccountLink_Response.Merge(m, src)
}
func (m *CMsgGCGetPartnerAccountLink_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCGetPartnerAccountLink_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCGetPartnerAccountLink_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCGetPartnerAccountLink_Response proto.InternalMessageInfo

func (m *CMsgGCGetPartnerAccountLink_Response) GetPwid() uint32 {
	if m != nil {
		return m.Pwid
	}
	return 0
}

func (m *CMsgGCGetPartnerAccountLink_Response) GetNexonid() uint32 {
	if m != nil {
		return m.Nexonid
	}
	return 0
}

type CMsgGCRoutingInfo struct {
	DirIndex      []uint32                         `protobuf:"varint,1,rep,name=dir_index,json=dirIndex" json:"dir_index,omitempty"`
	Method        *CMsgGCRoutingInfo_RoutingMethod `protobuf:"varint,2,opt,name=method,enum=CMsgGCRoutingInfo_RoutingMethod,def=0" json:"method,omitempty"`
	Fallback      *CMsgGCRoutingInfo_RoutingMethod `protobuf:"varint,3,opt,name=fallback,enum=CMsgGCRoutingInfo_RoutingMethod,def=1" json:"fallback,omitempty"`
	ProtobufField uint32                           `protobuf:"varint,4,opt,name=protobuf_field,json=protobufField" json:"protobuf_field"`
	WebapiParam   string                           `protobuf:"bytes,5,opt,name=webapi_param,json=webapiParam" json:"webapi_param"`
}

func (m *CMsgGCRoutingInfo) Reset()         { *m = CMsgGCRoutingInfo{} }
func (m *CMsgGCRoutingInfo) String() string { return proto.CompactTextString(m) }
func (*CMsgGCRoutingInfo) ProtoMessage()    {}
func (*CMsgGCRoutingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{51}
}
func (m *CMsgGCRoutingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCRoutingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCRoutingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCRoutingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCRoutingInfo.Merge(m, src)
}
func (m *CMsgGCRoutingInfo) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCRoutingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCRoutingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCRoutingInfo proto.InternalMessageInfo

const Default_CMsgGCRoutingInfo_Method CMsgGCRoutingInfo_RoutingMethod = CMsgGCRoutingInfo_RANDOM
const Default_CMsgGCRoutingInfo_Fallback CMsgGCRoutingInfo_RoutingMethod = CMsgGCRoutingInfo_DISCARD

func (m *CMsgGCRoutingInfo) GetDirIndex() []uint32 {
	if m != nil {
		return m.DirIndex
	}
	return nil
}

func (m *CMsgGCRoutingInfo) GetMethod() CMsgGCRoutingInfo_RoutingMethod {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return Default_CMsgGCRoutingInfo_Method
}

func (m *CMsgGCRoutingInfo) GetFallback() CMsgGCRoutingInfo_RoutingMethod {
	if m != nil && m.Fallback != nil {
		return *m.Fallback
	}
	return Default_CMsgGCRoutingInfo_Fallback
}

func (m *CMsgGCRoutingInfo) GetProtobufField() uint32 {
	if m != nil {
		return m.ProtobufField
	}
	return 0
}

func (m *CMsgGCRoutingInfo) GetWebapiParam() string {
	if m != nil {
		return m.WebapiParam
	}
	return ""
}

type CMsgGCMsgMasterSetWebAPIRouting struct {
	Entries []*CMsgGCMsgMasterSetWebAPIRouting_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Reset()         { *m = CMsgGCMsgMasterSetWebAPIRouting{} }
func (m *CMsgGCMsgMasterSetWebAPIRouting) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{52}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetWebAPIRouting) GetEntries() []*CMsgGCMsgMasterSetWebAPIRouting_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CMsgGCMsgMasterSetWebAPIRouting_Entry struct {
	InterfaceName string             `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName" json:"interface_name"`
	MethodName    string             `protobuf:"bytes,2,opt,name=method_name,json=methodName" json:"method_name"`
	Routing       *CMsgGCRoutingInfo `protobuf:"bytes,3,opt,name=routing" json:"routing,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Reset()         { *m = CMsgGCMsgMasterSetWebAPIRouting_Entry{} }
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting_Entry) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{52, 0}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Entry.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Entry proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetRouting() *CMsgGCRoutingInfo {
	if m != nil {
		return m.Routing
	}
	return nil
}

type CMsgGCMsgMasterSetClientMsgRouting struct {
	Entries []*CMsgGCMsgMasterSetClientMsgRouting_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Reset()         { *m = CMsgGCMsgMasterSetClientMsgRouting{} }
func (m *CMsgGCMsgMasterSetClientMsgRouting) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetClientMsgRouting) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetClientMsgRouting) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{53}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetClientMsgRouting) GetEntries() []*CMsgGCMsgMasterSetClientMsgRouting_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CMsgGCMsgMasterSetClientMsgRouting_Entry struct {
	MsgType uint32             `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	Routing *CMsgGCRoutingInfo `protobuf:"bytes,2,opt,name=routing" json:"routing,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Reset() {
	*m = CMsgGCMsgMasterSetClientMsgRouting_Entry{}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetClientMsgRouting_Entry) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetClientMsgRouting_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{53, 0}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Entry.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Entry proto.InternalMessageInfo

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) GetRouting() *CMsgGCRoutingInfo {
	if m != nil {
		return m.Routing
	}
	return nil
}

type CMsgGCMsgMasterSetWebAPIRouting_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Reset() {
	*m = CMsgGCMsgMasterSetWebAPIRouting_Response{}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting_Response) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{54}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Response.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetWebAPIRouting_Response proto.InternalMessageInfo

const Default_CMsgGCMsgMasterSetWebAPIRouting_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetWebAPIRouting_Response_Eresult
}

type CMsgGCMsgMasterSetClientMsgRouting_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Reset() {
	*m = CMsgGCMsgMasterSetClientMsgRouting_Response{}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgGCMsgMasterSetClientMsgRouting_Response) ProtoMessage() {}
func (*CMsgGCMsgMasterSetClientMsgRouting_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{55}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Response.Merge(m, src)
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Response.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgMasterSetClientMsgRouting_Response proto.InternalMessageInfo

const Default_CMsgGCMsgMasterSetClientMsgRouting_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetClientMsgRouting_Response_Eresult
}

type CMsgGCMsgSetOptions struct {
	Options         []CMsgGCMsgSetOptions_Option        `protobuf:"varint,1,rep,name=options,enum=CMsgGCMsgSetOptions_Option" json:"options,omitempty"`
	ClientMsgRanges []*CMsgGCMsgSetOptions_MessageRange `protobuf:"bytes,2,rep,name=client_msg_ranges,json=clientMsgRanges" json:"client_msg_ranges,omitempty"`
}

func (m *CMsgGCMsgSetOptions) Reset()         { *m = CMsgGCMsgSetOptions{} }
func (m *CMsgGCMsgSetOptions) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgSetOptions) ProtoMessage()    {}
func (*CMsgGCMsgSetOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{56}
}
func (m *CMsgGCMsgSetOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgSetOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgSetOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgSetOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgSetOptions.Merge(m, src)
}
func (m *CMsgGCMsgSetOptions) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgSetOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgSetOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgSetOptions proto.InternalMessageInfo

func (m *CMsgGCMsgSetOptions) GetOptions() []CMsgGCMsgSetOptions_Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *CMsgGCMsgSetOptions) GetClientMsgRanges() []*CMsgGCMsgSetOptions_MessageRange {
	if m != nil {
		return m.ClientMsgRanges
	}
	return nil
}

type CMsgGCMsgSetOptions_MessageRange struct {
	Low  uint32 `protobuf:"varint,1,req,name=low" json:"low"`
	High uint32 `protobuf:"varint,2,req,name=high" json:"high"`
}

func (m *CMsgGCMsgSetOptions_MessageRange) Reset()         { *m = CMsgGCMsgSetOptions_MessageRange{} }
func (m *CMsgGCMsgSetOptions_MessageRange) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgSetOptions_MessageRange) ProtoMessage()    {}
func (*CMsgGCMsgSetOptions_MessageRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{56, 0}
}
func (m *CMsgGCMsgSetOptions_MessageRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCMsgSetOptions_MessageRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCMsgSetOptions_MessageRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCMsgSetOptions_MessageRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCMsgSetOptions_MessageRange.Merge(m, src)
}
func (m *CMsgGCMsgSetOptions_MessageRange) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCMsgSetOptions_MessageRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCMsgSetOptions_MessageRange.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCMsgSetOptions_MessageRange proto.InternalMessageInfo

func (m *CMsgGCMsgSetOptions_MessageRange) GetLow() uint32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *CMsgGCMsgSetOptions_MessageRange) GetHigh() uint32 {
	if m != nil {
		return m.High
	}
	return 0
}

type CMsgGCHUpdateSession struct {
	SteamId             uint64                             `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	AppId               uint32                             `protobuf:"varint,2,opt,name=app_id,json=appId" json:"app_id"`
	Online              bool                               `protobuf:"varint,3,opt,name=online" json:"online"`
	ServerSteamId       uint64                             `protobuf:"fixed64,4,opt,name=server_steam_id,json=serverSteamId" json:"server_steam_id"`
	ServerAddr          uint32                             `protobuf:"varint,5,opt,name=server_addr,json=serverAddr" json:"server_addr"`
	ServerPort          uint32                             `protobuf:"varint,6,opt,name=server_port,json=serverPort" json:"server_port"`
	OsType              uint32                             `protobuf:"varint,7,opt,name=os_type,json=osType" json:"os_type"`
	ClientAddr          uint32                             `protobuf:"varint,8,opt,name=client_addr,json=clientAddr" json:"client_addr"`
	ExtraFields         []*CMsgGCHUpdateSession_ExtraField `protobuf:"bytes,9,rep,name=extra_fields,json=extraFields" json:"extra_fields,omitempty"`
	OwnerId             uint64                             `protobuf:"fixed64,10,opt,name=owner_id,json=ownerId" json:"owner_id"`
	CmSessionSysid      uint32                             `protobuf:"varint,11,opt,name=cm_session_sysid,json=cmSessionSysid" json:"cm_session_sysid"`
	CmSessionIdentifier uint32                             `protobuf:"varint,12,opt,name=cm_session_identifier,json=cmSessionIdentifier" json:"cm_session_identifier"`
	DepotIds            []uint32                           `protobuf:"varint,13,rep,name=depot_ids,json=depotIds" json:"depot_ids,omitempty"`
}

func (m *CMsgGCHUpdateSession) Reset()         { *m = CMsgGCHUpdateSession{} }
func (m *CMsgGCHUpdateSession) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHUpdateSession) ProtoMessage()    {}
func (*CMsgGCHUpdateSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{57}
}
func (m *CMsgGCHUpdateSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCHUpdateSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCHUpdateSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCHUpdateSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCHUpdateSession.Merge(m, src)
}
func (m *CMsgGCHUpdateSession) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCHUpdateSession) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCHUpdateSession.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCHUpdateSession proto.InternalMessageInfo

func (m *CMsgGCHUpdateSession) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *CMsgGCHUpdateSession) GetServerSteamId() uint64 {
	if m != nil {
		return m.ServerSteamId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetServerAddr() uint32 {
	if m != nil {
		return m.ServerAddr
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetOsType() uint32 {
	if m != nil {
		return m.OsType
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetClientAddr() uint32 {
	if m != nil {
		return m.ClientAddr
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetExtraFields() []*CMsgGCHUpdateSession_ExtraField {
	if m != nil {
		return m.ExtraFields
	}
	return nil
}

func (m *CMsgGCHUpdateSession) GetOwnerId() uint64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetCmSessionSysid() uint32 {
	if m != nil {
		return m.CmSessionSysid
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetCmSessionIdentifier() uint32 {
	if m != nil {
		return m.CmSessionIdentifier
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetDepotIds() []uint32 {
	if m != nil {
		return m.DepotIds
	}
	return nil
}

type CMsgGCHUpdateSession_ExtraField struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgGCHUpdateSession_ExtraField) Reset()         { *m = CMsgGCHUpdateSession_ExtraField{} }
func (m *CMsgGCHUpdateSession_ExtraField) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHUpdateSession_ExtraField) ProtoMessage()    {}
func (*CMsgGCHUpdateSession_ExtraField) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{57, 0}
}
func (m *CMsgGCHUpdateSession_ExtraField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgGCHUpdateSession_ExtraField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgGCHUpdateSession_ExtraField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgGCHUpdateSession_ExtraField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgGCHUpdateSession_ExtraField.Merge(m, src)
}
func (m *CMsgGCHUpdateSession_ExtraField) XXX_Size() int {
	return m.Size()
}
func (m *CMsgGCHUpdateSession_ExtraField) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgGCHUpdateSession_ExtraField.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgGCHUpdateSession_ExtraField proto.InternalMessageInfo

func (m *CMsgGCHUpdateSession_ExtraField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgGCHUpdateSession_ExtraField) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgNotificationOfSuspiciousActivity struct {
	Steamid           uint64                                                      `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	Appid             uint32                                                      `protobuf:"varint,2,opt,name=appid" json:"appid"`
	MultipleInstances *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances `protobuf:"bytes,3,opt,name=multiple_instances,json=multipleInstances" json:"multiple_instances,omitempty"`
}

func (m *CMsgNotificationOfSuspiciousActivity) Reset()         { *m = CMsgNotificationOfSuspiciousActivity{} }
func (m *CMsgNotificationOfSuspiciousActivity) String() string { return proto.CompactTextString(m) }
func (*CMsgNotificationOfSuspiciousActivity) ProtoMessage()    {}
func (*CMsgNotificationOfSuspiciousActivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{58}
}
func (m *CMsgNotificationOfSuspiciousActivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgNotificationOfSuspiciousActivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgNotificationOfSuspiciousActivity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgNotificationOfSuspiciousActivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgNotificationOfSuspiciousActivity.Merge(m, src)
}
func (m *CMsgNotificationOfSuspiciousActivity) XXX_Size() int {
	return m.Size()
}
func (m *CMsgNotificationOfSuspiciousActivity) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgNotificationOfSuspiciousActivity.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgNotificationOfSuspiciousActivity proto.InternalMessageInfo

func (m *CMsgNotificationOfSuspiciousActivity) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity) GetMultipleInstances() *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
	if m != nil {
		return m.MultipleInstances
	}
	return nil
}

type CMsgNotificationOfSuspiciousActivity_MultipleGameInstances struct {
	AppInstanceCount uint32   `protobuf:"varint,1,opt,name=app_instance_count,json=appInstanceCount" json:"app_instance_count"`
	OtherSteamids    []uint64 `protobuf:"fixed64,2,rep,name=other_steamids,json=otherSteamids" json:"other_steamids,omitempty"`
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Reset() {
	*m = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances{}
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) ProtoMessage() {}
func (*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{58, 0}
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.Merge(m, src)
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) XXX_Size() int {
	return m.Size()
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgNotificationOfSuspiciousActivity_MultipleGameInstances proto.InternalMessageInfo

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) GetAppInstanceCount() uint32 {
	if m != nil {
		return m.AppInstanceCount
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) GetOtherSteamids() []uint64 {
	if m != nil {
		return m.OtherSteamids
	}
	return nil
}

type CMsgDPPartnerMicroTxns struct {
	Appid        uint32                                    `protobuf:"varint,1,opt,name=appid" json:"appid"`
	GcName       string                                    `protobuf:"bytes,2,opt,name=gc_name,json=gcName" json:"gc_name"`
	Partner      *CMsgDPPartnerMicroTxns_PartnerInfo       `protobuf:"bytes,3,opt,name=partner" json:"partner,omitempty"`
	Transactions []*CMsgDPPartnerMicroTxns_PartnerMicroTxn `protobuf:"bytes,4,rep,name=transactions" json:"transactions,omitempty"`
}

func (m *CMsgDPPartnerMicroTxns) Reset()         { *m = CMsgDPPartnerMicroTxns{} }
func (m *CMsgDPPartnerMicroTxns) String() string { return proto.CompactTextString(m) }
func (*CMsgDPPartnerMicroTxns) ProtoMessage()    {}
func (*CMsgDPPartnerMicroTxns) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{59}
}
func (m *CMsgDPPartnerMicroTxns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgDPPartnerMicroTxns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgDPPartnerMicroTxns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgDPPartnerMicroTxns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgDPPartnerMicroTxns.Merge(m, src)
}
func (m *CMsgDPPartnerMicroTxns) XXX_Size() int {
	return m.Size()
}
func (m *CMsgDPPartnerMicroTxns) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgDPPartnerMicroTxns.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgDPPartnerMicroTxns proto.InternalMessageInfo

func (m *CMsgDPPartnerMicroTxns) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns) GetGcName() string {
	if m != nil {
		return m.GcName
	}
	return ""
}

func (m *CMsgDPPartnerMicroTxns) GetPartner() *CMsgDPPartnerMicroTxns_PartnerInfo {
	if m != nil {
		return m.Partner
	}
	return nil
}

func (m *CMsgDPPartnerMicroTxns) GetTransactions() []*CMsgDPPartnerMicroTxns_PartnerMicroTxn {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type CMsgDPPartnerMicroTxns_PartnerMicroTxn struct {
	InitTime       uint32 `protobuf:"varint,1,opt,name=init_time,json=initTime" json:"init_time"`
	LastUpdateTime uint32 `protobuf:"varint,2,opt,name=last_update_time,json=lastUpdateTime" json:"last_update_time"`
	TxnId          uint64 `protobuf:"varint,3,opt,name=txn_id,json=txnId" json:"txn_id"`
	AccountId      uint32 `protobuf:"varint,4,opt,name=account_id,json=accountId" json:"account_id"`
	LineItem       uint32 `protobuf:"varint,5,opt,name=line_item,json=lineItem" json:"line_item"`
	ItemId         uint64 `protobuf:"varint,6,opt,name=item_id,json=itemId" json:"item_id"`
	DefIndex       uint32 `protobuf:"varint,7,opt,name=def_index,json=defIndex" json:"def_index"`
	Price          uint64 `protobuf:"varint,8,opt,name=price" json:"price"`
	Tax            uint64 `protobuf:"varint,9,opt,name=tax" json:"tax"`
	PriceUsd       uint64 `protobuf:"varint,10,opt,name=price_usd,json=priceUsd" json:"price_usd"`
	TaxUsd         uint64 `protobuf:"varint,11,opt,name=tax_usd,json=taxUsd" json:"tax_usd"`
	PurchaseType   uint32 `protobuf:"varint,12,opt,name=purchase_type,json=purchaseType" json:"purchase_type"`
	SteamTxnType   uint32 `protobuf:"varint,13,opt,name=steam_txn_type,json=steamTxnType" json:"steam_txn_type"`
	CountryCode    string `protobuf:"bytes,14,opt,name=country_code,json=countryCode" json:"country_code"`
	RegionCode     string `protobuf:"bytes,15,opt,name=region_code,json=regionCode" json:"region_code"`
	Quantity       int32  `protobuf:"varint,16,opt,name=quantity" json:"quantity"`
	RefTransId     uint64 `protobuf:"varint,17,opt,name=ref_trans_id,json=refTransId" json:"ref_trans_id"`
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) Reset() {
	*m = CMsgDPPartnerMicroTxns_PartnerMicroTxn{}
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) String() string { return proto.CompactTextString(m) }
func (*CMsgDPPartnerMicroTxns_PartnerMicroTxn) ProtoMessage()    {}
func (*CMsgDPPartnerMicroTxns_PartnerMicroTxn) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{59, 0}
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerMicroTxn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerMicroTxn.Merge(m, src)
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) XXX_Size() int {
	return m.Size()
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerMicroTxn.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerMicroTxn proto.InternalMessageInfo

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetInitTime() uint32 {
	if m != nil {
		return m.InitTime
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetLastUpdateTime() uint32 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetTxnId() uint64 {
	if m != nil {
		return m.TxnId
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetLineItem() uint32 {
	if m != nil {
		return m.LineItem
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetPrice() uint64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetTax() uint64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetPriceUsd() uint64 {
	if m != nil {
		return m.PriceUsd
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetTaxUsd() uint64 {
	if m != nil {
		return m.TaxUsd
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetPurchaseType() uint32 {
	if m != nil {
		return m.PurchaseType
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetSteamTxnType() uint32 {
	if m != nil {
		return m.SteamTxnType
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetRegionCode() string {
	if m != nil {
		return m.RegionCode
	}
	return ""
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) GetRefTransId() uint64 {
	if m != nil {
		return m.RefTransId
	}
	return 0
}

type CMsgDPPartnerMicroTxns_PartnerInfo struct {
	PartnerId    uint32 `protobuf:"varint,1,opt,name=partner_id,json=partnerId" json:"partner_id"`
	PartnerName  string `protobuf:"bytes,2,opt,name=partner_name,json=partnerName" json:"partner_name"`
	CurrencyCode string `protobuf:"bytes,3,opt,name=currency_code,json=currencyCode" json:"currency_code"`
	CurrencyName string `protobuf:"bytes,4,opt,name=currency_name,json=currencyName" json:"currency_name"`
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) Reset()         { *m = CMsgDPPartnerMicroTxns_PartnerInfo{} }
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) String() string { return proto.CompactTextString(m) }
func (*CMsgDPPartnerMicroTxns_PartnerInfo) ProtoMessage()    {}
func (*CMsgDPPartnerMicroTxns_PartnerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{59, 1}
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerInfo.Merge(m, src)
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) XXX_Size() int {
	return m.Size()
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgDPPartnerMicroTxns_PartnerInfo proto.InternalMessageInfo

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) GetPartnerId() uint32 {
	if m != nil {
		return m.PartnerId
	}
	return 0
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) GetPartnerName() string {
	if m != nil {
		return m.PartnerName
	}
	return ""
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) GetCurrencyName() string {
	if m != nil {
		return m.CurrencyName
	}
	return ""
}

type CMsgDPPartnerMicroTxnsResponse struct {
	Eresult    *uint32                                    `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	Eerrorcode *CMsgDPPartnerMicroTxnsResponse_EErrorCode `protobuf:"varint,2,opt,name=eerrorcode,enum=CMsgDPPartnerMicroTxnsResponse_EErrorCode,def=0" json:"eerrorcode,omitempty"`
}

func (m *CMsgDPPartnerMicroTxnsResponse) Reset()         { *m = CMsgDPPartnerMicroTxnsResponse{} }
func (m *CMsgDPPartnerMicroTxnsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgDPPartnerMicroTxnsResponse) ProtoMessage()    {}
func (*CMsgDPPartnerMicroTxnsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_662a1850681ae3f8, []int{60}
}
func (m *CMsgDPPartnerMicroTxnsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgDPPartnerMicroTxnsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgDPPartnerMicroTxnsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgDPPartnerMicroTxnsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgDPPartnerMicroTxnsResponse.Merge(m, src)
}
func (m *CMsgDPPartnerMicroTxnsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CMsgDPPartnerMicroTxnsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgDPPartnerMicroTxnsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgDPPartnerMicroTxnsResponse proto.InternalMessageInfo

const Default_CMsgDPPartnerMicroTxnsResponse_Eresult uint32 = 2
const Default_CMsgDPPartnerMicroTxnsResponse_Eerrorcode CMsgDPPartnerMicroTxnsResponse_EErrorCode = CMsgDPPartnerMicroTxnsResponse_k_MsgValid

func (m *CMsgDPPartnerMicroTxnsResponse) GetEresult() uint32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgDPPartnerMicroTxnsResponse_Eresult
}

func (m *CMsgDPPartnerMicroTxnsResponse) GetEerrorcode() CMsgDPPartnerMicroTxnsResponse_EErrorCode {
	if m != nil && m.Eerrorcode != nil {
		return *m.Eerrorcode
	}
	return Default_CMsgDPPartnerMicroTxnsResponse_Eerrorcode
}

var E_KeyField = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         60000,
	Name:          "key_field",
	Tag:           "varint,60000,opt,name=key_field,def=0",
	Filename:      "steammessages.proto",
}

var E_MsgpoolSoftLimit = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*int32)(nil),
	Field:         60000,
	Name:          "msgpool_soft_limit",
	Tag:           "varint,60000,opt,name=msgpool_soft_limit,def=32",
	Filename:      "steammessages.proto",
}

var E_MsgpoolHardLimit = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*int32)(nil),
	Field:         60001,
	Name:          "msgpool_hard_limit",
	Tag:           "varint,60001,opt,name=msgpool_hard_limit,def=384",
	Filename:      "steammessages.proto",
}

func init() {
	proto.RegisterEnum("GCProtoBufMsgSrc", GCProtoBufMsgSrc_name, GCProtoBufMsgSrc_value)
	proto.RegisterEnum("CMsgGCRoutingInfo_RoutingMethod", CMsgGCRoutingInfo_RoutingMethod_name, CMsgGCRoutingInfo_RoutingMethod_value)
	proto.RegisterEnum("CMsgGCMsgSetOptions_Option", CMsgGCMsgSetOptions_Option_name, CMsgGCMsgSetOptions_Option_value)
	proto.RegisterEnum("CMsgDPPartnerMicroTxnsResponse_EErrorCode", CMsgDPPartnerMicroTxnsResponse_EErrorCode_name, CMsgDPPartnerMicroTxnsResponse_EErrorCode_value)
	proto.RegisterType((*CMsgProtoBufHeader)(nil), "CMsgProtoBufHeader")
	proto.RegisterType((*CMsgWebAPIKey)(nil), "CMsgWebAPIKey")
	proto.RegisterType((*CMsgHttpRequest)(nil), "CMsgHttpRequest")
	proto.RegisterType((*CMsgHttpRequest_RequestHeader)(nil), "CMsgHttpRequest.RequestHeader")
	proto.RegisterType((*CMsgHttpRequest_QueryParam)(nil), "CMsgHttpRequest.QueryParam")
	proto.RegisterType((*CMsgWebAPIRequest)(nil), "CMsgWebAPIRequest")
	proto.RegisterType((*CMsgHttpResponse)(nil), "CMsgHttpResponse")
	proto.RegisterType((*CMsgHttpResponse_ResponseHeader)(nil), "CMsgHttpResponse.ResponseHeader")
	proto.RegisterType((*CMsgAMFindAccounts)(nil), "CMsgAMFindAccounts")
	proto.RegisterType((*CMsgAMFindAccountsResponse)(nil), "CMsgAMFindAccountsResponse")
	proto.RegisterType((*CMsgNotifyWatchdog)(nil), "CMsgNotifyWatchdog")
	proto.RegisterType((*CMsgAMGetLicenses)(nil), "CMsgAMGetLicenses")
	proto.RegisterType((*CMsgPackageLicense)(nil), "CMsgPackageLicense")
	proto.RegisterType((*CMsgAMGetLicensesResponse)(nil), "CMsgAMGetLicensesResponse")
	proto.RegisterType((*CMsgAMGetUserGameStats)(nil), "CMsgAMGetUserGameStats")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse)(nil), "CMsgAMGetUserGameStatsResponse")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse_Stats)(nil), "CMsgAMGetUserGameStatsResponse.Stats")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse_Achievement_Blocks)(nil), "CMsgAMGetUserGameStatsResponse.Achievement_Blocks")
	proto.RegisterType((*CMsgGCGetCommandList)(nil), "CMsgGCGetCommandList")
	proto.RegisterType((*CMsgGCGetCommandListResponse)(nil), "CMsgGCGetCommandListResponse")
	proto.RegisterType((*CGCMsgMemCachedGet)(nil), "CGCMsgMemCachedGet")
	proto.RegisterType((*CGCMsgMemCachedGetResponse)(nil), "CGCMsgMemCachedGetResponse")
	proto.RegisterType((*CGCMsgMemCachedGetResponse_ValueTag)(nil), "CGCMsgMemCachedGetResponse.ValueTag")
	proto.RegisterType((*CGCMsgMemCachedSet)(nil), "CGCMsgMemCachedSet")
	proto.RegisterType((*CGCMsgMemCachedSet_KeyPair)(nil), "CGCMsgMemCachedSet.KeyPair")
	proto.RegisterType((*CGCMsgMemCachedDelete)(nil), "CGCMsgMemCachedDelete")
	proto.RegisterType((*CGCMsgMemCachedStats)(nil), "CGCMsgMemCachedStats")
	proto.RegisterType((*CGCMsgMemCachedStatsResponse)(nil), "CGCMsgMemCachedStatsResponse")
	proto.RegisterType((*CGCMsgSQLStats)(nil), "CGCMsgSQLStats")
	proto.RegisterType((*CGCMsgSQLStatsResponse)(nil), "CGCMsgSQLStatsResponse")
	proto.RegisterType((*CMsgAMAddFreeLicense)(nil), "CMsgAMAddFreeLicense")
	proto.RegisterType((*CMsgAMAddFreeLicenseResponse)(nil), "CMsgAMAddFreeLicenseResponse")
	proto.RegisterType((*CGCMsgGetIPLocation)(nil), "CGCMsgGetIPLocation")
	proto.RegisterType((*CIPLocationInfo)(nil), "CIPLocationInfo")
	proto.RegisterType((*CGCMsgGetIPLocationResponse)(nil), "CGCMsgGetIPLocationResponse")
	proto.RegisterType((*CGCMsgSystemStatsSchema)(nil), "CGCMsgSystemStatsSchema")
	proto.RegisterType((*CGCMsgGetSystemStats)(nil), "CGCMsgGetSystemStats")
	proto.RegisterType((*CGCMsgGetSystemStatsResponse)(nil), "CGCMsgGetSystemStatsResponse")
	proto.RegisterType((*CMsgAMSendEmail)(nil), "CMsgAMSendEmail")
	proto.RegisterType((*CMsgAMSendEmail_ReplacementToken)(nil), "CMsgAMSendEmail.ReplacementToken")
	proto.RegisterType((*CMsgAMSendEmail_PersonaNameReplacementToken)(nil), "CMsgAMSendEmail.PersonaNameReplacementToken")
	proto.RegisterType((*CMsgAMSendEmailResponse)(nil), "CMsgAMSendEmailResponse")
	proto.RegisterType((*CMsgGCGetEmailTemplate)(nil), "CMsgGCGetEmailTemplate")
	proto.RegisterType((*CMsgGCGetEmailTemplateResponse)(nil), "CMsgGCGetEmailTemplateResponse")
	proto.RegisterType((*CMsgAMGrantGuestPasses2)(nil), "CMsgAMGrantGuestPasses2")
	proto.RegisterType((*CMsgAMGrantGuestPasses2Response)(nil), "CMsgAMGrantGuestPasses2Response")
	proto.RegisterType((*CGCSystemMsg_GetAccountDetails)(nil), "CGCSystemMsg_GetAccountDetails")
	proto.RegisterType((*CGCSystemMsg_GetAccountDetails_Response)(nil), "CGCSystemMsg_GetAccountDetails_Response")
	proto.RegisterType((*CMsgGCGetPersonaNames)(nil), "CMsgGCGetPersonaNames")
	proto.RegisterType((*CMsgGCGetPersonaNames_Response)(nil), "CMsgGCGetPersonaNames_Response")
	proto.RegisterType((*CMsgGCGetPersonaNames_Response_PersonaName)(nil), "CMsgGCGetPersonaNames_Response.PersonaName")
	proto.RegisterType((*CMsgGCCheckFriendship)(nil), "CMsgGCCheckFriendship")
	proto.RegisterType((*CMsgGCCheckFriendship_Response)(nil), "CMsgGCCheckFriendship_Response")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory)(nil), "CMsgGCMsgMasterSetDirectory")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory_SubGC)(nil), "CMsgGCMsgMasterSetDirectory.SubGC")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory_Response)(nil), "CMsgGCMsgMasterSetDirectory_Response")
	proto.RegisterType((*CMsgGCMsgWebAPIJobRequestForwardResponse)(nil), "CMsgGCMsgWebAPIJobRequestForwardResponse")
	proto.RegisterType((*CGCSystemMsg_GetPurchaseTrust_Request)(nil), "CGCSystemMsg_GetPurchaseTrust_Request")
	proto.RegisterType((*CGCSystemMsg_GetPurchaseTrust_Response)(nil), "CGCSystemMsg_GetPurchaseTrust_Response")
	proto.RegisterType((*CMsgGCHAccountVacStatusChange)(nil), "CMsgGCHAccountVacStatusChange")
	proto.RegisterType((*CMsgGCGetPartnerAccountLink)(nil), "CMsgGCGetPartnerAccountLink")
	proto.RegisterType((*CMsgGCGetPartnerAccountLink_Response)(nil), "CMsgGCGetPartnerAccountLink_Response")
	proto.RegisterType((*CMsgGCRoutingInfo)(nil), "CMsgGCRoutingInfo")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting)(nil), "CMsgGCMsgMasterSetWebAPIRouting")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting_Entry)(nil), "CMsgGCMsgMasterSetWebAPIRouting.Entry")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting)(nil), "CMsgGCMsgMasterSetClientMsgRouting")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting_Entry)(nil), "CMsgGCMsgMasterSetClientMsgRouting.Entry")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting_Response)(nil), "CMsgGCMsgMasterSetWebAPIRouting_Response")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting_Response)(nil), "CMsgGCMsgMasterSetClientMsgRouting_Response")
	proto.RegisterType((*CMsgGCMsgSetOptions)(nil), "CMsgGCMsgSetOptions")
	proto.RegisterType((*CMsgGCMsgSetOptions_MessageRange)(nil), "CMsgGCMsgSetOptions.MessageRange")
	proto.RegisterType((*CMsgGCHUpdateSession)(nil), "CMsgGCHUpdateSession")
	proto.RegisterType((*CMsgGCHUpdateSession_ExtraField)(nil), "CMsgGCHUpdateSession.ExtraField")
	proto.RegisterType((*CMsgNotificationOfSuspiciousActivity)(nil), "CMsgNotificationOfSuspiciousActivity")
	proto.RegisterType((*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances)(nil), "CMsgNotificationOfSuspiciousActivity.MultipleGameInstances")
	proto.RegisterType((*CMsgDPPartnerMicroTxns)(nil), "CMsgDPPartnerMicroTxns")
	proto.RegisterType((*CMsgDPPartnerMicroTxns_PartnerMicroTxn)(nil), "CMsgDPPartnerMicroTxns.PartnerMicroTxn")
	proto.RegisterType((*CMsgDPPartnerMicroTxns_PartnerInfo)(nil), "CMsgDPPartnerMicroTxns.PartnerInfo")
	proto.RegisterType((*CMsgDPPartnerMicroTxnsResponse)(nil), "CMsgDPPartnerMicroTxnsResponse")
	proto.RegisterExtension(E_KeyField)
	proto.RegisterExtension(E_MsgpoolSoftLimit)
	proto.RegisterExtension(E_MsgpoolHardLimit)
}

func init() { proto.RegisterFile("steammessages.proto", fileDescriptor_662a1850681ae3f8) }

var fileDescriptor_662a1850681ae3f8 = []byte{
	// 5700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x7b, 0x4d, 0x6c, 0x23, 0xc9,
	0x75, 0xff, 0x90, 0xfa, 0x7e, 0x12, 0x29, 0xaa, 0x35, 0x1f, 0x5c, 0xcd, 0x97, 0xb6, 0xd7, 0xb3,
	0xab, 0xdd, 0x59, 0x73, 0x66, 0x67, 0x67, 0x3f, 0x2c, 0xdb, 0xf8, 0xaf, 0x86, 0xfa, 0x18, 0xee,
	0x4a, 0x1a, 0x2d, 0xc9, 0xd1, 0xfe, 0x13, 0x04, 0x6e, 0x17, 0xbb, 0x8b, 0x64, 0xad, 0xc8, 0xee,
	0xde, 0xae, 0xa2, 0x24, 0xde, 0x36, 0x09, 0x60, 0xd8, 0x97, 0x20, 0x40, 0x0e, 0xb9, 0x04, 0xbe,
	0xc5, 0x08, 0x72, 0x48, 0xe2, 0x8b, 0x0f, 0xb9, 0x25, 0xbe, 0x38, 0x87, 0x00, 0x3e, 0x04, 0x48,
	0x4e, 0x89, 0x63, 0x23, 0xc7, 0x20, 0x40, 0xae, 0x09, 0x90, 0xa0, 0x5e, 0x55, 0x35, 0xab, 0x49,
	0xed, 0x68, 0x62, 0x9f, 0xc4, 0x7e, 0xbf, 0xf7, 0x5e, 0x7d, 0xbd, 0x7a, 0xef, 0xd5, 0xab, 0x12,
	0xac, 0x72, 0x41, 0x49, 0xbf, 0x4f, 0x39, 0x27, 0x1d, 0xca, 0x2b, 0x71, 0x12, 0x89, 0x68, 0x6d,
	0xbd, 0x13, 0x45, 0x9d, 0x1e, 0x7d, 0x80, 0x5f, 0xad, 0x41, 0xfb, 0x41, 0x40, 0xb9, 0x9f, 0xb0,
	0x58, 0x44, 0x89, 0xe2, 0x70, 0xff, 0x6a, 0x1a, 0x9c, 0xea, 0x01, 0xef, 0x1c, 0xc9, 0xaf, 0x27,
	0x83, 0xf6, 0x53, 0x4a, 0x02, 0x9a, 0x38, 0x6f, 0xc3, 0xb2, 0xdf, 0x63, 0x34, 0x14, 0x1e, 0xaa,
	0xf5, 0x58, 0x50, 0xce, 0xad, 0xe7, 0x36, 0x66, 0x9f, 0x4c, 0xff, 0xec, 0x9f, 0xef, 0x5e, 0xa9,
	0x17, 0x14, 0xd8, 0x90, 0x58, 0x2d, 0x70, 0x1e, 0xc2, 0x8a, 0xe1, 0xa6, 0x9c, 0xb3, 0x28, 0x94,
	0xfc, 0xf9, 0xf5, 0xdc, 0xc6, 0x8c, 0xe6, 0xd7, 0xca, 0x1a, 0x0a, 0xad, 0x05, 0xce, 0x06, 0x14,
	0x78, 0x34, 0x48, 0x7c, 0xea, 0x91, 0x38, 0x96, 0xdc, 0x53, 0xeb, 0xb9, 0x8d, 0x82, 0xe6, 0x5e,
	0x54, 0xd0, 0x56, 0x1c, 0xd7, 0x02, 0xe7, 0x43, 0x28, 0x7c, 0x1e, 0xb5, 0x3c, 0x16, 0x78, 0x8a,
	0x5a, 0x06, 0xd9, 0x8f, 0xcd, 0xab, 0xef, 0x7c, 0xf8, 0xf8, 0xf1, 0xfb, 0x1f, 0x3c, 0x7e, 0xfc,
	0xf0, 0x83, 0x77, 0x3f, 0x78, 0xf8, 0x8d, 0xf7, 0xde, 0x7b, 0xe7, 0xfd, 0x77, 0xde, 0xab, 0x2f,
	0x7e, 0x1e, 0xb5, 0x6a, 0x41, 0x03, 0x19, 0x2d, 0x49, 0x41, 0x92, 0x0e, 0x15, 0xe5, 0xc5, 0x4b,
	0x25, 0x9b, 0xc8, 0x28, 0x47, 0xaf, 0x44, 0x3c, 0xa9, 0x20, 0x24, 0x7d, 0x5a, 0x5e, 0x5a, 0xcf,
	0x6d, 0x2c, 0x98, 0xd1, 0x2b, 0xf0, 0xe3, 0xa8, 0x75, 0x48, 0xfa, 0xd4, 0xb9, 0x09, 0x73, 0x34,
	0xa1, 0x7c, 0xd0, 0x13, 0xe5, 0x82, 0x1c, 0xf3, 0x66, 0xee, 0x51, 0xdd, 0x50, 0x9c, 0x37, 0xa1,
	0x40, 0x93, 0x24, 0x4a, 0x3c, 0xbd, 0x32, 0xe5, 0xa2, 0xa5, 0x68, 0x09, 0xa1, 0x03, 0x85, 0x38,
	0x57, 0x21, 0xcf, 0xe2, 0xf2, 0xb2, 0x35, 0x11, 0x79, 0x16, 0x3b, 0x87, 0x00, 0x1d, 0xdf, 0xeb,
	0xf3, 0x8e, 0xc7, 0x13, 0xbf, 0xfc, 0x33, 0xb9, 0x0a, 0xc5, 0x47, 0x2b, 0x95, 0xbd, 0xaa, 0x59,
	0xb1, 0x03, 0xde, 0x69, 0x24, 0xfe, 0xe6, 0xad, 0x71, 0x8a, 0xf7, 0x3c, 0xe4, 0x31, 0xf5, 0x59,
	0x9b, 0xd1, 0xa0, 0x3e, 0xdf, 0xf1, 0x15, 0xd5, 0x79, 0x0c, 0xab, 0x1d, 0xdf, 0x0b, 0x58, 0xe2,
	0xb1, 0x30, 0xa0, 0xe7, 0x66, 0x56, 0xff, 0x2e, 0x67, 0xb5, 0x5b, 0xea, 0xf8, 0xdb, 0x2c, 0xa9,
	0x49, 0x5c, 0xcd, 0xe5, 0x26, 0x7c, 0xf9, 0xa3, 0xdb, 0x5f, 0xe6, 0xbf, 0xff, 0xa3, 0xdb, 0x5f,
	0xce, 0xbb, 0x7f, 0x9d, 0x83, 0x82, 0x34, 0x99, 0xcf, 0x68, 0x6b, 0xeb, 0xa8, 0xf6, 0x09, 0x1d,
	0x3a, 0x37, 0x61, 0x96, 0x0b, 0x22, 0x06, 0x1c, 0x8d, 0xa4, 0xb0, 0x39, 0xf5, 0xe8, 0xbd, 0xf7,
	0xea, 0x9a, 0xe4, 0xac, 0x03, 0x10, 0xdf, 0x8f, 0x06, 0xa1, 0x30, 0x56, 0x51, 0xd8, 0xcc, 0x3d,
	0xac, 0x2f, 0x68, 0x62, 0x2d, 0x70, 0x1e, 0x80, 0x13, 0x0f, 0x5a, 0x3d, 0xc6, 0xbb, 0x34, 0xf1,
	0x3a, 0x49, 0x34, 0x18, 0x59, 0x84, 0xe4, 0x2c, 0xa5, 0xe0, 0x9e, 0xc4, 0x6a, 0x81, 0x6c, 0xef,
	0x84, 0x0e, 0x25, 0xd3, 0xb4, 0xd5, 0xeb, 0x99, 0x13, 0x3a, 0xac, 0x05, 0xce, 0x2d, 0x98, 0x0d,
	0xa2, 0x3e, 0x61, 0x61, 0x79, 0xc6, 0x9a, 0x6a, 0x4d, 0x73, 0x7f, 0x6f, 0x1a, 0x96, 0x65, 0xe7,
	0x9f, 0x0a, 0x11, 0xd7, 0xe9, 0x17, 0x03, 0xca, 0x85, 0x73, 0x1f, 0x8a, 0x89, 0xfa, 0xe9, 0xf5,
	0xa9, 0xe8, 0x46, 0xca, 0xd6, 0x8d, 0xda, 0x82, 0xc6, 0x0e, 0x10, 0x72, 0xd6, 0x61, 0xbe, 0x1b,
	0x71, 0x81, 0x46, 0x91, 0xb7, 0x1a, 0x48, 0xa9, 0xce, 0x75, 0x98, 0x1a, 0x24, 0x3d, 0xec, 0xbf,
	0x01, 0x25, 0xc1, 0xf9, 0x10, 0xe6, 0xba, 0xb8, 0xbb, 0x78, 0x79, 0x7a, 0x7d, 0x6a, 0x63, 0xf1,
	0xd1, 0x9d, 0xca, 0x58, 0x4f, 0x2a, 0xfa, 0xaf, 0xda, 0x84, 0x75, 0xc3, 0xee, 0x6c, 0x02, 0x48,
	0x63, 0x8c, 0x49, 0x42, 0xfa, 0xbc, 0x3c, 0x83, 0xc2, 0x37, 0x27, 0x84, 0x3f, 0x1d, 0xd0, 0x64,
	0x78, 0x24, 0x79, 0xea, 0x0b, 0x1d, 0x2a, 0xf0, 0x17, 0x77, 0xbe, 0x05, 0x8b, 0x71, 0xc4, 0x53,
	0xe1, 0xd9, 0xcb, 0x85, 0x41, 0xf2, 0x6b, 0xe9, 0x32, 0x4c, 0xb7, 0xa2, 0x60, 0x58, 0x9e, 0x5b,
	0xcf, 0x6d, 0x2c, 0xe9, 0xc1, 0x20, 0xc5, 0x79, 0x00, 0x25, 0xd2, 0xe2, 0x51, 0x6f, 0x20, 0xa8,
	0x27, 0x58, 0x9f, 0x46, 0x03, 0x51, 0x9e, 0xb7, 0xa6, 0x6d, 0xd9, 0xa0, 0x4d, 0x05, 0xae, 0xed,
	0x40, 0x21, 0x33, 0x3c, 0xa9, 0x1b, 0x67, 0x31, 0x67, 0x4d, 0x14, 0x52, 0x9c, 0x35, 0x98, 0x39,
	0x25, 0xbd, 0x41, 0x76, 0x82, 0x15, 0x69, 0xed, 0x09, 0xc0, 0xa8, 0xaf, 0x2f, 0xab, 0x63, 0x29,
	0xa3, 0xc3, 0xfd, 0x49, 0x1e, 0x56, 0x46, 0x16, 0x6c, 0xcc, 0xe0, 0x6d, 0x58, 0x7e, 0x7e, 0xf8,
	0xbc, 0xb1, 0xb3, 0x3d, 0xda, 0xf5, 0xb6, 0xda, 0x82, 0x02, 0xcd, 0xae, 0xbf, 0x0f, 0x45, 0x16,
	0x0a, 0x9a, 0xb4, 0x89, 0x4f, 0xbd, 0x09, 0x6b, 0x28, 0xa4, 0x18, 0x32, 0xdf, 0x83, 0x45, 0x65,
	0x59, 0x8a, 0xd3, 0x36, 0x0d, 0x50, 0x00, 0xb2, 0xdd, 0x81, 0xb9, 0x53, 0x9a, 0x48, 0x17, 0x99,
	0x31, 0x6c, 0x43, 0x74, 0xde, 0x80, 0x39, 0x12, 0x33, 0xef, 0x84, 0x0e, 0xd1, 0xb6, 0x17, 0x1f,
	0x15, 0x2b, 0x99, 0x8d, 0x58, 0x9f, 0x25, 0x31, 0x93, 0x1b, 0xf2, 0x2d, 0x98, 0xd3, 0x56, 0x5b,
	0x9e, 0x45, 0xc6, 0xd2, 0xf8, 0x82, 0xd7, 0x0d, 0x83, 0xf3, 0x16, 0x14, 0x93, 0x68, 0x20, 0x58,
	0xd8, 0x31, 0xbe, 0x78, 0xce, 0x6a, 0x7b, 0x49, 0x63, 0xe8, 0x8c, 0xdd, 0x7f, 0xcc, 0x41, 0x69,
	0xa4, 0x88, 0xc7, 0x51, 0xc8, 0x71, 0x70, 0x6a, 0xab, 0x7b, 0x7e, 0x14, 0xd0, 0xcc, 0xde, 0x01,
	0x05, 0x54, 0xa3, 0x80, 0x3a, 0x9b, 0x23, 0xf3, 0xcf, 0xa3, 0x11, 0xae, 0x57, 0xc6, 0x55, 0x55,
	0xcc, 0x8f, 0xf1, 0x0d, 0x60, 0xcc, 0x70, 0x6a, 0xdc, 0x0c, 0xd7, 0x76, 0xa1, 0x98, 0x15, 0xfa,
	0xf5, 0xcc, 0xca, 0x6d, 0xab, 0x30, 0xb8, 0x75, 0xb0, 0xcb, 0xc2, 0x60, 0x4b, 0xb9, 0x26, 0x8e,
	0x43, 0xa3, 0x24, 0xf1, 0xbb, 0x9e, 0x18, 0xc6, 0xe3, 0x43, 0x43, 0xa0, 0x39, 0x8c, 0xa9, 0x74,
	0xf2, 0x9a, 0x8d, 0x8b, 0x84, 0x85, 0x9d, 0x4c, 0x03, 0x4b, 0x0a, 0x6a, 0x20, 0xe2, 0x7e, 0x00,
	0x6b, 0x93, 0xed, 0xa4, 0x53, 0xf9, 0x0a, 0xcc, 0x5b, 0xf1, 0x76, 0x6a, 0x63, 0xb6, 0x3e, 0xc7,
	0x55, 0x8c, 0x75, 0xff, 0x3b, 0xa7, 0x7a, 0x78, 0x18, 0x09, 0xd6, 0x1e, 0x7e, 0x46, 0x84, 0xdf,
	0x0d, 0xa2, 0x8e, 0xf4, 0x76, 0xda, 0x83, 0xdb, 0x9d, 0xd3, 0x34, 0xe7, 0x35, 0x00, 0xd2, 0xa3,
	0x89, 0x50, 0xdd, 0xcf, 0x5b, 0x1c, 0x0b, 0x48, 0xc7, 0xde, 0xbf, 0x03, 0x2b, 0x8a, 0x29, 0xa0,
	0x5c, 0xb0, 0x90, 0x08, 0x69, 0x7f, 0x76, 0x3c, 0x2e, 0x21, 0xbc, 0x3d, 0x42, 0xa5, 0x13, 0xf4,
	0x13, 0x26, 0x98, 0x4f, 0x7a, 0x68, 0xa9, 0xf3, 0xc6, 0x09, 0x1a, 0xaa, 0x5c, 0x05, 0xe9, 0x15,
	0xd0, 0x4e, 0x8d, 0x1e, 0xa4, 0xc8, 0x55, 0x20, 0x71, 0xcc, 0x02, 0xb4, 0xcc, 0xd4, 0x77, 0x23,
	0x09, 0xa5, 0xe8, 0xb9, 0x40, 0x0b, 0x4c, 0xd7, 0x4e, 0x52, 0xdc, 0x77, 0xd5, 0x8e, 0xdd, 0x3a,
	0xd8, 0xa3, 0x62, 0x9f, 0xf9, 0x34, 0xe4, 0x94, 0xcb, 0xfd, 0x82, 0xd3, 0x33, 0x96, 0x9d, 0x18,
	0xa2, 0xfb, 0xfb, 0x7a, 0xce, 0x8e, 0x88, 0x7f, 0x42, 0x3a, 0x54, 0xcb, 0xc9, 0x59, 0x89, 0x15,
	0xc5, 0xe4, 0x35, 0xe9, 0xac, 0x68, 0x7a, 0x2d, 0x70, 0xde, 0x80, 0x25, 0xd9, 0x5d, 0xcf, 0x4f,
	0x28, 0x11, 0x34, 0xc8, 0x4c, 0xde, 0xa2, 0x44, 0xaa, 0x0a, 0x70, 0xee, 0xc2, 0x7c, 0x74, 0x16,
	0xd2, 0x64, 0x3c, 0x8b, 0x99, 0x43, 0x6a, 0x2d, 0x70, 0xbb, 0xf0, 0xca, 0x44, 0xd7, 0xd3, 0x15,
	0xff, 0x3a, 0xcc, 0xf5, 0x14, 0x0d, 0x17, 0x7c, 0xf1, 0xd1, 0x6a, 0x65, 0xb2, 0xc7, 0x75, 0xc3,
	0x23, 0x97, 0x5b, 0xa7, 0x1a, 0x76, 0x7f, 0x34, 0xcd, 0x0d, 0xe1, 0x7a, 0xda, 0xd2, 0x73, 0x4e,
	0x93, 0x3d, 0xd2, 0xa7, 0x0d, 0x41, 0x04, 0x97, 0x9d, 0xbc, 0x30, 0x91, 0x33, 0xe6, 0xe5, 0xdc,
	0x86, 0xb9, 0x0e, 0xe9, 0x53, 0x13, 0xa2, 0x0d, 0x3e, 0x2b, 0x89, 0xb5, 0xc0, 0xb9, 0x0a, 0x33,
	0x72, 0x2b, 0xf3, 0xf2, 0xd4, 0xfa, 0xd4, 0x46, 0xa1, 0xae, 0x3e, 0xdc, 0x1f, 0x4c, 0xc3, 0x9d,
	0x8b, 0x1b, 0x4c, 0xc7, 0xf7, 0x9b, 0x36, 0x6c, 0x25, 0x57, 0x53, 0x13, 0xc9, 0xd5, 0x37, 0x4d,
	0xaf, 0x54, 0x3c, 0xbd, 0x57, 0x79, 0x71, 0x67, 0x2a, 0xea, 0x4b, 0xc9, 0x38, 0x04, 0x1c, 0xe2,
	0x77, 0x19, 0x3d, 0xa5, 0x7d, 0x99, 0xb9, 0xb6, 0x7a, 0x91, 0x7f, 0x62, 0x82, 0xeb, 0xa3, 0xcb,
	0x34, 0x6d, 0x59, 0x92, 0x4f, 0x50, 0xb2, 0xbe, 0x62, 0x69, 0x53, 0xa4, 0xb5, 0x4f, 0x60, 0x46,
	0x4d, 0xff, 0x6d, 0x69, 0xa8, 0x44, 0x8c, 0x9b, 0x1b, 0xa6, 0x48, 0xb5, 0x40, 0x1a, 0x24, 0xc2,
	0x23, 0xef, 0x94, 0x1a, 0xa4, 0xa4, 0x1f, 0x63, 0xe0, 0xfb, 0x93, 0x1c, 0x38, 0x93, 0xcd, 0xca,
	0x38, 0x64, 0x0f, 0x63, 0xac, 0x85, 0x82, 0x85, 0xd5, 0x02, 0xe7, 0xd1, 0xd8, 0x98, 0xd9, 0x28,
	0x27, 0x4b, 0xf7, 0xba, 0x35, 0x0a, 0x26, 0x65, 0xee, 0xc1, 0xe2, 0x20, 0x94, 0x6d, 0x61, 0x98,
	0xc7, 0x55, 0x98, 0x33, 0x3e, 0x50, 0x01, 0x32, 0xc2, 0xbb, 0xdf, 0x85, 0xab, 0x72, 0xce, 0xf6,
	0xaa, 0x7b, 0x54, 0x54, 0xa3, 0x7e, 0x9f, 0x84, 0xc1, 0x3e, 0xe3, 0x42, 0xe6, 0x6a, 0x3a, 0xac,
	0xe4, 0xc6, 0xf6, 0x7b, 0x2d, 0x90, 0x9d, 0xf7, 0x15, 0xaf, 0x17, 0x27, 0xb4, 0xcd, 0xce, 0xb3,
	0x41, 0x54, 0x63, 0x47, 0x08, 0xb9, 0x5b, 0x70, 0xeb, 0xa2, 0x16, 0x52, 0x53, 0x7b, 0x15, 0x96,
	0x8c, 0x32, 0x1d, 0x00, 0xa6, 0x36, 0x16, 0xea, 0x8b, 0x9a, 0x26, 0x03, 0xac, 0xbb, 0x01, 0x4e,
	0x75, 0x4f, 0x2a, 0x39, 0xa0, 0xfd, 0x2a, 0xf1, 0xbb, 0x34, 0xd8, 0xa3, 0xc2, 0x71, 0x60, 0xfa,
	0x84, 0x0e, 0xb9, 0x16, 0xc0, 0xdf, 0xee, 0x0f, 0x73, 0xb0, 0x36, 0xc9, 0x9a, 0xb6, 0xf5, 0x2d,
	0x98, 0xc5, 0xc5, 0xe2, 0x7a, 0xd7, 0x7e, 0xad, 0xf2, 0xd5, 0xcc, 0x15, 0x5c, 0xbf, 0x26, 0xe9,
	0xd4, 0xb5, 0xcc, 0xda, 0x13, 0x98, 0x37, 0x34, 0xe9, 0x0e, 0xdb, 0xd1, 0x20, 0x54, 0xd3, 0x63,
	0xfc, 0xa8, 0x22, 0xbd, 0x30, 0x87, 0xf9, 0x5e, 0x6e, 0x62, 0x2c, 0x0d, 0x2a, 0x9c, 0x07, 0xd6,
	0x58, 0x30, 0xcf, 0x9b, 0x60, 0xa9, 0x7c, 0x42, 0x87, 0x47, 0x84, 0x25, 0x6a, 0xa0, 0x6b, 0xff,
	0x0f, 0xe6, 0x34, 0xe1, 0xd7, 0x4c, 0xa6, 0xee, 0xc3, 0xb5, 0xb1, 0x46, 0xb6, 0x69, 0x8f, 0x0a,
	0x7a, 0xe1, 0xb4, 0x5e, 0x87, 0xab, 0xe3, 0x3d, 0x42, 0x4f, 0xf2, 0xe7, 0xd3, 0x70, 0xeb, 0x22,
	0x20, 0x9d, 0xf0, 0x07, 0x50, 0xf2, 0x07, 0x49, 0xe2, 0xf9, 0x51, 0x18, 0x52, 0x5f, 0x06, 0x21,
	0x75, 0xd8, 0x98, 0x4e, 0x4f, 0x98, 0x83, 0x24, 0xa9, 0x8e, 0x40, 0xb9, 0xe5, 0xfc, 0x7e, 0xe0,
	0xc9, 0x73, 0x5f, 0xde, 0xe2, 0x9b, 0xf5, 0xfb, 0xb8, 0xe6, 0x1a, 0xe6, 0x54, 0xf9, 0x15, 0x1b,
	0x96, 0xd3, 0xf8, 0x2a, 0x2c, 0x48, 0xb8, 0xdd, 0x1b, 0xf0, 0x2e, 0x46, 0xb8, 0xe9, 0x34, 0xc2,
	0xf5, 0x83, 0x5d, 0x49, 0x95, 0x9e, 0x4d, 0x26, 0xe5, 0x5d, 0x26, 0x38, 0x46, 0x39, 0xc3, 0x31,
	0xd7, 0xa1, 0xe2, 0x29, 0x13, 0x5c, 0xee, 0x6a, 0xc9, 0xd0, 0x67, 0x9c, 0x53, 0x8e, 0xd1, 0xce,
	0xb0, 0xc8, 0xf4, 0xfc, 0x00, 0xc9, 0x72, 0x77, 0x05, 0x38, 0x5d, 0x4a, 0xd1, 0x9c, 0xc5, 0x05,
	0x0a, 0x40, 0x5d, 0x6f, 0x42, 0x41, 0xb3, 0x69, 0x75, 0xf3, 0x16, 0xe3, 0x92, 0x82, 0xb4, 0xc6,
	0xd7, 0x00, 0x5a, 0x43, 0x41, 0xb9, 0x97, 0x50, 0x12, 0x94, 0x17, 0xec, 0x66, 0x91, 0x5e, 0xa7,
	0x24, 0x90, 0xfa, 0x14, 0xd3, 0x59, 0xc2, 0x84, 0xa0, 0x21, 0x9e, 0xaa, 0x53, 0x7d, 0x08, 0x7d,
	0xa6, 0x10, 0xb9, 0x47, 0x7b, 0xac, 0xcf, 0x84, 0xd7, 0x27, 0xe7, 0x08, 0xe0, 0x39, 0xda, 0xf0,
	0x16, 0x10, 0x3b, 0xd0, 0x90, 0x6c, 0x1c, 0x97, 0x89, 0x09, 0xda, 0xe7, 0x78, 0x68, 0x4e, 0x1b,
	0x97, 0xf4, 0x9a, 0x24, 0x3b, 0x2e, 0x2c, 0xd0, 0x53, 0xa6, 0x17, 0xb1, 0x60, 0xf3, 0xa4, 0x64,
	0x69, 0x71, 0xaa, 0xb1, 0xa2, 0x85, 0x2b, 0x92, 0xfb, 0x6d, 0x28, 0x2a, 0x5b, 0x69, 0x7c, 0xba,
	0xaf, 0xfc, 0xeb, 0x7d, 0x28, 0x72, 0xbf, 0x4b, 0xfb, 0xc4, 0xf3, 0x89, 0x20, 0xbd, 0xa8, 0x93,
	0x75, 0x82, 0x0a, 0xab, 0x2a, 0xc8, 0xfd, 0x9f, 0x29, 0xb8, 0x9e, 0x95, 0x4f, 0xad, 0xec, 0x0e,
	0xcc, 0x89, 0xae, 0x9c, 0x37, 0x9e, 0x51, 0x60, 0x88, 0x32, 0x55, 0xd2, 0x3f, 0x8d, 0x21, 0x8e,
	0x65, 0x06, 0x25, 0x0d, 0x57, 0x0d, 0x2a, 0xbb, 0x66, 0x44, 0x88, 0x2f, 0xd8, 0x29, 0xcd, 0x24,
	0x09, 0x05, 0x8d, 0x6d, 0x21, 0xe4, 0x7c, 0x00, 0x57, 0xa3, 0x98, 0x26, 0x98, 0x64, 0x71, 0x8f,
	0x0f, 0x5a, 0x7d, 0xb9, 0x06, 0xd9, 0x63, 0xee, 0xea, 0x88, 0xa3, 0x61, 0x18, 0x9c, 0x5d, 0xb8,
	0x15, 0x27, 0x34, 0x26, 0x09, 0x0d, 0x3c, 0x19, 0x32, 0xd0, 0x7f, 0x73, 0x8f, 0x9e, 0x53, 0x7f,
	0x20, 0x15, 0xd8, 0x69, 0xd8, 0x9a, 0xe1, 0x6c, 0xa4, 0x8c, 0x3b, 0x9a, 0xcf, 0x39, 0x80, 0xf5,
	0x30, 0x0a, 0xbd, 0x17, 0xea, 0xb2, 0xf3, 0xb6, 0xdb, 0x61, 0x14, 0x1e, 0x7d, 0xb5, 0xba, 0x07,
	0x50, 0x0a, 0x28, 0x09, 0x30, 0x7a, 0x24, 0x54, 0x24, 0x8c, 0xf2, 0xcc, 0xe9, 0x62, 0xd9, 0xa0,
	0x75, 0x05, 0x3a, 0xbb, 0x70, 0xdb, 0x9a, 0x00, 0x19, 0x70, 0x02, 0x2f, 0x1a, 0x08, 0x8f, 0x85,
	0xde, 0x17, 0x03, 0x3a, 0xa0, 0x99, 0x23, 0xe6, 0x2b, 0x23, 0x56, 0x19, 0x82, 0x82, 0x67, 0x03,
	0x51, 0x0b, 0x3f, 0x95, 0x6c, 0x32, 0x4f, 0xc2, 0xda, 0x0a, 0xc7, 0x0d, 0x90, 0xc6, 0x5b, 0x45,
	0x73, 0x7f, 0x9c, 0x53, 0xc1, 0x6a, 0xeb, 0x60, 0x2b, 0x08, 0x76, 0x13, 0x9a, 0x66, 0x86, 0x97,
	0x24, 0x94, 0xd2, 0x2d, 0xb0, 0xd8, 0xc3, 0x7a, 0x84, 0x9f, 0x59, 0xf7, 0x79, 0x16, 0x1f, 0x21,
	0x55, 0x1a, 0xb7, 0x4e, 0x22, 0xc7, 0xf2, 0xc1, 0x11, 0x59, 0x86, 0x61, 0x2e, 0xa2, 0x84, 0x7a,
	0x98, 0xfe, 0x27, 0x43, 0x75, 0x70, 0x9a, 0xb6, 0xdc, 0x6e, 0x09, 0xf1, 0xaa, 0x82, 0xe5, 0xf1,
	0xc9, 0xfd, 0xe3, 0x9c, 0x0a, 0x7f, 0xe3, 0x7d, 0x4e, 0x6d, 0xd7, 0xca, 0x94, 0x72, 0x13, 0x99,
	0xd2, 0x26, 0x5c, 0x8f, 0x07, 0x89, 0xdf, 0x25, 0x9c, 0x7a, 0x8a, 0xe4, 0x05, 0x54, 0x10, 0xd6,
	0xcb, 0x94, 0xe9, 0xae, 0x1a, 0x9e, 0x3a, 0xb2, 0x6c, 0x23, 0x07, 0x6e, 0x8a, 0x84, 0x84, 0x5c,
	0x8f, 0x27, 0x9d, 0x14, 0x4d, 0x74, 0xdf, 0x80, 0x55, 0xb5, 0x9d, 0xf6, 0xa8, 0xa8, 0x1d, 0xed,
	0x47, 0xbe, 0x3a, 0x23, 0x94, 0x60, 0x8a, 0xc5, 0xca, 0xfb, 0xcf, 0xd5, 0xe5, 0x4f, 0xf7, 0xa7,
	0x39, 0x58, 0xae, 0x8e, 0x38, 0x6a, 0x61, 0x3b, 0xd2, 0x45, 0xaf, 0xdc, 0x58, 0xd1, 0x6b, 0x1d,
	0xe6, 0x7b, 0x44, 0x30, 0x31, 0x08, 0x54, 0xc8, 0xc9, 0x9b, 0x69, 0x36, 0x54, 0x39, 0xcd, 0xbd,
	0x28, 0xec, 0x28, 0x96, 0x29, 0x8b, 0x65, 0x44, 0x96, 0x1d, 0xd7, 0x13, 0x9c, 0x99, 0x5b, 0x43,
	0x94, 0x3e, 0x06, 0xed, 0x3b, 0x53, 0x28, 0x52, 0x24, 0x19, 0x0b, 0x7d, 0x26, 0x86, 0x68, 0xec,
	0x69, 0x2c, 0x94, 0x14, 0x77, 0x07, 0x6e, 0x5e, 0x30, 0xdc, 0x74, 0x19, 0x5e, 0x87, 0x19, 0x16,
	0xb6, 0x23, 0x13, 0x81, 0x4b, 0x95, 0xb1, 0x11, 0xd7, 0x15, 0xec, 0x7e, 0x07, 0x6e, 0x68, 0x27,
	0x34, 0xe4, 0x82, 0xf6, 0xd1, 0x0f, 0x35, 0xd0, 0x4f, 0x39, 0xeb, 0xb0, 0xd0, 0xf1, 0xbd, 0x0b,
	0xb2, 0xa6, 0xb9, 0x8e, 0xaf, 0x8a, 0xa2, 0xaf, 0xc2, 0x82, 0xf6, 0x77, 0x27, 0xa7, 0x99, 0x98,
	0x3c, 0xaf, 0xc8, 0x9f, 0x9c, 0x8e, 0x22, 0xed, 0x1e, 0x15, 0x56, 0x13, 0xee, 0x4f, 0xd3, 0x48,
	0x9b, 0x05, 0xd2, 0x01, 0x5c, 0xde, 0x3a, 0xe6, 0xf4, 0x44, 0xf0, 0xf1, 0xc6, 0x31, 0xc7, 0xe5,
	0x9f, 0x9c, 0xca, 0xa0, 0xa6, 0x7c, 0x9d, 0xf7, 0x79, 0xd4, 0xe2, 0x99, 0x5d, 0x00, 0x0a, 0xf8,
	0x38, 0x6a, 0x61, 0x50, 0x1b, 0x32, 0xda, 0x0b, 0x58, 0xd8, 0x51, 0x8c, 0xb6, 0x9b, 0x5b, 0x32,
	0x90, 0x61, 0x1d, 0x70, 0x9a, 0x98, 0xfa, 0x32, 0xcf, 0x38, 0xb4, 0x25, 0x09, 0xe9, 0xda, 0x32,
	0x77, 0xde, 0x87, 0xab, 0x78, 0xa0, 0xe0, 0x34, 0x39, 0xb5, 0x25, 0x6c, 0xb7, 0xe5, 0x48, 0x8e,
	0x06, 0x32, 0xa4, 0x72, 0xeb, 0x30, 0xcf, 0x23, 0x5f, 0xa6, 0x1e, 0x59, 0x1f, 0x95, 0x52, 0x71,
	0xdb, 0xea, 0xdf, 0x9e, 0x88, 0x3c, 0x99, 0xfc, 0x92, 0x20, 0xe3, 0x91, 0x4a, 0x06, 0x6f, 0x46,
	0xcf, 0x11, 0x95, 0x1e, 0x30, 0x95, 0x91, 0x04, 0x16, 0x76, 0x32, 0x2e, 0x69, 0xd9, 0xa0, 0xfb,
	0x0a, 0x74, 0xbe, 0x0e, 0xcb, 0x32, 0x26, 0xd3, 0x16, 0xf1, 0x4f, 0xb4, 0xcf, 0x03, 0x8b, 0xbf,
	0x98, 0x82, 0xca, 0xd1, 0xbd, 0x09, 0x05, 0xed, 0x9c, 0x3c, 0x75, 0x80, 0x59, 0xb4, 0x27, 0x46,
	0x43, 0xfb, 0x78, 0x52, 0xb8, 0x07, 0x8b, 0xbd, 0xa8, 0x13, 0x19, 0x4f, 0xba, 0x64, 0xaf, 0x0a,
	0x02, 0x4a, 0xe3, 0x6b, 0xa0, 0xbe, 0xd4, 0x92, 0x14, 0x6c, 0x0f, 0x86, 0x74, 0xb9, 0x1e, 0xee,
	0xf7, 0x74, 0x19, 0x75, 0xeb, 0xa0, 0x41, 0xc3, 0x60, 0xa7, 0xaf, 0xfd, 0xc4, 0x0b, 0x9d, 0xe7,
	0x5b, 0x50, 0xa4, 0x92, 0x11, 0x8b, 0xd9, 0x13, 0x05, 0x89, 0x25, 0xc4, 0x0e, 0x78, 0x07, 0x6b,
	0x12, 0x6f, 0x80, 0xfa, 0xf6, 0xda, 0x51, 0xd2, 0x27, 0x22, 0x7b, 0x3d, 0x80, 0xc8, 0x2e, 0x02,
	0xce, 0xef, 0xc0, 0x6a, 0x4c, 0x13, 0x1e, 0x85, 0x04, 0x93, 0x7e, 0x4f, 0x44, 0x27, 0x34, 0x34,
	0xc7, 0xb8, 0xb7, 0x2b, 0x63, 0x7d, 0xac, 0x1c, 0x29, 0x5e, 0x79, 0x18, 0xa8, 0xd3, 0xb8, 0x47,
	0x7c, 0x0c, 0x58, 0x4d, 0x29, 0x54, 0x5f, 0x89, 0x47, 0x20, 0x52, 0x38, 0xee, 0x33, 0x75, 0x4d,
	0xd1, 0xf1, 0x33, 0x06, 0x34, 0xaf, 0xc8, 0x7b, 0xbe, 0xf3, 0x0d, 0x98, 0xd5, 0x6d, 0xce, 0x61,
	0x9b, 0xaf, 0x4e, 0xb4, 0x39, 0xd1, 0x90, 0x16, 0x58, 0xfb, 0x0e, 0x94, 0xc6, 0x31, 0x39, 0xfb,
	0x88, 0x4e, 0xd6, 0x1f, 0x17, 0x90, 0x6e, 0xca, 0x89, 0x8a, 0x69, 0xb2, 0x9c, 0xa5, 0xa4, 0xd5,
	0x89, 0xb1, 0x05, 0x37, 0x5f, 0x30, 0xde, 0x4b, 0xd7, 0x2b, 0xdb, 0x95, 0xfc, 0x85, 0x5d, 0x71,
	0xdf, 0x87, 0x1b, 0x63, 0xe3, 0xfd, 0xaa, 0x80, 0x54, 0xb0, 0x03, 0x92, 0xfb, 0x97, 0x39, 0x55,
	0xab, 0xc0, 0xd3, 0x1c, 0xca, 0x35, 0x69, 0x3f, 0xee, 0x49, 0xd7, 0xfb, 0xc2, 0x13, 0xe3, 0xff,
	0xc5, 0x88, 0x5e, 0x03, 0x50, 0xbc, 0x3d, 0x12, 0x76, 0x54, 0xf9, 0x20, 0x4d, 0x34, 0x25, 0x7d,
	0x9f, 0x84, 0x9d, 0x09, 0x4b, 0x9b, 0xb6, 0xd8, 0x6c, 0x4b, 0x73, 0xff, 0x20, 0xa7, 0x8a, 0x1d,
	0x93, 0x3d, 0x7e, 0xa9, 0x11, 0xcb, 0x8d, 0x2d, 0xb4, 0x80, 0x47, 0xcf, 0x19, 0x17, 0x1c, 0xbb,
	0x6e, 0x8e, 0x7c, 0x45, 0x03, 0xee, 0x20, 0x26, 0xdd, 0x91, 0xa1, 0x64, 0xea, 0xc5, 0x29, 0xd5,
	0xfd, 0x97, 0x9c, 0x99, 0xfb, 0xbd, 0x84, 0x84, 0x62, 0x6f, 0x40, 0xb9, 0x38, 0x22, 0xf2, 0x0c,
	0xf0, 0xe8, 0xf2, 0xb2, 0x4b, 0xb6, 0x06, 0x96, 0xbf, 0xb8, 0x06, 0xf6, 0x36, 0x2c, 0xc7, 0xa8,
	0x50, 0xba, 0xbb, 0x8e, 0x6c, 0x24, 0x33, 0x8b, 0x05, 0x05, 0x36, 0x23, 0x6c, 0x5f, 0xba, 0xc7,
	0x80, 0x0c, 0x91, 0x97, 0x9e, 0xc7, 0x4c, 0x65, 0x66, 0x99, 0xf9, 0x2c, 0x49, 0xbc, 0x19, 0xed,
	0xa4, 0xa8, 0xcc, 0xd3, 0x08, 0x66, 0xfc, 0xe8, 0xd0, 0x0d, 0x9f, 0xa6, 0xb9, 0x5d, 0xb8, 0xfb,
	0x15, 0x03, 0x7c, 0xb9, 0xac, 0x67, 0x03, 0x8a, 0xba, 0xff, 0xd8, 0x79, 0x9d, 0xab, 0xcf, 0x6c,
	0xe6, 0x1e, 0x9a, 0xbe, 0xef, 0x29, 0xba, 0xdb, 0x85, 0x3b, 0xd5, 0xbd, 0xaa, 0x0a, 0x87, 0x07,
	0xbc, 0xe3, 0xed, 0x51, 0xa1, 0x8b, 0xb3, 0x2a, 0x09, 0xba, 0xb4, 0xd6, 0x38, 0x2a, 0x6b, 0xe6,
	0x27, 0xca, 0x9a, 0xea, 0xf6, 0x2c, 0xf7, 0xfd, 0x1f, 0xdd, 0xfe, 0x72, 0xda, 0xfd, 0xd3, 0x02,
	0xbc, 0xf1, 0xe2, 0xa6, 0xbc, 0x74, 0x70, 0x0f, 0xc1, 0xa1, 0x69, 0xb6, 0x16, 0x27, 0xd4, 0xc7,
	0x4a, 0x64, 0x6a, 0x5a, 0x2b, 0x1a, 0xdc, 0x4e, 0x31, 0x69, 0xcd, 0xe6, 0xb2, 0x6d, 0x62, 0xd7,
	0x2e, 0x6a, 0x04, 0x5d, 0xc8, 0x1b, 0xb0, 0x64, 0xfb, 0xcd, 0x8c, 0x89, 0x2d, 0x5a, 0x8e, 0xd0,
	0x79, 0x08, 0x2b, 0x8c, 0x7b, 0x71, 0x12, 0xb5, 0x59, 0x8f, 0x9a, 0xd4, 0xd7, 0xae, 0xf9, 0x2e,
	0x33, 0x7e, 0xa4, 0x50, 0x9d, 0x01, 0x3f, 0x86, 0x55, 0xc6, 0x3d, 0x16, 0x9e, 0xd2, 0x50, 0x44,
	0xc9, 0xd0, 0xc8, 0xcc, 0x58, 0x32, 0x2b, 0x8c, 0xd7, 0x0c, 0xae, 0xa5, 0x36, 0xa0, 0xc0, 0xb8,
	0x77, 0x4a, 0x7c, 0xaf, 0x45, 0xc2, 0x90, 0xaa, 0x5b, 0x08, 0xc3, 0xbf, 0xc8, 0xf8, 0x31, 0xf1,
	0x9f, 0x20, 0xa0, 0x39, 0xfd, 0x61, 0x8b, 0x26, 0x9e, 0x4f, 0xda, 0xea, 0x4c, 0x60, 0x71, 0x56,
	0x25, 0x52, 0x25, 0x6d, 0xd3, 0x77, 0xee, 0x77, 0xa3, 0xa8, 0xe7, 0xe9, 0xd1, 0x63, 0xf4, 0xb5,
	0xfa, 0xde, 0x40, 0x54, 0xaf, 0x80, 0xdc, 0x16, 0x8c, 0x7b, 0x78, 0xa6, 0xa5, 0x01, 0x06, 0x5e,
	0xc3, 0xba, 0xc0, 0xf8, 0xbe, 0x22, 0xcb, 0x98, 0xcb, 0xf0, 0x74, 0xc6, 0xfd, 0x84, 0xb5, 0x68,
	0x80, 0x31, 0xd7, 0xf0, 0x2d, 0x31, 0x79, 0x2c, 0xd3, 0x88, 0xb4, 0x1a, 0xbd, 0x9d, 0x32, 0xf1,
	0xd6, 0x10, 0x9d, 0x0f, 0xe0, 0x1a, 0xe3, 0x5e, 0x3b, 0xa1, 0xd4, 0x13, 0x09, 0x23, 0xa3, 0x5e,
	0x16, 0x2c, 0x95, 0x0e, 0xe3, 0x32, 0xe1, 0x6f, 0x4a, 0x06, 0xd3, 0xd1, 0x0f, 0xe1, 0x9a, 0x25,
	0x65, 0xed, 0xb7, 0xa2, 0x7d, 0x54, 0x6c, 0x1b, 0x31, 0x6b, 0xcb, 0xbd, 0x0d, 0xcb, 0x72, 0x88,
	0xd1, 0x99, 0x77, 0xca, 0xa2, 0x1e, 0x0d, 0x7d, 0x8a, 0x77, 0xce, 0xf3, 0xe9, 0xcd, 0x15, 0xdf,
	0x8f, 0xce, 0x8e, 0x35, 0xe4, 0x7c, 0x03, 0xae, 0x33, 0x6e, 0x7a, 0x85, 0x29, 0x06, 0x0d, 0xbc,
	0x20, 0x3a, 0x0b, 0xcb, 0x25, 0x4b, 0x68, 0x95, 0x71, 0xdd, 0xb1, 0x7d, 0xe4, 0xd8, 0x8e, 0xce,
	0x42, 0x6d, 0x07, 0x7e, 0xd4, 0xef, 0x0f, 0x42, 0x26, 0x86, 0x66, 0x5d, 0x57, 0xb2, 0x76, 0x50,
	0x35, 0xb8, 0x5e, 0x5d, 0xd5, 0x3d, 0x91, 0x90, 0x80, 0x1a, 0x09, 0x27, 0xdb, 0xbd, 0xa6, 0xc4,
	0x34, 0xf7, 0xfb, 0x70, 0x35, 0x65, 0xb5, 0x67, 0x61, 0xd5, 0x4e, 0xf6, 0x84, 0x16, 0xb0, 0x26,
	0xc1, 0x05, 0x73, 0xff, 0xcc, 0x82, 0xf2, 0xd5, 0xcc, 0xbd, 0x88, 0x21, 0xcb, 0xfe, 0xf3, 0x01,
	0x8f, 0x69, 0x88, 0x2f, 0x1a, 0x68, 0x18, 0xa8, 0x02, 0xe8, 0x35, 0x8b, 0x7b, 0x65, 0xc4, 0xb0,
	0x13, 0x06, 0xf2, 0x10, 0x8a, 0x57, 0x23, 0x83, 0x24, 0xa1, 0xa1, 0x3f, 0x2c, 0x5f, 0xb7, 0xfd,
	0xb6, 0xa1, 0xaa, 0xfb, 0x32, 0xe9, 0x9b, 0x7b, 0xf4, 0x94, 0xf6, 0xca, 0x37, 0xb2, 0xf7, 0x65,
	0x94, 0xf4, 0xf7, 0x25, 0x5d, 0xee, 0xd0, 0x76, 0xc2, 0x64, 0xb3, 0xca, 0x22, 0xca, 0x76, 0x0a,
	0xa4, 0x90, 0xaa, 0x31, 0x05, 0xb3, 0x3e, 0x78, 0x59, 0x21, 0x7b, 0x8b, 0x3d, 0x7d, 0xc5, 0x36,
	0x05, 0xcd, 0x52, 0xd5, 0x1c, 0xd8, 0xd7, 0x0f, 0xd1, 0xfa, 0xb0, 0xcd, 0xce, 0x80, 0x24, 0x81,
	0x47, 0x43, 0xd2, 0xea, 0xd1, 0xa0, 0x7c, 0x33, 0xbb, 0xb6, 0x8d, 0x94, 0x63, 0x47, 0x31, 0x18,
	0xaf, 0xd0, 0x8d, 0x42, 0xea, 0x9d, 0xd2, 0x04, 0x1f, 0x19, 0x94, 0x6f, 0x8d, 0x79, 0x05, 0x89,
	0x1e, 0x6b, 0xd0, 0xf9, 0x08, 0xd6, 0xe4, 0xba, 0x9e, 0x45, 0x5e, 0x9b, 0xf8, 0x22, 0x4a, 0x3c,
	0x32, 0x10, 0xdd, 0xb4, 0xc1, 0xdb, 0x96, 0xe8, 0x75, 0xc6, 0x9b, 0x67, 0xd1, 0x2e, 0x72, 0x6d,
	0x0d, 0x44, 0xd7, 0xb4, 0xf9, 0x4d, 0xb8, 0x61, 0x89, 0x6b, 0x49, 0x35, 0xd2, 0x3b, 0xd6, 0x48,
	0xaf, 0x0a, 0x23, 0xac, 0x05, 0x71, 0xa8, 0xdf, 0x82, 0x1b, 0x76, 0x6f, 0x7d, 0x6b, 0x9a, 0xee,
	0x5a, 0xc2, 0xd7, 0xe2, 0x51, 0xa7, 0xfd, 0xd1, 0x44, 0xdd, 0x85, 0x79, 0x25, 0xcd, 0x82, 0xf2,
	0xab, 0x76, 0xad, 0x0f, 0xa9, 0x35, 0xb4, 0xc3, 0x74, 0x3e, 0x58, 0x40, 0x43, 0xc1, 0xda, 0x43,
	0x99, 0xea, 0xbb, 0xd9, 0x6d, 0x7c, 0xa4, 0xd8, 0x53, 0x5c, 0xc6, 0xcc, 0x44, 0x68, 0x09, 0x31,
	0xf4, 0x7a, 0x2c, 0x3c, 0xa1, 0x41, 0xf9, 0x35, 0xfb, 0x48, 0x91, 0x88, 0x9a, 0x86, 0xf7, 0x11,
	0x95, 0xfe, 0x2f, 0x11, 0x5e, 0x8b, 0x25, 0xa2, 0xeb, 0x05, 0x32, 0x3d, 0xf8, 0x9a, 0x6d, 0x19,
	0x89, 0x78, 0x22, 0x91, 0x6d, 0x99, 0x49, 0x55, 0xa0, 0x24, 0xce, 0xc3, 0x6c, 0x95, 0xe1, 0x9e,
	0x65, 0x93, 0x45, 0x71, 0x1e, 0x5a, 0x35, 0x86, 0x4c, 0x9c, 0x7a, 0x17, 0xae, 0xa5, 0xd9, 0x8e,
	0x95, 0x45, 0x72, 0x67, 0x4d, 0xa7, 0x16, 0x2c, 0xe0, 0xfa, 0x8e, 0x32, 0xfd, 0x76, 0xbf, 0x9f,
	0xb7, 0x72, 0x24, 0x5b, 0x6a, 0x14, 0xd3, 0xfe, 0x3f, 0xac, 0xf0, 0x81, 0xef, 0x53, 0x1a, 0x50,
	0x79, 0x64, 0x89, 0x4e, 0x06, 0xb1, 0x39, 0x2b, 0xdf, 0xaf, 0xbc, 0x58, 0x36, 0x93, 0xbd, 0x97,
	0x52, 0x2d, 0xfb, 0x4a, 0x89, 0xf3, 0x18, 0xae, 0xb7, 0x09, 0xeb, 0xa5, 0x6a, 0xbd, 0xb4, 0x9b,
	0x79, 0xec, 0xe6, 0x55, 0x85, 0x2a, 0xf6, 0x86, 0xc6, 0xd6, 0x8e, 0x61, 0xd1, 0x52, 0x7b, 0x69,
	0x98, 0x1f, 0x8f, 0x9b, 0xf9, 0xaf, 0x88, 0x9b, 0xee, 0x89, 0x99, 0xbf, 0x6a, 0x97, 0xfa, 0x27,
	0xbb, 0xb8, 0x5f, 0x79, 0x97, 0xc5, 0x52, 0x43, 0x7a, 0x62, 0xa3, 0x6d, 0x91, 0x69, 0x66, 0xd1,
	0x1c, 0xd8, 0x68, 0x5b, 0xd8, 0x47, 0xbb, 0x84, 0x75, 0xba, 0x22, 0x73, 0x3f, 0x66, 0x74, 0xd4,
	0x25, 0xe2, 0x7e, 0x61, 0xa6, 0x7d, 0xac, 0x31, 0xcf, 0xae, 0x6c, 0xe2, 0x84, 0x71, 0x9e, 0xb9,
	0x68, 0x30, 0x44, 0x79, 0x4e, 0xc5, 0x3b, 0x07, 0xaf, 0x9d, 0x0a, 0x67, 0xd2, 0xd3, 0x65, 0x44,
	0x47, 0x9a, 0xdd, 0xbf, 0xc8, 0xc3, 0x4d, 0xd5, 0xe6, 0x01, 0xef, 0x1c, 0x10, 0x2e, 0xe4, 0x51,
	0x5a, 0x6c, 0xb3, 0x84, 0xca, 0xad, 0x37, 0x94, 0xb6, 0xd7, 0x47, 0xea, 0xe8, 0xad, 0x51, 0x26,
	0x9f, 0x2f, 0x2a, 0xd4, 0xbc, 0x33, 0x72, 0x1e, 0xc3, 0x54, 0xc0, 0x12, 0xfd, 0x34, 0xc0, 0xad,
	0xbc, 0x40, 0x75, 0xa5, 0x31, 0x68, 0xed, 0x55, 0xeb, 0x92, 0x7d, 0xed, 0xcf, 0x72, 0x30, 0x83,
	0x9f, 0xf2, 0xa8, 0x76, 0x71, 0x43, 0xf3, 0x81, 0x69, 0xc2, 0xdc, 0x6f, 0xe4, 0x27, 0xee, 0x37,
	0xae, 0xc3, 0x54, 0x2b, 0x3a, 0xcf, 0x3e, 0xd9, 0x69, 0x45, 0xe7, 0x72, 0xad, 0xcc, 0x95, 0x52,
	0x8f, 0x85, 0xd9, 0x12, 0x9d, 0xb9, 0x58, 0xda, 0x67, 0x21, 0x95, 0xad, 0x77, 0x7c, 0xaf, 0xc5,
	0x42, 0x92, 0x0c, 0x33, 0xe5, 0xa4, 0xf9, 0x8e, 0xff, 0x04, 0xa9, 0x6e, 0x15, 0xbe, 0xf6, 0x82,
	0x41, 0x79, 0x2f, 0x95, 0xd1, 0xba, 0x07, 0xb0, 0x91, 0x2a, 0x51, 0xcf, 0x3e, 0x3e, 0x8e, 0x5a,
	0xfa, 0x49, 0xc7, 0x6e, 0x94, 0x9c, 0x91, 0x24, 0xb0, 0xee, 0xc3, 0x2e, 0x9b, 0x11, 0x77, 0x0f,
	0xee, 0x8d, 0xe7, 0xa2, 0x47, 0xba, 0x04, 0xd8, 0x4c, 0x06, 0x5c, 0x78, 0xe6, 0x6d, 0xcc, 0x65,
	0x37, 0xed, 0x3f, 0xcc, 0xc3, 0xeb, 0x97, 0x69, 0xd2, 0xdd, 0xda, 0x82, 0xb5, 0x2e, 0x91, 0x19,
	0x25, 0x8b, 0x12, 0x2f, 0x2d, 0x4a, 0x76, 0x19, 0x97, 0xd3, 0x90, 0x31, 0xce, 0x1b, 0x5d, 0xc2,
	0x8f, 0x24, 0x9b, 0xd1, 0xf4, 0x54, 0x31, 0x39, 0xbb, 0x70, 0x5b, 0xaa, 0x08, 0x23, 0x2f, 0xa1,
	0x3e, 0x0d, 0x85, 0x27, 0x93, 0xf9, 0xb3, 0x28, 0x09, 0xbc, 0x84, 0x72, 0x3a, 0x76, 0xb0, 0x7a,
	0xa5, 0x4b, 0xf8, 0x61, 0x54, 0x47, 0xc6, 0x23, 0xcd, 0x57, 0x47, 0x36, 0x9d, 0xdc, 0x9c, 0x91,
	0x5e, 0x8f, 0x0a, 0xcf, 0x27, 0xbc, 0xeb, 0x09, 0xd9, 0x57, 0xaa, 0x0a, 0x9d, 0x56, 0x00, 0xfc,
	0x0c, 0x59, 0xaa, 0x84, 0x77, 0x9b, 0x8a, 0x01, 0x5d, 0x2b, 0xeb, 0x53, 0x8f, 0xf4, 0x7a, 0xa9,
	0x90, 0x5d, 0xbe, 0x2a, 0x4a, 0x74, 0xab, 0xd7, 0xd3, 0xfc, 0xee, 0xbf, 0xe7, 0xe0, 0xb6, 0x5a,
	0xb9, 0xa7, 0x3a, 0x53, 0x3a, 0x26, 0x7e, 0x43, 0xbd, 0x8e, 0xe9, 0x92, 0xb0, 0xf3, 0x12, 0x37,
	0xe5, 0xa3, 0x73, 0x71, 0x7e, 0xf2, 0x5c, 0xfc, 0x18, 0x56, 0x13, 0xec, 0xd0, 0x29, 0xf1, 0x65,
	0x2e, 0xc4, 0x05, 0x49, 0x44, 0xb6, 0xf4, 0xb6, 0x82, 0x0c, 0xc7, 0x88, 0x37, 0x10, 0xd6, 0xa9,
	0xb4, 0x4a, 0xb3, 0xbc, 0x30, 0x3a, 0xcb, 0x24, 0xf6, 0x8b, 0x8c, 0xab, 0x2c, 0xeb, 0x30, 0x3a,
	0x93, 0xe3, 0x1d, 0x71, 0xb6, 0x07, 0x62, 0x90, 0xd0, 0x4c, 0x46, 0x5f, 0x34, 0xcc, 0xbb, 0x88,
	0xb9, 0xdf, 0x36, 0xde, 0x61, 0x0f, 0x5f, 0xa2, 0x89, 0x90, 0x26, 0x26, 0x43, 0x64, 0xe1, 0xc9,
	0xa5, 0xf6, 0xf4, 0x5d, 0xb3, 0x59, 0x2e, 0x14, 0x1f, 0x19, 0x53, 0x19, 0xa6, 0xe3, 0xb3, 0xb1,
	0x4a, 0x01, 0x52, 0x64, 0x0b, 0x21, 0x3d, 0x8f, 0xc2, 0xb1, 0xe9, 0x32, 0x44, 0xf7, 0x77, 0xa7,
	0xd4, 0x8b, 0x92, 0xbd, 0x6a, 0x5d, 0xbd, 0x70, 0xc2, 0x72, 0xf4, 0xcd, 0xec, 0x9e, 0x99, 0xda,
	0x28, 0x58, 0xfe, 0xe3, 0x23, 0x98, 0xd5, 0xef, 0x03, 0xf3, 0xf8, 0x0a, 0x73, 0xbd, 0x32, 0xa1,
	0xa0, 0xa2, 0x7f, 0xab, 0xc7, 0x82, 0x9b, 0xb3, 0xf5, 0xad, 0xc3, 0xed, 0x67, 0x07, 0x75, 0x2d,
	0xe7, 0xec, 0xc0, 0x7c, 0x9b, 0xf4, 0x7a, 0x2d, 0xe2, 0x9f, 0xe0, 0xd2, 0xbc, 0x8c, 0x8e, 0xb9,
	0xed, 0x5a, 0xa3, 0xba, 0x55, 0xdf, 0xae, 0xa7, 0xa2, 0xce, 0x7d, 0x28, 0x9a, 0x17, 0xbd, 0x5e,
	0x9b, 0xd1, 0x5e, 0xd6, 0xf4, 0x0a, 0x06, 0xdb, 0x95, 0x90, 0xf4, 0x61, 0x67, 0xb4, 0x45, 0x62,
	0xa6, 0x9e, 0x00, 0x66, 0xbc, 0xd3, 0xa2, 0x42, 0xf0, 0x2d, 0x9d, 0x1b, 0x43, 0x21, 0xd3, 0xb2,
	0x03, 0xa0, 0xfb, 0x5f, 0xba, 0xe2, 0x2c, 0x82, 0xe9, 0x47, 0x29, 0xe7, 0x38, 0x50, 0xac, 0xee,
	0xd7, 0x76, 0x0e, 0x9b, 0x5e, 0xa3, 0xb9, 0xb3, 0x75, 0x50, 0xdb, 0x2e, 0xe5, 0x9d, 0x57, 0xe0,
	0xda, 0x51, 0xfd, 0x59, 0xf3, 0xd9, 0x93, 0xe7, 0xbb, 0xde, 0x6e, 0x6d, 0x67, 0x7f, 0xdb, 0x7b,
	0x5e, 0x3b, 0x6c, 0xbe, 0xff, 0xb8, 0x34, 0xe5, 0xdc, 0x80, 0xd5, 0xcf, 0x76, 0x9e, 0x6c, 0x1d,
	0xd5, 0xbc, 0xa3, 0xad, 0xfa, 0xd6, 0x81, 0x01, 0xa6, 0xdd, 0xff, 0xc8, 0xa9, 0x03, 0x7e, 0xd6,
	0x27, 0xea, 0x57, 0x79, 0xaa, 0x2b, 0xce, 0x47, 0x30, 0x47, 0x43, 0x75, 0x73, 0xa4, 0xb2, 0x84,
	0xd7, 0x2b, 0x97, 0x88, 0x54, 0x76, 0x64, 0x42, 0x53, 0x37, 0x62, 0x6b, 0x3f, 0xc8, 0xc1, 0x0c,
	0x92, 0x2e, 0x78, 0xb3, 0x97, 0x7b, 0xe9, 0x37, 0x7b, 0xf9, 0xaf, 0x78, 0xb3, 0xf7, 0x36, 0xcc,
	0xe9, 0x27, 0x72, 0xb8, 0xa2, 0x8b, 0x8f, 0x9c, 0xc9, 0x15, 0xad, 0x1b, 0x16, 0xf7, 0x6f, 0x72,
	0xe0, 0x4e, 0x76, 0xbf, 0x8a, 0xaf, 0xa3, 0x0f, 0x78, 0xc7, 0x0c, 0xba, 0x3a, 0x3e, 0xe8, 0x37,
	0x2b, 0x97, 0x4b, 0x8d, 0x8f, 0xfb, 0xd8, 0x0c, 0xfb, 0x2e, 0xcc, 0xa7, 0xd5, 0xb2, 0x4c, 0x41,
	0xbf, 0xaf, 0x0b, 0x65, 0xd6, 0x18, 0xf2, 0x97, 0x8f, 0x61, 0xcf, 0x8a, 0x41, 0x17, 0xaf, 0xc0,
	0x4b, 0x06, 0xb3, 0x8f, 0xe1, 0xfe, 0xe5, 0xa3, 0x7a, 0x49, 0x5d, 0x7f, 0x9f, 0x87, 0xd5, 0x54,
	0x59, 0x83, 0x8a, 0x67, 0xb1, 0xba, 0x47, 0x7e, 0x0f, 0xe6, 0xa2, 0xd8, 0x3c, 0x17, 0x98, 0xda,
	0x28, 0xea, 0xa7, 0xaf, 0x63, 0x6c, 0x15, 0xf5, 0xb7, 0x6e, 0x78, 0x9d, 0x83, 0xf4, 0x45, 0xbb,
	0x9c, 0xb9, 0x44, 0x3a, 0x68, 0xf3, 0x6c, 0xf1, 0xd5, 0x0b, 0x15, 0xe8, 0x47, 0xdc, 0x75, 0xc9,
	0x69, 0x9e, 0xbb, 0xcb, 0x41, 0xa0, 0xe4, 0xda, 0x47, 0xb0, 0x64, 0x33, 0xc8, 0x7c, 0xa3, 0x17,
	0x9d, 0x95, 0x73, 0xeb, 0xf9, 0x74, 0x31, 0x24, 0x41, 0xba, 0xb3, 0x2e, 0xeb, 0x74, 0xcb, 0x79,
	0x0b, 0x40, 0x8a, 0x1b, 0xc2, 0xac, 0x6a, 0xca, 0x29, 0xc3, 0xd5, 0xc3, 0x67, 0xcd, 0xda, 0xee,
	0x6f, 0x79, 0xcf, 0x1b, 0x3b, 0x75, 0xaf, 0xb1, 0xd3, 0x68, 0xd4, 0x9e, 0x1d, 0x36, 0x4a, 0x57,
	0x9c, 0x35, 0xb8, 0xae, 0x91, 0xc6, 0x4e, 0xfd, 0xd8, 0xc6, 0x72, 0x72, 0x0f, 0x6a, 0x6c, 0xab,
	0xfa, 0xb4, 0xb6, 0x73, 0xbc, 0x73, 0xb0, 0x73, 0xd8, 0x6c, 0x94, 0xf2, 0xce, 0x35, 0x58, 0xd1,
	0xc0, 0xf1, 0x56, 0xd5, 0xdb, 0xaa, 0x36, 0x6b, 0xcf, 0x0e, 0x4b, 0x53, 0xee, 0xbf, 0x4d, 0x9b,
	0xf7, 0x3c, 0x4f, 0x9f, 0xc7, 0xf2, 0x94, 0xa1, 0xef, 0x49, 0x7e, 0xc3, 0x30, 0x75, 0x0b, 0x66,
	0xa3, 0x10, 0x53, 0x29, 0x3b, 0xc2, 0x6a, 0x9a, 0x3c, 0xfb, 0x9b, 0x5b, 0x1b, 0xd3, 0xc4, 0xb4,
	0xfd, 0x5f, 0x07, 0x0a, 0x34, 0xff, 0x75, 0x80, 0x8f, 0x33, 0x91, 0x9b, 0x04, 0x41, 0x92, 0xb9,
	0x11, 0x02, 0x05, 0x6c, 0x05, 0x41, 0x62, 0xb1, 0xc5, 0x51, 0x22, 0x32, 0x55, 0x7c, 0xcd, 0x76,
	0x14, 0x25, 0xf8, 0x20, 0x24, 0xe2, 0x6a, 0x8f, 0xd8, 0xb7, 0x3f, 0xb3, 0x11, 0xc7, 0x2d, 0x72,
	0x0f, 0x16, 0xb5, 0x41, 0x60, 0x63, 0xf6, 0xa5, 0x0f, 0x28, 0x00, 0x1b, 0xab, 0xc2, 0x12, 0x3d,
	0x17, 0x09, 0x51, 0x6e, 0x99, 0x97, 0x17, 0xac, 0x97, 0xae, 0xe3, 0x53, 0x59, 0xd9, 0x91, 0x9c,
	0xe8, 0xa4, 0xeb, 0x8b, 0x34, 0xfd, 0xcd, 0x33, 0x2f, 0x0a, 0xc1, 0x9e, 0x62, 0xfd, 0xa2, 0x50,
	0x06, 0x63, 0xbf, 0x9f, 0xfe, 0xaf, 0x05, 0x1f, 0x72, 0x16, 0x64, 0xee, 0x7d, 0x8a, 0x7e, 0x5f,
	0xb7, 0xd1, 0x90, 0x98, 0x3c, 0xe7, 0x5b, 0xfc, 0xfa, 0x7c, 0xca, 0x68, 0x92, 0xa9, 0x49, 0xad,
	0xa6, 0x42, 0xb5, 0x94, 0x01, 0xe3, 0x21, 0x8d, 0x23, 0x79, 0x44, 0xe5, 0xe5, 0x82, 0x8e, 0x87,
	0x92, 0x50, 0x0b, 0xf8, 0xda, 0x13, 0x80, 0xd1, 0x10, 0x7e, 0xcd, 0x77, 0xb7, 0x7f, 0x9b, 0x57,
	0x91, 0x1e, 0x9f, 0xb5, 0xea, 0x23, 0xf7, 0xb3, 0x76, 0x63, 0xc0, 0x63, 0xe6, 0xb3, 0x68, 0xa0,
	0x1e, 0x46, 0x30, 0x31, 0xfc, 0x4d, 0xea, 0xaf, 0xce, 0xe7, 0xe0, 0xf4, 0x07, 0x3d, 0xc1, 0xe2,
	0x1e, 0xf5, 0x58, 0xc8, 0x05, 0x09, 0x7d, 0xca, 0xb5, 0xbb, 0xfe, 0x66, 0xe5, 0x65, 0x9a, 0xaf,
	0x1c, 0x68, 0xf9, 0x3d, 0xd2, 0xa7, 0x35, 0xa3, 0xa2, 0xbe, 0x62, 0xd4, 0xa6, 0xa4, 0xb5, 0x04,
	0xae, 0x5d, 0xc8, 0x8b, 0x6f, 0xef, 0xe4, 0xbe, 0xd0, 0x04, 0x5d, 0xd5, 0xc9, 0xfc, 0xdb, 0x85,
	0xdc, 0x23, 0x1a, 0x56, 0xa5, 0x9d, 0x7b, 0x50, 0x8c, 0x44, 0xd7, 0xec, 0x87, 0xd1, 0x51, 0xb6,
	0x80, 0xd4, 0x46, 0x7a, 0xec, 0x9e, 0x57, 0x97, 0x29, 0xdb, 0x47, 0x3a, 0x57, 0x3a, 0x60, 0x7e,
	0x12, 0x35, 0xcf, 0xd5, 0x3b, 0x1a, 0x35, 0x2d, 0xb9, 0xc9, 0x69, 0xb9, 0x0d, 0x73, 0x1d, 0x7f,
	0x32, 0xba, 0xcd, 0x76, 0x7c, 0x8c, 0x6c, 0xdf, 0x86, 0xb9, 0x58, 0xa9, 0xd3, 0x53, 0xf5, 0x5a,
	0xe5, 0xe2, 0x46, 0x2a, 0x9a, 0xa0, 0xc2, 0x84, 0x96, 0x71, 0x3e, 0x81, 0x25, 0x7c, 0x21, 0x40,
	0xf4, 0x43, 0x1f, 0xf5, 0x46, 0xf3, 0x8d, 0x4b, 0x74, 0x18, 0x42, 0x3d, 0x23, 0xbc, 0xf6, 0x9f,
	0xd3, 0xb0, 0x3c, 0xc6, 0x81, 0x8f, 0x31, 0x42, 0x26, 0x54, 0x11, 0x27, 0x73, 0xbe, 0x91, 0x64,
	0xac, 0xdb, 0x54, 0xa0, 0xd4, 0x23, 0x5c, 0x78, 0x03, 0xdc, 0x77, 0x8a, 0xd3, 0xb6, 0x8f, 0xa2,
	0x44, 0xd5, 0xa6, 0x44, 0xfe, 0x9b, 0x30, 0x2b, 0xce, 0x43, 0xf3, 0x92, 0x37, 0x7d, 0x76, 0x24,
	0xce, 0x43, 0x75, 0x65, 0x62, 0xfd, 0x23, 0xcb, 0xf4, 0x05, 0x45, 0x43, 0x75, 0x33, 0x2f, 0x5d,
	0x19, 0x3e, 0x80, 0xca, 0xb8, 0xa4, 0x79, 0x49, 0xae, 0x09, 0xda, 0x97, 0xd3, 0x2e, 0x51, 0x4f,
	0x3f, 0x81, 0x4e, 0x9f, 0x9e, 0x49, 0xa2, 0xd2, 0x10, 0xd0, 0xb6, 0x4e, 0x41, 0x33, 0x17, 0xd1,
	0x01, 0x6d, 0xab, 0x44, 0x74, 0x0d, 0x66, 0xe2, 0x84, 0xf9, 0x34, 0xf3, 0x0a, 0x4c, 0x91, 0x64,
	0x68, 0x11, 0xe4, 0x3c, 0xf3, 0xee, 0x4b, 0x12, 0xa4, 0x5a, 0x64, 0xf0, 0x06, 0x3c, 0xc8, 0xbc,
	0xf6, 0x9a, 0x47, 0xf2, 0x73, 0x8e, 0xf6, 0x20, 0xc8, 0x39, 0x32, 0xd8, 0x4f, 0xbc, 0x66, 0x05,
	0x39, 0x97, 0xf0, 0x9b, 0x50, 0x48, 0x8f, 0x6b, 0xe8, 0x27, 0x6d, 0xef, 0xb1, 0x64, 0x20, 0xf4,
	0x96, 0x6f, 0x41, 0x51, 0x79, 0x70, 0x39, 0x9b, 0xc8, 0x5b, 0x98, 0xb8, 0x96, 0x6e, 0x9e, 0x87,
	0xe6, 0xaa, 0x37, 0x53, 0xa0, 0x2a, 0x66, 0xcf, 0xd8, 0x69, 0x75, 0x4a, 0xba, 0xe0, 0x84, 0x76,
	0xa4, 0x07, 0x43, 0xbe, 0x65, 0x3b, 0x21, 0x53, 0x00, 0xb2, 0xad, 0xc3, 0xfc, 0x17, 0x03, 0x82,
	0x05, 0x33, 0xac, 0x51, 0x9b, 0x4b, 0xa5, 0x94, 0xea, 0xbc, 0x0e, 0x4b, 0x09, 0x6d, 0x7b, 0x68,
	0x60, 0x72, 0x15, 0x56, 0xec, 0x47, 0x77, 0x09, 0x6d, 0x37, 0x25, 0x50, 0x0b, 0xd6, 0x7e, 0x9c,
	0x83, 0x45, 0xcb, 0xb4, 0xd5, 0x9d, 0x19, 0x7e, 0x5e, 0xf0, 0x6e, 0x5c, 0xb1, 0xa9, 0x02, 0x91,
	0x66, 0xba, 0xa0, 0x40, 0xa4, 0x10, 0xdc, 0x5e, 0x6f, 0x42, 0xc1, 0x94, 0x84, 0xd5, 0x80, 0xec,
	0xea, 0xc3, 0x92, 0x81, 0x70, 0x48, 0x36, 0x2b, 0x2a, 0x9d, 0xbe, 0x88, 0x15, 0xcb, 0x4e, 0x7f,
	0x34, 0xa5, 0x4a, 0x41, 0x93, 0x3b, 0xec, 0xe5, 0x6e, 0x29, 0x8f, 0x01, 0x28, 0xbe, 0x92, 0xc2,
	0x2e, 0xa9, 0x73, 0xce, 0x5b, 0x95, 0x17, 0x6b, 0xac, 0xec, 0xec, 0x48, 0x09, 0x55, 0x42, 0x3c,
	0xf1, 0x0e, 0x78, 0xe7, 0x98, 0xf4, 0x58, 0x50, 0xb7, 0x34, 0xb9, 0xff, 0x95, 0x03, 0x18, 0xb1,
	0x39, 0x45, 0xb0, 0x18, 0x4b, 0x57, 0x64, 0x16, 0x82, 0xdf, 0xb5, 0xf0, 0x54, 0x52, 0xb6, 0xe2,
	0xb8, 0x26, 0x0f, 0x1a, 0x37, 0xe1, 0x86, 0x4d, 0xb6, 0x16, 0xa3, 0x94, 0x97, 0x29, 0x0d, 0x82,
	0x87, 0x51, 0xd3, 0x72, 0x15, 0xa5, 0x29, 0x67, 0x15, 0x96, 0x11, 0x68, 0x7c, 0xba, 0xbf, 0x4b,
	0x58, 0x6f, 0x90, 0xd0, 0xd2, 0xb4, 0x73, 0x17, 0x6e, 0x22, 0xd1, 0xd2, 0xb1, 0xcd, 0xb8, 0x9f,
	0xd0, 0x98, 0x84, 0xfe, 0xb0, 0x34, 0xe3, 0xac, 0xc3, 0x2d, 0x64, 0xb0, 0x94, 0xd5, 0x42, 0x4e,
	0x13, 0xb1, 0x8b, 0x65, 0xc3, 0xd2, 0x5c, 0xda, 0xe0, 0x56, 0x2f, 0xa1, 0x24, 0x18, 0xd6, 0x07,
	0x61, 0xc8, 0xc2, 0x4e, 0x69, 0x3e, 0xd5, 0xad, 0xbb, 0x69, 0x69, 0xd8, 0x26, 0x82, 0x94, 0x16,
	0xde, 0xfa, 0x49, 0x0e, 0x4a, 0xe3, 0xff, 0x9f, 0x27, 0x1b, 0x7c, 0xd1, 0xff, 0xec, 0x95, 0xae,
	0x48, 0xbd, 0x13, 0x1c, 0xbb, 0x49, 0xd4, 0x57, 0x65, 0x96, 0x52, 0xee, 0x42, 0x15, 0xc8, 0x80,
	0x29, 0x92, 0x3c, 0x96, 0xdd, 0x84, 0x1b, 0x17, 0x72, 0xec, 0x55, 0x4b, 0x53, 0x17, 0x8a, 0xd7,
	0x69, 0xdc, 0x1b, 0xea, 0x06, 0xa6, 0x37, 0xab, 0xb0, 0x70, 0x42, 0x87, 0x2a, 0x9b, 0x71, 0x6e,
	0x57, 0xd4, 0xbf, 0x93, 0x56, 0xcc, 0x01, 0xb3, 0x82, 0x91, 0x5f, 0xa7, 0xc0, 0xe5, 0x5f, 0xfc,
	0x03, 0xe6, 0x74, 0x9b, 0x33, 0x6d, 0xd2, 0xe3, 0xb4, 0x3e, 0x7f, 0x42, 0x87, 0x88, 0x6f, 0x36,
	0xc0, 0xe9, 0xf3, 0x4e, 0x1c, 0x45, 0x3d, 0x8f, 0x47, 0x6d, 0xa1, 0xae, 0xd7, 0x9c, 0xbb, 0x13,
	0xda, 0x74, 0x8a, 0x9c, 0xd5, 0x37, 0xb3, 0x99, 0x7f, 0xf7, 0x51, 0xbd, 0xa4, 0x15, 0x34, 0xa2,
	0xb6, 0xc0, 0x6b, 0xb8, 0xcd, 0xe6, 0x48, 0x69, 0x97, 0x24, 0xc1, 0xcb, 0x2a, 0xfd, 0x57, 0xad,
	0x74, 0xea, 0xdd, 0x0f, 0x1f, 0xa7, 0x5a, 0x9f, 0x92, 0x24, 0x40, 0xad, 0x4f, 0xdc, 0x9f, 0xfd,
	0xf2, 0x4e, 0xee, 0xe7, 0xbf, 0xbc, 0x93, 0xfb, 0xc5, 0x2f, 0xef, 0xe4, 0xfe, 0xf0, 0x57, 0x77,
	0xae, 0xfc, 0xfc, 0x57, 0x77, 0xae, 0xfc, 0xd3, 0xaf, 0xee, 0x5c, 0x79, 0x9a, 0xfb, 0xed, 0xa9,
	0x3e, 0xef, 0x7c, 0x99, 0xbb, 0xf2, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xec, 0x98, 0x52, 0x62,
	0x6a, 0x3b, 0x00, 0x00,
}

func (m *CMsgProtoBufHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgProtoBufHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ClientSteamId))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ClientSessionId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SourceAppId))
	if m.JobIdSource != nil {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.JobIdSource))
		i += 8
	}
	if m.JobIdTarget != nil {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.JobIdTarget))
		i += 8
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TargetJobName)))
	i += copy(dAtA[i:], m.TargetJobName)
	if m.Eresult != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.ErrorMessage)))
	i += copy(dAtA[i:], m.ErrorMessage)
	dAtA[i] = 0x78
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Ip))
	if m.GcMsgSrc != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.GcMsgSrc))
	}
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0xc
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcDirIndexSource))
	return i, nil
}

func (m *CMsgWebAPIKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgWebAPIKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Status))
	}
	if m.AccountId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.AccountId))
	}
	if m.PublisherGroupId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.PublisherGroupId))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.KeyId))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	return i, nil
}

func (m *CMsgHttpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RequestMethod))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Url)))
	i += copy(dAtA[i:], m.Url)
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GetParams) > 0 {
		for _, msg := range m.GetParams {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PostParams) > 0 {
		for _, msg := range m.PostParams {
			dAtA[i] = 0x32
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AbsoluteTimeout))
	return i, nil
}

func (m *CMsgHttpRequest_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgHttpRequest_QueryParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest_QueryParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CMsgWebAPIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgWebAPIRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.UNUSEDJobName)))
	i += copy(dAtA[i:], m.UNUSEDJobName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.InterfaceName)))
	i += copy(dAtA[i:], m.InterfaceName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.MethodName)))
	i += copy(dAtA[i:], m.MethodName)
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Version))
	if m.ApiKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.ApiKey.Size()))
		n1, err1 := m.ApiKey.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.Request != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Request.Size()))
		n2, err2 := m.Request.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RoutingAppId))
	return i, nil
}

func (m *CMsgHttpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatusCode))
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *CMsgHttpResponse_ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpResponse_ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgAMFindAccounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMFindAccounts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SearchType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.SearchString)))
	i += copy(dAtA[i:], m.SearchString)
	return i, nil
}

func (m *CMsgAMFindAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMFindAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SteamId) > 0 {
		for _, num := range m.SteamId {
			dAtA[i] = 0x9
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	return i, nil
}

func (m *CMsgNotifyWatchdog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotifyWatchdog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AlertType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AlertDestination))
	dAtA[i] = 0x20
	i++
	if m.Critical {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Time))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	dAtA[i] = 0x3a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CMsgAMGetLicenses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetLicenses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	return i, nil
}

func (m *CMsgPackageLicense) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgPackageLicense) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PackageId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TimeCreated))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OwnerId))
	return i, nil
}

func (m *CMsgAMGetLicensesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetLicensesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.License) > 0 {
		for _, msg := range m.License {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Result))
	return i, nil
}

func (m *CMsgAMGetUserGameStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamId))
	i += 8
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GameId))
	i += 8
	if len(m.Stats) > 0 {
		for _, num := range m.Stats {
			dAtA[i] = 0x18
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamId))
	i += 8
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GameId))
	i += 8
	if m.Eresult != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AchievementBlocks) > 0 {
		for _, msg := range m.AchievementBlocks {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatValue))
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AchievementId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AchievementBitId))
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnlockTime))
	i += 4
	return i, nil
}

func (m *CMsgGCGetCommandList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetCommandList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CommandPrefix)))
	i += copy(dAtA[i:], m.CommandPrefix)
	return i, nil
}

func (m *CMsgGCGetCommandListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetCommandListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommandName) > 0 {
		for _, s := range m.CommandName {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Found {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CGCMsgMemCachedSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedSet_KeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedSet_KeyPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CGCMsgMemCachedDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CGCMsgMemCachedStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CurrConnections))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdGet))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdSet))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdFlush))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GetHits))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GetMisses))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeleteHits))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeleteMisses))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.BytesRead))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.BytesWritten))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LimitMaxbytes))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CurrItems))
	dAtA[i] = 0x68
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Evictions))
	dAtA[i] = 0x70
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Bytes))
	return i, nil
}

func (m *CGCMsgSQLStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSQLStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SchemaCatalog))
	return i, nil
}

func (m *CGCMsgSQLStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSQLStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Threads))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ThreadsConnected))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ThreadsActive))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OperationsSubmitted))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PreparedStatementsExecuted))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.NonPreparedStatementsExecuted))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeadlockRetries))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OperationsTimedOutInQueue))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Errors))
	return i, nil
}

func (m *CMsgAMAddFreeLicense) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMAddFreeLicense) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.IpPublic))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Packageid))
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.StoreCountryCode)))
	i += copy(dAtA[i:], m.StoreCountryCode)
	return i, nil
}

func (m *CMsgAMAddFreeLicenseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMAddFreeLicenseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PurchaseResultDetail))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Transid))
	i += 8
	return i, nil
}

func (m *CGCMsgGetIPLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetIPLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ips) > 0 {
		for _, num := range m.Ips {
			dAtA[i] = 0xd
			i++
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(num))
			i += 4
		}
	}
	return i, nil
}

func (m *CIPLocationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CIPLocationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Ip))
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
	i += 4
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
	i += 4
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Country)))
	i += copy(dAtA[i:], m.Country)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.State)))
	i += copy(dAtA[i:], m.State)
	dAtA[i] = 0x32
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.City)))
	i += copy(dAtA[i:], m.City)
	return i, nil
}

func (m *CGCMsgGetIPLocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetIPLocationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgSystemStatsSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSystemStatsSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcAppId))
	if m.SchemaKv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.SchemaKv)))
		i += copy(dAtA[i:], m.SchemaKv)
	}
	return i, nil
}

func (m *CGCMsgGetSystemStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetSystemStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CGCMsgGetSystemStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetSystemStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcAppId))
	if m.StatsKv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.StatsKv)))
		i += copy(dAtA[i:], m.StatsKv)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ActiveJobs))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.YieldingJobs))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.UserSessions))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GameServerSessions))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Socaches))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SocachesToUnload))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SocachesLoading))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.WritebackQueue))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SteamidLocks))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LogonQueue))
	dAtA[i] = 0x68
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LogonJobs))
	return i, nil
}

func (m *CMsgAMSendEmail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailMsgType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailFormat))
	if len(m.PersonaNameTokens) > 0 {
		for _, msg := range m.PersonaNameTokens {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SourceGc))
	if len(m.Tokens) > 0 {
		for _, msg := range m.Tokens {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgAMSendEmail_ReplacementToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail_ReplacementToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenName)))
	i += copy(dAtA[i:], m.TokenName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenValue)))
	i += copy(dAtA[i:], m.TokenValue)
	return i, nil
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenName)))
	i += copy(dAtA[i:], m.TokenName)
	return i, nil
}

func (m *CMsgAMSendEmailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmailResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCGetEmailTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetEmailTemplate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailMsgType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailLang))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailFormat))
	return i, nil
}

func (m *CMsgGCGetEmailTemplateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetEmailTemplateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x10
	i++
	if m.TemplateExists {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Template)))
	i += copy(dAtA[i:], m.Template)
	return i, nil
}

func (m *CMsgAMGrantGuestPasses2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGrantGuestPasses2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamId))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PackageId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PassesToGrant))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DaysToExpiration))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Action))
	return i, nil
}

func (m *CMsgAMGrantGuestPasses2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGrantGuestPasses2Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	if m.PassesGranted != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.PassesGranted))
	}
	return i, nil
}

func (m *CGCSystemMsg_GetAccountDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetAccountDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	return i, nil
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetAccountDetails_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EresultDeprecated != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.EresultDeprecated))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.AccountName)))
	i += copy(dAtA[i:], m.AccountName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.PersonaName)))
	i += copy(dAtA[i:], m.PersonaName)
	dAtA[i] = 0x20
	i++
	if m.IsProfilePublic {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsInventoryPublic {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.IsVacBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.IsCyberCafe {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.IsSchoolAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	if m.IsLimited {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	if m.IsSubscribed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Package))
	dAtA[i] = 0x68
	i++
	if m.IsFreeTrialAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.FreeTrialExpiration))
	dAtA[i] = 0x78
	i++
	if m.IsLowViolence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	if m.IsAccountLockedDown {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.IsCommunityBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	if m.IsTradeBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TradeBanExpiration))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Accountid))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SuspensionEndTime))
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Currency)))
	i += copy(dAtA[i:], m.Currency)
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SteamLevel))
	dAtA[i] = 0xc0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.FriendCount))
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AccountCreationTime))
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsSteamguardEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xe0
	i++
	dAtA[i] = 0x1
	i++
	if m.IsPhoneVerified {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsTwoFactorAuthEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xf0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TwoFactorEnabledTime))
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PhoneVerificationTime))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PhoneId))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x2
	i++
	if m.IsPhoneIdentifying {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RtIdentityLinked))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RtBirthDate))
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TxnCountryCode)))
	i += copy(dAtA[i:], m.TxnCountryCode)
	return i, nil
}

func (m *CMsgGCGetPersonaNames) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Steamids) > 0 {
		for _, num := range m.Steamids {
			dAtA[i] = 0x9
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	return i, nil
}

func (m *CMsgGCGetPersonaNames_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SucceededLookups) > 0 {
		for _, msg := range m.SucceededLookups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FailedLookupSteamids) > 0 {
		for _, num := range m.FailedLookupSteamids {
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	return i, nil
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.PersonaName)))
	i += copy(dAtA[i:], m.PersonaName)
	return i, nil
}

func (m *CMsgGCCheckFriendship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCCheckFriendship) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamidLeft))
	i += 8
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamidRight))
	i += 8
	return i, nil
}

func (m *CMsgGCCheckFriendship_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCCheckFriendship_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Success {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	if m.FoundFriendship {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.MasterDirIndex))
	if len(m.Dir) > 0 {
		for _, msg := range m.Dir {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DirIndex))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Box)))
	i += copy(dAtA[i:], m.Box)
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CommandLine)))
	i += copy(dAtA[i:], m.CommandLine)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.GcBinary)))
	i += copy(dAtA[i:], m.GcBinary)
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DirIndex))
	return i, nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	return i, nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.HasPriorPurchaseHistory {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	if m.HasNoRecentPasswordResets {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	if m.IsWalletCashTrusted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TimeAllTrusted))
	return i, nil
}

func (m *CMsgGCHAccountVacStatusChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHAccountVacStatusChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamId))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RtimeVacbanStarts))
	dAtA[i] = 0x20
	i++
	if m.IsBannedNow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsBannedFuture {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCGetPartnerAccountLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPartnerAccountLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	return i, nil
}

func (m *CMsgGCGetPartnerAccountLink_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPartnerAccountLink_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Pwid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Nexonid))
	return i, nil
}

func (m *CMsgGCRoutingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRoutingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DirIndex) > 0 {
		for _, num := range m.DirIndex {
			dAtA[i] = 0x8
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	if m.Method != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Method))
	}
	if m.Fallback != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Fallback))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ProtobufField))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.WebapiParam)))
	i += copy(dAtA[i:], m.WebapiParam)
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.InterfaceName)))
	i += copy(dAtA[i:], m.InterfaceName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.MethodName)))
	i += copy(dAtA[i:], m.MethodName)
	if m.Routing != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Routing.Size()))
		n3, err3 := m.Routing.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.MsgType))
	if m.Routing != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Routing.Size()))
		n4, err4 := m.Routing.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgSetOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgSetOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, num := range m.Options {
			dAtA[i] = 0x8
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	if len(m.ClientMsgRanges) > 0 {
		for _, msg := range m.ClientMsgRanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgSetOptions_MessageRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgSetOptions_MessageRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Low))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.High))
	return i, nil
}

func (m *CMsgGCHUpdateSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHUpdateSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.SteamId))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x18
	i++
	if m.Online {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x21
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ServerSteamId))
	i += 8
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ServerAddr))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ServerPort))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OsType))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ClientAddr))
	if len(m.ExtraFields) > 0 {
		for _, msg := range m.ExtraFields {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x51
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OwnerId))
	i += 8
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmSessionSysid))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmSessionIdentifier))
	if len(m.DepotIds) > 0 {
		for _, num := range m.DepotIds {
			dAtA[i] = 0x68
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgGCHUpdateSession_ExtraField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHUpdateSession_ExtraField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgNotificationOfSuspiciousActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotificationOfSuspiciousActivity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Steamid))
	i += 8
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	if m.MultipleInstances != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.MultipleInstances.Size()))
		n5, err5 := m.MultipleInstances.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppInstanceCount))
	if len(m.OtherSteamids) > 0 {
		for _, num := range m.OtherSteamids {
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(num))
			i += 8
		}
	}
	return i, nil
}

func (m *CMsgDPPartnerMicroTxns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgDPPartnerMicroTxns) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.GcName)))
	i += copy(dAtA[i:], m.GcName)
	if m.Partner != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Partner.Size()))
		n6, err6 := m.Partner.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.InitTime))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LastUpdateTime))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TxnId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LineItem))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ItemId))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DefIndex))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Price))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Tax))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PriceUsd))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TaxUsd))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PurchaseType))
	dAtA[i] = 0x68
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SteamTxnType))
	dAtA[i] = 0x72
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CountryCode)))
	i += copy(dAtA[i:], m.CountryCode)
	dAtA[i] = 0x7a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.RegionCode)))
	i += copy(dAtA[i:], m.RegionCode)
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Quantity))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RefTransId))
	return i, nil
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PartnerId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.PartnerName)))
	i += copy(dAtA[i:], m.PartnerName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CurrencyCode)))
	i += copy(dAtA[i:], m.CurrencyCode)
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CurrencyName)))
	i += copy(dAtA[i:], m.CurrencyName)
	return i, nil
}

func (m *CMsgDPPartnerMicroTxnsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgDPPartnerMicroTxnsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	if m.Eerrorcode != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eerrorcode))
	}
	return i, nil
}

func encodeVarintSteammessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgProtoBufHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.ClientSessionId))
	n += 1 + sovSteammessages(uint64(m.SourceAppId))
	if m.JobIdSource != nil {
		n += 9
	}
	if m.JobIdTarget != nil {
		n += 9
	}
	l = len(m.TargetJobName)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	l = len(m.ErrorMessage)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 1 + sovSteammessages(uint64(m.Ip))
	if m.GcMsgSrc != nil {
		n += 2 + sovSteammessages(uint64(*m.GcMsgSrc))
	}
	n += 2 + sovSteammessages(uint64(m.GcDirIndexSource))
	return n
}

func (m *CMsgWebAPIKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovSteammessages(uint64(*m.Status))
	}
	if m.AccountId != nil {
		n += 1 + sovSteammessages(uint64(*m.AccountId))
	}
	if m.PublisherGroupId != nil {
		n += 1 + sovSteammessages(uint64(*m.PublisherGroupId))
	}
	n += 1 + sovSteammessages(uint64(m.KeyId))
	l = len(m.Domain)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgHttpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.RequestMethod))
	l = len(m.Hostname)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Url)
	n += 1 + l + sovSteammessages(uint64(l))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.GetParams) > 0 {
		for _, e := range m.GetParams {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.PostParams) > 0 {
		for _, e := range m.PostParams {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.AbsoluteTimeout))
	return n
}

func (m *CMsgHttpRequest_RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgHttpRequest_QueryParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgWebAPIRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UNUSEDJobName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.InterfaceName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.MethodName)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 1 + sovSteammessages(uint64(m.Version))
	if m.ApiKey != nil {
		l = m.ApiKey.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.RoutingAppId))
	return n
}

func (m *CMsgHttpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.StatusCode))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgHttpResponse_ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMFindAccounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.SearchType))
	l = len(m.SearchString)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMFindAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SteamId) > 0 {
		n += 9 * len(m.SteamId)
	}
	return n
}

func (m *CMsgNotifyWatchdog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Source))
	n += 1 + sovSteammessages(uint64(m.AlertType))
	n += 1 + sovSteammessages(uint64(m.AlertDestination))
	n += 2
	n += 1 + sovSteammessages(uint64(m.Time))
	n += 1 + sovSteammessages(uint64(m.Appid))
	l = len(m.Text)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMGetLicenses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgPackageLicense) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.PackageId))
	n += 1 + sovSteammessages(uint64(m.TimeCreated))
	n += 1 + sovSteammessages(uint64(m.OwnerId))
	return n
}

func (m *CMsgAMGetLicensesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.License) > 0 {
		for _, e := range m.License {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	n += 1 + sovSteammessages(uint64(m.Result))
	return n
}

func (m *CMsgAMGetUserGameStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgAMGetUserGameStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.AchievementBlocks) > 0 {
		for _, e := range m.AchievementBlocks {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.StatId))
	n += 1 + sovSteammessages(uint64(m.StatValue))
	return n
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AchievementId))
	n += 1 + sovSteammessages(uint64(m.AchievementBitId))
	n += 5
	return n
}

func (m *CMsgGCGetCommandList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppId))
	l = len(m.CommandPrefix)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCGetCommandListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CommandName) > 0 {
		for _, s := range m.CommandName {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgMemCachedSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedSet_KeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgMemCachedDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CGCMsgMemCachedStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.CurrConnections))
	n += 1 + sovSteammessages(uint64(m.CmdGet))
	n += 1 + sovSteammessages(uint64(m.CmdSet))
	n += 1 + sovSteammessages(uint64(m.CmdFlush))
	n += 1 + sovSteammessages(uint64(m.GetHits))
	n += 1 + sovSteammessages(uint64(m.GetMisses))
	n += 1 + sovSteammessages(uint64(m.DeleteHits))
	n += 1 + sovSteammessages(uint64(m.DeleteMisses))
	n += 1 + sovSteammessages(uint64(m.BytesRead))
	n += 1 + sovSteammessages(uint64(m.BytesWritten))
	n += 1 + sovSteammessages(uint64(m.LimitMaxbytes))
	n += 1 + sovSteammessages(uint64(m.CurrItems))
	n += 1 + sovSteammessages(uint64(m.Evictions))
	n += 1 + sovSteammessages(uint64(m.Bytes))
	return n
}

func (m *CGCMsgSQLStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.SchemaCatalog))
	return n
}

func (m *CGCMsgSQLStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Threads))
	n += 1 + sovSteammessages(uint64(m.ThreadsConnected))
	n += 1 + sovSteammessages(uint64(m.ThreadsActive))
	n += 1 + sovSteammessages(uint64(m.OperationsSubmitted))
	n += 1 + sovSteammessages(uint64(m.PreparedStatementsExecuted))
	n += 1 + sovSteammessages(uint64(m.NonPreparedStatementsExecuted))
	n += 1 + sovSteammessages(uint64(m.DeadlockRetries))
	n += 1 + sovSteammessages(uint64(m.OperationsTimedOutInQueue))
	n += 1 + sovSteammessages(uint64(m.Errors))
	return n
}

func (m *CMsgAMAddFreeLicense) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.IpPublic))
	n += 1 + sovSteammessages(uint64(m.Packageid))
	l = len(m.StoreCountryCode)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMAddFreeLicenseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	n += 1 + sovSteammessages(uint64(m.PurchaseResultDetail))
	n += 9
	return n
}

func (m *CGCMsgGetIPLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ips) > 0 {
		n += 5 * len(m.Ips)
	}
	return n
}

func (m *CIPLocationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Ip))
	n += 5
	n += 5
	l = len(m.Country)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.State)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.City)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CGCMsgGetIPLocationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgSystemStatsSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.GcAppId))
	if m.SchemaKv != nil {
		l = len(m.SchemaKv)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgGetSystemStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CGCMsgGetSystemStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.GcAppId))
	if m.StatsKv != nil {
		l = len(m.StatsKv)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.ActiveJobs))
	n += 1 + sovSteammessages(uint64(m.YieldingJobs))
	n += 1 + sovSteammessages(uint64(m.UserSessions))
	n += 1 + sovSteammessages(uint64(m.GameServerSessions))
	n += 1 + sovSteammessages(uint64(m.Socaches))
	n += 1 + sovSteammessages(uint64(m.SocachesToUnload))
	n += 1 + sovSteammessages(uint64(m.SocachesLoading))
	n += 1 + sovSteammessages(uint64(m.WritebackQueue))
	n += 1 + sovSteammessages(uint64(m.SteamidLocks))
	n += 1 + sovSteammessages(uint64(m.LogonQueue))
	n += 1 + sovSteammessages(uint64(m.LogonJobs))
	return n
}

func (m *CMsgAMSendEmail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.EmailMsgType))
	n += 1 + sovSteammessages(uint64(m.EmailFormat))
	if len(m.PersonaNameTokens) > 0 {
		for _, e := range m.PersonaNameTokens {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	n += 1 + sovSteammessages(uint64(m.SourceGc))
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgAMSendEmail_ReplacementToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.TokenValue)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	l = len(m.TokenName)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMSendEmailResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCGetEmailTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 1 + sovSteammessages(uint64(m.EmailMsgType))
	n += 1 + sovSteammessages(uint64(m.EmailLang))
	n += 1 + sovSteammessages(uint64(m.EmailFormat))
	return n
}

func (m *CMsgGCGetEmailTemplateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	n += 2
	l = len(m.Template)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMGrantGuestPasses2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.PackageId))
	n += 1 + sovSteammessages(uint64(m.PassesToGrant))
	n += 1 + sovSteammessages(uint64(m.DaysToExpiration))
	n += 1 + sovSteammessages(uint64(m.Action))
	return n
}

func (m *CMsgAMGrantGuestPasses2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	if m.PassesGranted != nil {
		n += 1 + sovSteammessages(uint64(*m.PassesGranted))
	}
	return n
}

func (m *CGCSystemMsg_GetAccountDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.Appid))
	return n
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EresultDeprecated != nil {
		n += 1 + sovSteammessages(uint64(*m.EresultDeprecated))
	}
	l = len(m.AccountName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.PersonaName)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovSteammessages(uint64(m.Package))
	n += 2
	n += 1 + sovSteammessages(uint64(m.FreeTrialExpiration))
	n += 2
	n += 3
	n += 3
	n += 3
	n += 2 + sovSteammessages(uint64(m.TradeBanExpiration))
	n += 2 + sovSteammessages(uint64(m.Accountid))
	n += 2 + sovSteammessages(uint64(m.SuspensionEndTime))
	l = len(m.Currency)
	n += 2 + l + sovSteammessages(uint64(l))
	n += 2 + sovSteammessages(uint64(m.SteamLevel))
	n += 2 + sovSteammessages(uint64(m.FriendCount))
	n += 2 + sovSteammessages(uint64(m.AccountCreationTime))
	n += 3
	n += 3
	n += 3
	n += 2 + sovSteammessages(uint64(m.TwoFactorEnabledTime))
	n += 2 + sovSteammessages(uint64(m.PhoneVerificationTime))
	n += 2 + sovSteammessages(uint64(m.PhoneId))
	n += 3
	n += 2 + sovSteammessages(uint64(m.RtIdentityLinked))
	n += 2 + sovSteammessages(uint64(m.RtBirthDate))
	l = len(m.TxnCountryCode)
	n += 2 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCGetPersonaNames) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Steamids) > 0 {
		n += 9 * len(m.Steamids)
	}
	return n
}

func (m *CMsgGCGetPersonaNames_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SucceededLookups) > 0 {
		for _, e := range m.SucceededLookups {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.FailedLookupSteamids) > 0 {
		n += 9 * len(m.FailedLookupSteamids)
	}
	return n
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	l = len(m.PersonaName)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCCheckFriendship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	return n
}

func (m *CMsgGCCheckFriendship_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	return n
}

func (m *CMsgGCMsgMasterSetDirectory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.MasterDirIndex))
	if len(m.Dir) > 0 {
		for _, e := range m.Dir {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.DirIndex))
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Box)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.CommandLine)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.GcBinary)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.DirIndex))
	return n
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	n += 2
	n += 1 + sovSteammessages(uint64(m.TimeAllTrusted))
	return n
}

func (m *CMsgGCHAccountVacStatusChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 1 + sovSteammessages(uint64(m.RtimeVacbanStarts))
	n += 2
	n += 2
	return n
}

func (m *CMsgGCGetPartnerAccountLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgGCGetPartnerAccountLink_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Pwid))
	n += 1 + sovSteammessages(uint64(m.Nexonid))
	return n
}

func (m *CMsgGCRoutingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DirIndex) > 0 {
		for _, e := range m.DirIndex {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	if m.Method != nil {
		n += 1 + sovSteammessages(uint64(*m.Method))
	}
	if m.Fallback != nil {
		n += 1 + sovSteammessages(uint64(*m.Fallback))
	}
	n += 1 + sovSteammessages(uint64(m.ProtobufField))
	l = len(m.WebapiParam)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InterfaceName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.MethodName)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.MsgType))
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgSetOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	if len(m.ClientMsgRanges) > 0 {
		for _, e := range m.ClientMsgRanges {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgSetOptions_MessageRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Low))
	n += 1 + sovSteammessages(uint64(m.High))
	return n
}

func (m *CMsgGCHUpdateSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 2
	n += 9
	n += 1 + sovSteammessages(uint64(m.ServerAddr))
	n += 1 + sovSteammessages(uint64(m.ServerPort))
	n += 1 + sovSteammessages(uint64(m.OsType))
	n += 1 + sovSteammessages(uint64(m.ClientAddr))
	if len(m.ExtraFields) > 0 {
		for _, e := range m.ExtraFields {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	n += 9
	n += 1 + sovSteammessages(uint64(m.CmSessionSysid))
	n += 1 + sovSteammessages(uint64(m.CmSessionIdentifier))
	if len(m.DepotIds) > 0 {
		for _, e := range m.DepotIds {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgGCHUpdateSession_ExtraField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgNotificationOfSuspiciousActivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.Appid))
	if m.MultipleInstances != nil {
		l = m.MultipleInstances.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppInstanceCount))
	if len(m.OtherSteamids) > 0 {
		n += 9 * len(m.OtherSteamids)
	}
	return n
}

func (m *CMsgDPPartnerMicroTxns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Appid))
	l = len(m.GcName)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Partner != nil {
		l = m.Partner.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.InitTime))
	n += 1 + sovSteammessages(uint64(m.LastUpdateTime))
	n += 1 + sovSteammessages(uint64(m.TxnId))
	n += 1 + sovSteammessages(uint64(m.AccountId))
	n += 1 + sovSteammessages(uint64(m.LineItem))
	n += 1 + sovSteammessages(uint64(m.ItemId))
	n += 1 + sovSteammessages(uint64(m.DefIndex))
	n += 1 + sovSteammessages(uint64(m.Price))
	n += 1 + sovSteammessages(uint64(m.Tax))
	n += 1 + sovSteammessages(uint64(m.PriceUsd))
	n += 1 + sovSteammessages(uint64(m.TaxUsd))
	n += 1 + sovSteammessages(uint64(m.PurchaseType))
	n += 1 + sovSteammessages(uint64(m.SteamTxnType))
	l = len(m.CountryCode)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.RegionCode)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 2 + sovSteammessages(uint64(m.Quantity))
	n += 2 + sovSteammessages(uint64(m.RefTransId))
	return n
}

func (m *CMsgDPPartnerMicroTxns_PartnerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.PartnerId))
	l = len(m.PartnerName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.CurrencyCode)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.CurrencyName)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgDPPartnerMicroTxnsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	if m.Eerrorcode != nil {
		n += 1 + sovSteammessages(uint64(*m.Eerrorcode))
	}
	return n
}

func sovSteammessages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSteammessages(x uint64) (n int) {
	return sovSteammessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgProtoBufHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgProtoBufHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgProtoBufHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSteamId", wireType)
			}
			m.ClientSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionId", wireType)
			}
			m.ClientSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAppId", wireType)
			}
			m.SourceAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceAppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIdSource", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.JobIdSource = &v
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIdTarget", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.JobIdTarget = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetJobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetJobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcMsgSrc", wireType)
			}
			var v GCProtoBufMsgSrc
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= GCProtoBufMsgSrc(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GcMsgSrc = &v
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcDirIndexSource", wireType)
			}
			m.GcDirIndexSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcDirIndexSource |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgWebAPIKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgWebAPIKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgWebAPIKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherGroupId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublisherGroupId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgHttpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgHttpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMethod", wireType)
			}
			m.RequestMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMethod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &CMsgHttpRequest_RequestHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GetParams = append(m.GetParams, &CMsgHttpRequest_QueryParam{})
			if err := m.GetParams[len(m.GetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostParams = append(m.PostParams, &CMsgHttpRequest_QueryParam{})
			if err := m.PostParams[len(m.PostParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsoluteTimeout", wireType)
			}
			m.AbsoluteTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbsoluteTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest_QueryParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgWebAPIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgWebAPIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgWebAPIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UNUSEDJobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UNUSEDJobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiKey == nil {
				m.ApiKey = &CMsgWebAPIKey{}
			}
			if err := m.ApiKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &CMsgHttpRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingAppId", wireType)
			}
			m.RoutingAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoutingAppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgHttpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgHttpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &CMsgHttpResponse_ResponseHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpResponse_ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMFindAccounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMFindAccounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMFindAccounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchType", wireType)
			}
			m.SearchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMFindAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMFindAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMFindAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.SteamId = append(m.SteamId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SteamId) == 0 {
					m.SteamId = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.SteamId = append(m.SteamId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotifyWatchdog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgNotifyWatchdog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgNotifyWatchdog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertType", wireType)
			}
			m.AlertType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertDestination", wireType)
			}
			m.AlertDestination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertDestination |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Critical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Critical = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetLicenses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetLicenses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetLicenses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgPackageLicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgPackageLicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgPackageLicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetLicensesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetLicensesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetLicensesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = append(m.License, &CMsgPackageLicense{})
			if err := m.License[len(m.License)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Stats = append(m.Stats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Stats) == 0 {
					m.Stats = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Stats = append(m.Stats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &CMsgAMGetUserGameStatsResponse_Stats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementBlocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementBlocks = append(m.AchievementBlocks, &CMsgAMGetUserGameStatsResponse_Achievement_Blocks{})
			if err := m.AchievementBlocks[len(m.AchievementBlocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatId", wireType)
			}
			m.StatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatValue", wireType)
			}
			m.StatValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatValue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Achievement_Blocks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Achievement_Blocks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementId", wireType)
			}
			m.AchievementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AchievementId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementBitId", wireType)
			}
			m.AchievementBitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AchievementBitId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTime", wireType)
			}
			m.UnlockTime = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockTime = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetCommandList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetCommandList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetCommandList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetCommandListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetCommandListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetCommandListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandName = append(m.CommandName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CGCMsgMemCachedGetResponse_ValueTag{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CGCMsgMemCachedSet_KeyPair{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedSet_KeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrConnections", wireType)
			}
			m.CurrConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrConnections |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdGet", wireType)
			}
			m.CmdGet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdGet |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSet", wireType)
			}
			m.CmdSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdSet |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdFlush", wireType)
			}
			m.CmdFlush = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdFlush |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetHits", wireType)
			}
			m.GetHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetMisses", wireType)
			}
			m.GetMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetMisses |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteHits", wireType)
			}
			m.DeleteHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteMisses", wireType)
			}
			m.DeleteMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteMisses |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMaxbytes", wireType)
			}
			m.LimitMaxbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMaxbytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrItems", wireType)
			}
			m.CurrItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrItems |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evictions", wireType)
			}
			m.Evictions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Evictions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSQLStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSQLStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSQLStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaCatalog", wireType)
			}
			m.SchemaCatalog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaCatalog |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSQLStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSQLStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSQLStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsConnected", wireType)
			}
			m.ThreadsConnected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadsConnected |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsActive", wireType)
			}
			m.ThreadsActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadsActive |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsSubmitted", wireType)
			}
			m.OperationsSubmitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationsSubmitted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedStatementsExecuted", wireType)
			}
			m.PreparedStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparedStatementsExecuted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonPreparedStatementsExecuted", wireType)
			}
			m.NonPreparedStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NonPreparedStatementsExecuted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlockRetries", wireType)
			}
			m.DeadlockRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlockRetries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsTimedOutInQueue", wireType)
			}
			m.OperationsTimedOutInQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationsTimedOutInQueue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMAddFreeLicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPublic", wireType)
			}
			m.IpPublic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPublic |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packageid", wireType)
			}
			m.Packageid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Packageid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreCountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreCountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMAddFreeLicenseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicenseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicenseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseResultDetail", wireType)
			}
			m.PurchaseResultDetail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurchaseResultDetail |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transid", wireType)
			}
			m.Transid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Transid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetIPLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetIPLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetIPLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Ips = append(m.Ips, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Ips) == 0 {
					m.Ips = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Ips = append(m.Ips, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ips", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CIPLocationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CIPLocationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CIPLocationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetIPLocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetIPLocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetIPLocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &CIPLocationInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSystemStatsSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSystemStatsSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSystemStatsSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAppId", wireType)
			}
			m.GcAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcAppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaKv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaKv = append(m.SchemaKv[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaKv == nil {
				m.SchemaKv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetSystemStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetSystemStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetSystemStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetSystemStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetSystemStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetSystemStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAppId", wireType)
			}
			m.GcAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcAppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsKv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsKv = append(m.StatsKv[:0], dAtA[iNdEx:postIndex]...)
			if m.StatsKv == nil {
				m.StatsKv = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveJobs", wireType)
			}
			m.ActiveJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldingJobs", wireType)
			}
			m.YieldingJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YieldingJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSessions", wireType)
			}
			m.UserSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserSessions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameServerSessions", wireType)
			}
			m.GameServerSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameServerSessions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Socaches", wireType)
			}
			m.Socaches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Socaches |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocachesToUnload", wireType)
			}
			m.SocachesToUnload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocachesToUnload |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocachesLoading", wireType)
			}
			m.SocachesLoading = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocachesLoading |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritebackQueue", wireType)
			}
			m.WritebackQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WritebackQueue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidLocks", wireType)
			}
			m.SteamidLocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamidLocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogonQueue", wireType)
			}
			m.LogonQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogonQueue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogonJobs", wireType)
			}
			m.LogonJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogonJobs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMSendEmail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMSendEmail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailMsgType", wireType)
			}
			m.EmailMsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailMsgType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailFormat", wireType)
			}
			m.EmailFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailFormat |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaNameTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaNameTokens = append(m.PersonaNameTokens, &CMsgAMSendEmail_PersonaNameReplacementToken{})
			if err := m.PersonaNameTokens[len(m.PersonaNameTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGc", wireType)
			}
			m.SourceGc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, &CMsgAMSendEmail_ReplacementToken{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail_ReplacementToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacementToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacementToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonaNameReplacementToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonaNameReplacementToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMSendEmailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMSendEmailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetEmailTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailMsgType", wireType)
			}
			m.EmailMsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailMsgType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailLang", wireType)
			}
			m.EmailLang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailLang |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailFormat", wireType)
			}
			m.EmailFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailFormat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetEmailTemplateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TemplateExists = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGrantGuestPasses2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassesToGrant", wireType)
			}
			m.PassesToGrant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassesToGrant |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaysToExpiration", wireType)
			}
			m.DaysToExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DaysToExpiration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGrantGuestPasses2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassesGranted", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassesGranted = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetAccountDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetAccountDetails_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EresultDeprecated", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EresultDeprecated = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProfilePublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProfilePublic = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInventoryPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInventoryPublic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVacBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVacBanned = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCyberCafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCyberCafe = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSchoolAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSchoolAccount = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLimited = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubscribed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubscribed = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			m.Package = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Package |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFreeTrialAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFreeTrialAccount = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTrialExpiration", wireType)
			}
			m.FreeTrialExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTrialExpiration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLowViolence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLowViolence = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAccountLockedDown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAccountLockedDown = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCommunityBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCommunityBanned = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTradeBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTradeBanned = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeBanExpiration", wireType)
			}
			m.TradeBanExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeBanExpiration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accountid", wireType)
			}
			m.Accountid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accountid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspensionEndTime", wireType)
			}
			m.SuspensionEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuspensionEndTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamLevel", wireType)
			}
			m.SteamLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendCount", wireType)
			}
			m.FriendCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountCreationTime", wireType)
			}
			m.AccountCreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountCreationTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSteamguardEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSteamguardEnabled = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhoneVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhoneVerified = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTwoFactorAuthEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTwoFactorAuthEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwoFactorEnabledTime", wireType)
			}
			m.TwoFactorEnabledTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TwoFactorEnabledTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneVerificationTime", wireType)
			}
			m.PhoneVerificationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhoneVerificationTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneId", wireType)
			}
			m.PhoneId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhoneId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhoneIdentifying", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhoneIdentifying = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtIdentityLinked", wireType)
			}
			m.RtIdentityLinked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtIdentityLinked |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtBirthDate", wireType)
			}
			m.RtBirthDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtBirthDate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnCountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnCountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Steamids = append(m.Steamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Steamids) == 0 {
					m.Steamids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Steamids = append(m.Steamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceededLookups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SucceededLookups = append(m.SucceededLookups, &CMsgGCGetPersonaNames_Response_PersonaName{})
			if err := m.SucceededLookups[len(m.SucceededLookups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.FailedLookupSteamids = append(m.FailedLookupSteamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.FailedLookupSteamids) == 0 {
					m.FailedLookupSteamids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.FailedLookupSteamids = append(m.FailedLookupSteamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedLookupSteamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonaName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonaName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCCheckFriendship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidLeft", wireType)
			}
			m.SteamidLeft = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamidLeft = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidRight", wireType)
			}
			m.SteamidRight = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamidRight = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCCheckFriendship_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundFriendship", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundFriendship = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterDirIndex", wireType)
			}
			m.MasterDirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MasterDirIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = append(m.Dir, &CMsgGCMsgMasterSetDirectory_SubGC{})
			if err := m.Dir[len(m.Dir)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubGC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubGC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
			m.DirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Box", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Box = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcBinary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcBinary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgWebAPIJobRequestForwardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgWebAPIJobRequestForwardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
			m.DirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPriorPurchaseHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPriorPurchaseHistory = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNoRecentPasswordResets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNoRecentPasswordResets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWalletCashTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWalletCashTrusted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAllTrusted", wireType)
			}
			m.TimeAllTrusted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeAllTrusted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHAccountVacStatusChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCHAccountVacStatusChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCHAccountVacStatusChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtimeVacbanStarts", wireType)
			}
			m.RtimeVacbanStarts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtimeVacbanStarts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBannedNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBannedNow = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBannedFuture", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBannedFuture = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPartnerAccountLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPartnerAccountLink_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwid", wireType)
			}
			m.Pwid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pwid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexonid", wireType)
			}
			m.Nexonid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nexonid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRoutingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRoutingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRoutingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DirIndex = append(m.DirIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DirIndex) == 0 {
					m.DirIndex = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DirIndex = append(m.DirIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var v CMsgGCRoutingInfo_RoutingMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= CMsgGCRoutingInfo_RoutingMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Method = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fallback", wireType)
			}
			var v CMsgGCRoutingInfo_RoutingMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= CMsgGCRoutingInfo_RoutingMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fallback = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtobufField", wireType)
			}
			m.ProtobufField = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtobufField |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebapiParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebapiParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CMsgGCMsgMasterSetWebAPIRouting_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &CMsgGCRoutingInfo{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CMsgGCMsgMasterSetClientMsgRouting_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &CMsgGCRoutingInfo{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgSetOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgSetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgSetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v CMsgGCMsgSetOptions_Option
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= CMsgGCMsgSetOptions_Option(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Options = append(m.Options, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Options) == 0 {
					m.Options = make([]CMsgGCMsgSetOptions_Option, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v CMsgGCMsgSetOptions_Option
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= CMsgGCMsgSetOptions_Option(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Options = append(m.Options, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientMsgRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientMsgRanges = append(m.ClientMsgRanges, &CMsgGCMsgSetOptions_MessageRange{})
			if err := m.ClientMsgRanges[len(m.ClientMsgRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgSetOptions_MessageRange) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("low")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("high")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHUpdateSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCHUpdateSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCHUpdateSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.SteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSteamId", wireType)
			}
			m.ServerSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerSteamId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddr", wireType)
			}
			m.ServerAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerAddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsType", wireType)
			}
			m.OsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			m.ClientAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientAddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraFields = append(m.ExtraFields, &CMsgGCHUpdateSession_ExtraField{})
			if err := m.ExtraFields[len(m.ExtraFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmSessionSysid", wireType)
			}
			m.CmSessionSysid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmSessionSysid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmSessionIdentifier", wireType)
			}
			m.CmSessionIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmSessionIdentifier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DepotIds = append(m.DepotIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DepotIds) == 0 {
					m.DepotIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DepotIds = append(m.DepotIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DepotIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHUpdateSession_ExtraField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotificationOfSuspiciousActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgNotificationOfSuspiciousActivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgNotificationOfSuspiciousActivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Steamid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultipleInstances == nil {
				m.MultipleInstances = &CMsgNotificationOfSuspiciousActivity_MultipleGameInstances{}
			}
			if err := m.MultipleInstances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultipleGameInstances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultipleGameInstances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstanceCount", wireType)
			}
			m.AppInstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppInstanceCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.OtherSteamids = append(m.OtherSteamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSteammessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.OtherSteamids) == 0 {
					m.OtherSteamids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.OtherSteamids = append(m.OtherSteamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherSteamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgDPPartnerMicroTxns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgDPPartnerMicroTxns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgDPPartnerMicroTxns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partner == nil {
				m.Partner = &CMsgDPPartnerMicroTxns_PartnerInfo{}
			}
			if err := m.Partner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &CMsgDPPartnerMicroTxns_PartnerMicroTxn{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgDPPartnerMicroTxns_PartnerMicroTxn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartnerMicroTxn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartnerMicroTxn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTime", wireType)
			}
			m.InitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			m.TxnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineItem", wireType)
			}
			m.LineItem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineItem |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceUsd", wireType)
			}
			m.PriceUsd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceUsd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxUsd", wireType)
			}
			m.TaxUsd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaxUsd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseType", wireType)
			}
			m.PurchaseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurchaseType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamTxnType", wireType)
			}
			m.SteamTxnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamTxnType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTransId", wireType)
			}
			m.RefTransId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefTransId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgDPPartnerMicroTxns_PartnerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartnerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartnerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerId", wireType)
			}
			m.PartnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartnerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSteammessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgDPPartnerMicroTxnsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgDPPartnerMicroTxnsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgDPPartnerMicroTxnsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eerrorcode", wireType)
			}
			var v CMsgDPPartnerMicroTxnsResponse_EErrorCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= CMsgDPPartnerMicroTxnsResponse_EErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eerrorcode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSteammessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSteammessages
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSteammessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSteammessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSteammessages
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSteammessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSteammessages   = fmt.Errorf("proto: integer overflow")
)
