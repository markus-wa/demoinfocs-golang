// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: netmessages.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type NET_Messages int32

const (
	NET_Messages_net_NOP              NET_Messages = 0
	NET_Messages_net_Disconnect       NET_Messages = 1
	NET_Messages_net_File             NET_Messages = 2
	NET_Messages_net_SplitScreenUser  NET_Messages = 3
	NET_Messages_net_Tick             NET_Messages = 4
	NET_Messages_net_StringCmd        NET_Messages = 5
	NET_Messages_net_SetConVar        NET_Messages = 6
	NET_Messages_net_SignonState      NET_Messages = 7
	NET_Messages_net_PlayerAvatarData NET_Messages = 100
)

var NET_Messages_name = map[int32]string{
	0:   "net_NOP",
	1:   "net_Disconnect",
	2:   "net_File",
	3:   "net_SplitScreenUser",
	4:   "net_Tick",
	5:   "net_StringCmd",
	6:   "net_SetConVar",
	7:   "net_SignonState",
	100: "net_PlayerAvatarData",
}
var NET_Messages_value = map[string]int32{
	"net_NOP":              0,
	"net_Disconnect":       1,
	"net_File":             2,
	"net_SplitScreenUser":  3,
	"net_Tick":             4,
	"net_StringCmd":        5,
	"net_SetConVar":        6,
	"net_SignonState":      7,
	"net_PlayerAvatarData": 100,
}

func (x NET_Messages) Enum() *NET_Messages {
	p := new(NET_Messages)
	*p = x
	return p
}
func (x NET_Messages) String() string {
	return proto.EnumName(NET_Messages_name, int32(x))
}
func (x *NET_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NET_Messages_value, data, "NET_Messages")
	if err != nil {
		return err
	}
	*x = NET_Messages(value)
	return nil
}
func (NET_Messages) EnumDescriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{0} }

type CLC_Messages int32

const (
	CLC_Messages_clc_ClientInfo         CLC_Messages = 8
	CLC_Messages_clc_Move               CLC_Messages = 9
	CLC_Messages_clc_VoiceData          CLC_Messages = 10
	CLC_Messages_clc_BaselineAck        CLC_Messages = 11
	CLC_Messages_clc_ListenEvents       CLC_Messages = 12
	CLC_Messages_clc_RespondCvarValue   CLC_Messages = 13
	CLC_Messages_clc_FileCRCCheck       CLC_Messages = 14
	CLC_Messages_clc_LoadingProgress    CLC_Messages = 15
	CLC_Messages_clc_SplitPlayerConnect CLC_Messages = 16
	CLC_Messages_clc_ClientMessage      CLC_Messages = 17
	CLC_Messages_clc_CmdKeyValues       CLC_Messages = 18
	CLC_Messages_clc_HltvReplay         CLC_Messages = 20
)

var CLC_Messages_name = map[int32]string{
	8:  "clc_ClientInfo",
	9:  "clc_Move",
	10: "clc_VoiceData",
	11: "clc_BaselineAck",
	12: "clc_ListenEvents",
	13: "clc_RespondCvarValue",
	14: "clc_FileCRCCheck",
	15: "clc_LoadingProgress",
	16: "clc_SplitPlayerConnect",
	17: "clc_ClientMessage",
	18: "clc_CmdKeyValues",
	20: "clc_HltvReplay",
}
var CLC_Messages_value = map[string]int32{
	"clc_ClientInfo":         8,
	"clc_Move":               9,
	"clc_VoiceData":          10,
	"clc_BaselineAck":        11,
	"clc_ListenEvents":       12,
	"clc_RespondCvarValue":   13,
	"clc_FileCRCCheck":       14,
	"clc_LoadingProgress":    15,
	"clc_SplitPlayerConnect": 16,
	"clc_ClientMessage":      17,
	"clc_CmdKeyValues":       18,
	"clc_HltvReplay":         20,
}

func (x CLC_Messages) Enum() *CLC_Messages {
	p := new(CLC_Messages)
	*p = x
	return p
}
func (x CLC_Messages) String() string {
	return proto.EnumName(CLC_Messages_name, int32(x))
}
func (x *CLC_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CLC_Messages_value, data, "CLC_Messages")
	if err != nil {
		return err
	}
	*x = CLC_Messages(value)
	return nil
}
func (CLC_Messages) EnumDescriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{1} }

type VoiceDataFormatT int32

const (
	VoiceDataFormatT_VOICEDATA_FORMAT_STEAM  VoiceDataFormatT = 0
	VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE VoiceDataFormatT = 1
)

var VoiceDataFormatT_name = map[int32]string{
	0: "VOICEDATA_FORMAT_STEAM",
	1: "VOICEDATA_FORMAT_ENGINE",
}
var VoiceDataFormatT_value = map[string]int32{
	"VOICEDATA_FORMAT_STEAM":  0,
	"VOICEDATA_FORMAT_ENGINE": 1,
}

func (x VoiceDataFormatT) Enum() *VoiceDataFormatT {
	p := new(VoiceDataFormatT)
	*p = x
	return p
}
func (x VoiceDataFormatT) String() string {
	return proto.EnumName(VoiceDataFormatT_name, int32(x))
}
func (x *VoiceDataFormatT) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VoiceDataFormatT_value, data, "VoiceDataFormatT")
	if err != nil {
		return err
	}
	*x = VoiceDataFormatT(value)
	return nil
}
func (VoiceDataFormatT) EnumDescriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{2} }

type ESplitScreenMessageType int32

const (
	ESplitScreenMessageType_MSG_SPLITSCREEN_ADDUSER    ESplitScreenMessageType = 0
	ESplitScreenMessageType_MSG_SPLITSCREEN_REMOVEUSER ESplitScreenMessageType = 1
	ESplitScreenMessageType_MSG_SPLITSCREEN_TYPE_BITS  ESplitScreenMessageType = 1
)

var ESplitScreenMessageType_name = map[int32]string{
	0: "MSG_SPLITSCREEN_ADDUSER",
	1: "MSG_SPLITSCREEN_REMOVEUSER",
	// Duplicate value: 1: "MSG_SPLITSCREEN_TYPE_BITS",
}
var ESplitScreenMessageType_value = map[string]int32{
	"MSG_SPLITSCREEN_ADDUSER":    0,
	"MSG_SPLITSCREEN_REMOVEUSER": 1,
	"MSG_SPLITSCREEN_TYPE_BITS":  1,
}

func (x ESplitScreenMessageType) Enum() *ESplitScreenMessageType {
	p := new(ESplitScreenMessageType)
	*p = x
	return p
}
func (x ESplitScreenMessageType) String() string {
	return proto.EnumName(ESplitScreenMessageType_name, int32(x))
}
func (x *ESplitScreenMessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ESplitScreenMessageType_value, data, "ESplitScreenMessageType")
	if err != nil {
		return err
	}
	*x = ESplitScreenMessageType(value)
	return nil
}
func (ESplitScreenMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{3}
}

type SVC_Messages int32

const (
	SVC_Messages_svc_ServerInfo        SVC_Messages = 8
	SVC_Messages_svc_SendTable         SVC_Messages = 9
	SVC_Messages_svc_ClassInfo         SVC_Messages = 10
	SVC_Messages_svc_SetPause          SVC_Messages = 11
	SVC_Messages_svc_CreateStringTable SVC_Messages = 12
	SVC_Messages_svc_UpdateStringTable SVC_Messages = 13
	SVC_Messages_svc_VoiceInit         SVC_Messages = 14
	SVC_Messages_svc_VoiceData         SVC_Messages = 15
	SVC_Messages_svc_Print             SVC_Messages = 16
	SVC_Messages_svc_Sounds            SVC_Messages = 17
	SVC_Messages_svc_SetView           SVC_Messages = 18
	SVC_Messages_svc_FixAngle          SVC_Messages = 19
	SVC_Messages_svc_CrosshairAngle    SVC_Messages = 20
	SVC_Messages_svc_BSPDecal          SVC_Messages = 21
	SVC_Messages_svc_SplitScreen       SVC_Messages = 22
	SVC_Messages_svc_UserMessage       SVC_Messages = 23
	SVC_Messages_svc_EntityMessage     SVC_Messages = 24
	SVC_Messages_svc_GameEvent         SVC_Messages = 25
	SVC_Messages_svc_PacketEntities    SVC_Messages = 26
	SVC_Messages_svc_TempEntities      SVC_Messages = 27
	SVC_Messages_svc_Prefetch          SVC_Messages = 28
	SVC_Messages_svc_Menu              SVC_Messages = 29
	SVC_Messages_svc_GameEventList     SVC_Messages = 30
	SVC_Messages_svc_GetCvarValue      SVC_Messages = 31
	SVC_Messages_svc_PaintmapData      SVC_Messages = 33
	SVC_Messages_svc_CmdKeyValues      SVC_Messages = 34
	SVC_Messages_svc_EncryptedData     SVC_Messages = 35
	SVC_Messages_svc_HltvReplay        SVC_Messages = 36
	SVC_Messages_svc_Broadcast_Command SVC_Messages = 38
)

var SVC_Messages_name = map[int32]string{
	8:  "svc_ServerInfo",
	9:  "svc_SendTable",
	10: "svc_ClassInfo",
	11: "svc_SetPause",
	12: "svc_CreateStringTable",
	13: "svc_UpdateStringTable",
	14: "svc_VoiceInit",
	15: "svc_VoiceData",
	16: "svc_Print",
	17: "svc_Sounds",
	18: "svc_SetView",
	19: "svc_FixAngle",
	20: "svc_CrosshairAngle",
	21: "svc_BSPDecal",
	22: "svc_SplitScreen",
	23: "svc_UserMessage",
	24: "svc_EntityMessage",
	25: "svc_GameEvent",
	26: "svc_PacketEntities",
	27: "svc_TempEntities",
	28: "svc_Prefetch",
	29: "svc_Menu",
	30: "svc_GameEventList",
	31: "svc_GetCvarValue",
	33: "svc_PaintmapData",
	34: "svc_CmdKeyValues",
	35: "svc_EncryptedData",
	36: "svc_HltvReplay",
	38: "svc_Broadcast_Command",
}
var SVC_Messages_value = map[string]int32{
	"svc_ServerInfo":        8,
	"svc_SendTable":         9,
	"svc_ClassInfo":         10,
	"svc_SetPause":          11,
	"svc_CreateStringTable": 12,
	"svc_UpdateStringTable": 13,
	"svc_VoiceInit":         14,
	"svc_VoiceData":         15,
	"svc_Print":             16,
	"svc_Sounds":            17,
	"svc_SetView":           18,
	"svc_FixAngle":          19,
	"svc_CrosshairAngle":    20,
	"svc_BSPDecal":          21,
	"svc_SplitScreen":       22,
	"svc_UserMessage":       23,
	"svc_EntityMessage":     24,
	"svc_GameEvent":         25,
	"svc_PacketEntities":    26,
	"svc_TempEntities":      27,
	"svc_Prefetch":          28,
	"svc_Menu":              29,
	"svc_GameEventList":     30,
	"svc_GetCvarValue":      31,
	"svc_PaintmapData":      33,
	"svc_CmdKeyValues":      34,
	"svc_EncryptedData":     35,
	"svc_HltvReplay":        36,
	"svc_Broadcast_Command": 38,
}

func (x SVC_Messages) Enum() *SVC_Messages {
	p := new(SVC_Messages)
	*p = x
	return p
}
func (x SVC_Messages) String() string {
	return proto.EnumName(SVC_Messages_name, int32(x))
}
func (x *SVC_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SVC_Messages_value, data, "SVC_Messages")
	if err != nil {
		return err
	}
	*x = SVC_Messages(value)
	return nil
}
func (SVC_Messages) EnumDescriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{4} }

type ReplayEventTypeT int32

const (
	ReplayEventTypeT_REPLAY_EVENT_CANCEL                 ReplayEventTypeT = 0
	ReplayEventTypeT_REPLAY_EVENT_DEATH                  ReplayEventTypeT = 1
	ReplayEventTypeT_REPLAY_EVENT_GENERIC                ReplayEventTypeT = 2
	ReplayEventTypeT_REPLAY_EVENT_STUCK_NEED_FULL_UPDATE ReplayEventTypeT = 3
)

var ReplayEventTypeT_name = map[int32]string{
	0: "REPLAY_EVENT_CANCEL",
	1: "REPLAY_EVENT_DEATH",
	2: "REPLAY_EVENT_GENERIC",
	3: "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE",
}
var ReplayEventTypeT_value = map[string]int32{
	"REPLAY_EVENT_CANCEL":                 0,
	"REPLAY_EVENT_DEATH":                  1,
	"REPLAY_EVENT_GENERIC":                2,
	"REPLAY_EVENT_STUCK_NEED_FULL_UPDATE": 3,
}

func (x ReplayEventTypeT) Enum() *ReplayEventTypeT {
	p := new(ReplayEventTypeT)
	*p = x
	return p
}
func (x ReplayEventTypeT) String() string {
	return proto.EnumName(ReplayEventTypeT_name, int32(x))
}
func (x *ReplayEventTypeT) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReplayEventTypeT_value, data, "ReplayEventTypeT")
	if err != nil {
		return err
	}
	*x = ReplayEventTypeT(value)
	return nil
}
func (ReplayEventTypeT) EnumDescriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{5} }

type CMsgVector struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
	Z float32 `protobuf:"fixed32,3,opt,name=z" json:"z"`
}

func (m *CMsgVector) Reset()                    { *m = CMsgVector{} }
func (m *CMsgVector) String() string            { return proto.CompactTextString(m) }
func (*CMsgVector) ProtoMessage()               {}
func (*CMsgVector) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{0} }

func (m *CMsgVector) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgVector) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CMsgVector) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type CMsgVector2D struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
}

func (m *CMsgVector2D) Reset()                    { *m = CMsgVector2D{} }
func (m *CMsgVector2D) String() string            { return proto.CompactTextString(m) }
func (*CMsgVector2D) ProtoMessage()               {}
func (*CMsgVector2D) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{1} }

func (m *CMsgVector2D) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgVector2D) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type CMsgQAngle struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
	Z float32 `protobuf:"fixed32,3,opt,name=z" json:"z"`
}

func (m *CMsgQAngle) Reset()                    { *m = CMsgQAngle{} }
func (m *CMsgQAngle) String() string            { return proto.CompactTextString(m) }
func (*CMsgQAngle) ProtoMessage()               {}
func (*CMsgQAngle) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{2} }

func (m *CMsgQAngle) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgQAngle) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CMsgQAngle) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type CMsgRGBA struct {
	R int32 `protobuf:"varint,1,opt,name=r" json:"r"`
	G int32 `protobuf:"varint,2,opt,name=g" json:"g"`
	B int32 `protobuf:"varint,3,opt,name=b" json:"b"`
	A int32 `protobuf:"varint,4,opt,name=a" json:"a"`
}

func (m *CMsgRGBA) Reset()                    { *m = CMsgRGBA{} }
func (m *CMsgRGBA) String() string            { return proto.CompactTextString(m) }
func (*CMsgRGBA) ProtoMessage()               {}
func (*CMsgRGBA) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{3} }

func (m *CMsgRGBA) GetR() int32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *CMsgRGBA) GetG() int32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *CMsgRGBA) GetB() int32 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *CMsgRGBA) GetA() int32 {
	if m != nil {
		return m.A
	}
	return 0
}

type CNETMsg_Tick struct {
	Tick                            uint32 `protobuf:"varint,1,opt,name=tick" json:"tick"`
	HostComputationtime             uint32 `protobuf:"varint,4,opt,name=host_computationtime,json=hostComputationtime" json:"host_computationtime"`
	HostComputationtimeStdDeviation uint32 `protobuf:"varint,5,opt,name=host_computationtime_std_deviation,json=hostComputationtimeStdDeviation" json:"host_computationtime_std_deviation"`
	HostFramestarttimeStdDeviation  uint32 `protobuf:"varint,6,opt,name=host_framestarttime_std_deviation,json=hostFramestarttimeStdDeviation" json:"host_framestarttime_std_deviation"`
	HltvReplayFlags                 uint32 `protobuf:"varint,7,opt,name=hltv_replay_flags,json=hltvReplayFlags" json:"hltv_replay_flags"`
}

func (m *CNETMsg_Tick) Reset()                    { *m = CNETMsg_Tick{} }
func (m *CNETMsg_Tick) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_Tick) ProtoMessage()               {}
func (*CNETMsg_Tick) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{4} }

func (m *CNETMsg_Tick) GetTick() uint32 {
	if m != nil {
		return m.Tick
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostComputationtime() uint32 {
	if m != nil {
		return m.HostComputationtime
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostComputationtimeStdDeviation() uint32 {
	if m != nil {
		return m.HostComputationtimeStdDeviation
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostFramestarttimeStdDeviation() uint32 {
	if m != nil {
		return m.HostFramestarttimeStdDeviation
	}
	return 0
}

func (m *CNETMsg_Tick) GetHltvReplayFlags() uint32 {
	if m != nil {
		return m.HltvReplayFlags
	}
	return 0
}

type CNETMsg_StringCmd struct {
	Command string `protobuf:"bytes,1,opt,name=command" json:"command"`
}

func (m *CNETMsg_StringCmd) Reset()                    { *m = CNETMsg_StringCmd{} }
func (m *CNETMsg_StringCmd) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_StringCmd) ProtoMessage()               {}
func (*CNETMsg_StringCmd) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{5} }

func (m *CNETMsg_StringCmd) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

type CNETMsg_SignonState struct {
	SignonState       uint32   `protobuf:"varint,1,opt,name=signon_state,json=signonState" json:"signon_state"`
	SpawnCount        uint32   `protobuf:"varint,2,opt,name=spawn_count,json=spawnCount" json:"spawn_count"`
	NumServerPlayers  uint32   `protobuf:"varint,3,opt,name=num_server_players,json=numServerPlayers" json:"num_server_players"`
	PlayersNetworkids []string `protobuf:"bytes,4,rep,name=players_networkids,json=playersNetworkids" json:"players_networkids,omitempty"`
	MapName           string   `protobuf:"bytes,5,opt,name=map_name,json=mapName" json:"map_name"`
}

func (m *CNETMsg_SignonState) Reset()                    { *m = CNETMsg_SignonState{} }
func (m *CNETMsg_SignonState) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_SignonState) ProtoMessage()               {}
func (*CNETMsg_SignonState) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{6} }

func (m *CNETMsg_SignonState) GetSignonState() uint32 {
	if m != nil {
		return m.SignonState
	}
	return 0
}

func (m *CNETMsg_SignonState) GetSpawnCount() uint32 {
	if m != nil {
		return m.SpawnCount
	}
	return 0
}

func (m *CNETMsg_SignonState) GetNumServerPlayers() uint32 {
	if m != nil {
		return m.NumServerPlayers
	}
	return 0
}

func (m *CNETMsg_SignonState) GetPlayersNetworkids() []string {
	if m != nil {
		return m.PlayersNetworkids
	}
	return nil
}

func (m *CNETMsg_SignonState) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

type CMsg_CVars struct {
	Cvars []*CMsg_CVars_CVar `protobuf:"bytes,1,rep,name=cvars" json:"cvars,omitempty"`
}

func (m *CMsg_CVars) Reset()                    { *m = CMsg_CVars{} }
func (m *CMsg_CVars) String() string            { return proto.CompactTextString(m) }
func (*CMsg_CVars) ProtoMessage()               {}
func (*CMsg_CVars) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{7} }

func (m *CMsg_CVars) GetCvars() []*CMsg_CVars_CVar {
	if m != nil {
		return m.Cvars
	}
	return nil
}

type CMsg_CVars_CVar struct {
	Name           string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value          string `protobuf:"bytes,2,opt,name=value" json:"value"`
	DictionaryName uint32 `protobuf:"varint,3,opt,name=dictionary_name,json=dictionaryName" json:"dictionary_name"`
}

func (m *CMsg_CVars_CVar) Reset()                    { *m = CMsg_CVars_CVar{} }
func (m *CMsg_CVars_CVar) String() string            { return proto.CompactTextString(m) }
func (*CMsg_CVars_CVar) ProtoMessage()               {}
func (*CMsg_CVars_CVar) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{7, 0} }

func (m *CMsg_CVars_CVar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsg_CVars_CVar) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *CMsg_CVars_CVar) GetDictionaryName() uint32 {
	if m != nil {
		return m.DictionaryName
	}
	return 0
}

type CNETMsg_SetConVar struct {
	Convars *CMsg_CVars `protobuf:"bytes,1,opt,name=convars" json:"convars,omitempty"`
}

func (m *CNETMsg_SetConVar) Reset()                    { *m = CNETMsg_SetConVar{} }
func (m *CNETMsg_SetConVar) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_SetConVar) ProtoMessage()               {}
func (*CNETMsg_SetConVar) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{8} }

func (m *CNETMsg_SetConVar) GetConvars() *CMsg_CVars {
	if m != nil {
		return m.Convars
	}
	return nil
}

type CNETMsg_NOP struct {
}

func (m *CNETMsg_NOP) Reset()                    { *m = CNETMsg_NOP{} }
func (m *CNETMsg_NOP) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_NOP) ProtoMessage()               {}
func (*CNETMsg_NOP) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{9} }

type CNETMsg_Disconnect struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text"`
}

func (m *CNETMsg_Disconnect) Reset()                    { *m = CNETMsg_Disconnect{} }
func (m *CNETMsg_Disconnect) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_Disconnect) ProtoMessage()               {}
func (*CNETMsg_Disconnect) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{10} }

func (m *CNETMsg_Disconnect) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CNETMsg_File struct {
	TransferId       int32  `protobuf:"varint,1,opt,name=transfer_id,json=transferId" json:"transfer_id"`
	FileName         string `protobuf:"bytes,2,opt,name=file_name,json=fileName" json:"file_name"`
	IsReplayDemoFile bool   `protobuf:"varint,3,opt,name=is_replay_demo_file,json=isReplayDemoFile" json:"is_replay_demo_file"`
	Deny             bool   `protobuf:"varint,4,opt,name=deny" json:"deny"`
}

func (m *CNETMsg_File) Reset()                    { *m = CNETMsg_File{} }
func (m *CNETMsg_File) String() string            { return proto.CompactTextString(m) }
func (*CNETMsg_File) ProtoMessage()               {}
func (*CNETMsg_File) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{11} }

func (m *CNETMsg_File) GetTransferId() int32 {
	if m != nil {
		return m.TransferId
	}
	return 0
}

func (m *CNETMsg_File) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *CNETMsg_File) GetIsReplayDemoFile() bool {
	if m != nil {
		return m.IsReplayDemoFile
	}
	return false
}

func (m *CNETMsg_File) GetDeny() bool {
	if m != nil {
		return m.Deny
	}
	return false
}

type CNETMsg_SplitScreenUser struct {
	Slot int32 `protobuf:"varint,1,opt,name=slot" json:"slot"`
}

func (m *CNETMsg_SplitScreenUser) Reset()         { *m = CNETMsg_SplitScreenUser{} }
func (m *CNETMsg_SplitScreenUser) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_SplitScreenUser) ProtoMessage()    {}
func (*CNETMsg_SplitScreenUser) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{12}
}

func (m *CNETMsg_SplitScreenUser) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

type CNETMsg_PlayerAvatarData struct {
	Accountid uint32 `protobuf:"varint,1,opt,name=accountid" json:"accountid"`
	Rgb       []byte `protobuf:"bytes,2,opt,name=rgb" json:"rgb"`
}

func (m *CNETMsg_PlayerAvatarData) Reset()         { *m = CNETMsg_PlayerAvatarData{} }
func (m *CNETMsg_PlayerAvatarData) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_PlayerAvatarData) ProtoMessage()    {}
func (*CNETMsg_PlayerAvatarData) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{13}
}

func (m *CNETMsg_PlayerAvatarData) GetAccountid() uint32 {
	if m != nil {
		return m.Accountid
	}
	return 0
}

func (m *CNETMsg_PlayerAvatarData) GetRgb() []byte {
	if m != nil {
		return m.Rgb
	}
	return nil
}

type CCLCMsg_ClientInfo struct {
	SendTableCrc uint32   `protobuf:"fixed32,1,opt,name=send_table_crc,json=sendTableCrc" json:"send_table_crc"`
	ServerCount  uint32   `protobuf:"varint,2,opt,name=server_count,json=serverCount" json:"server_count"`
	IsHltv       bool     `protobuf:"varint,3,opt,name=is_hltv,json=isHltv" json:"is_hltv"`
	IsReplay     bool     `protobuf:"varint,4,opt,name=is_replay,json=isReplay" json:"is_replay"`
	FriendsId    uint32   `protobuf:"varint,5,opt,name=friends_id,json=friendsId" json:"friends_id"`
	FriendsName  string   `protobuf:"bytes,6,opt,name=friends_name,json=friendsName" json:"friends_name"`
	CustomFiles  []uint32 `protobuf:"fixed32,7,rep,name=custom_files,json=customFiles" json:"custom_files,omitempty"`
}

func (m *CCLCMsg_ClientInfo) Reset()                    { *m = CCLCMsg_ClientInfo{} }
func (m *CCLCMsg_ClientInfo) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_ClientInfo) ProtoMessage()               {}
func (*CCLCMsg_ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{14} }

func (m *CCLCMsg_ClientInfo) GetSendTableCrc() uint32 {
	if m != nil {
		return m.SendTableCrc
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetServerCount() uint32 {
	if m != nil {
		return m.ServerCount
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetIsHltv() bool {
	if m != nil {
		return m.IsHltv
	}
	return false
}

func (m *CCLCMsg_ClientInfo) GetIsReplay() bool {
	if m != nil {
		return m.IsReplay
	}
	return false
}

func (m *CCLCMsg_ClientInfo) GetFriendsId() uint32 {
	if m != nil {
		return m.FriendsId
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetFriendsName() string {
	if m != nil {
		return m.FriendsName
	}
	return ""
}

func (m *CCLCMsg_ClientInfo) GetCustomFiles() []uint32 {
	if m != nil {
		return m.CustomFiles
	}
	return nil
}

type CCLCMsg_Move struct {
	NumBackupCommands uint32 `protobuf:"varint,1,opt,name=num_backup_commands,json=numBackupCommands" json:"num_backup_commands"`
	NumNewCommands    uint32 `protobuf:"varint,2,opt,name=num_new_commands,json=numNewCommands" json:"num_new_commands"`
	Data              []byte `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *CCLCMsg_Move) Reset()                    { *m = CCLCMsg_Move{} }
func (m *CCLCMsg_Move) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_Move) ProtoMessage()               {}
func (*CCLCMsg_Move) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{15} }

func (m *CCLCMsg_Move) GetNumBackupCommands() uint32 {
	if m != nil {
		return m.NumBackupCommands
	}
	return 0
}

func (m *CCLCMsg_Move) GetNumNewCommands() uint32 {
	if m != nil {
		return m.NumNewCommands
	}
	return 0
}

func (m *CCLCMsg_Move) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CCLCMsg_VoiceData struct {
	Data                     []byte            `protobuf:"bytes,1,opt,name=data" json:"data"`
	Xuid                     uint64            `protobuf:"fixed64,2,opt,name=xuid" json:"xuid"`
	Format                   *VoiceDataFormatT `protobuf:"varint,3,opt,name=format,enum=VoiceDataFormatT,def=1" json:"format,omitempty"`
	SequenceBytes            int32             `protobuf:"varint,4,opt,name=sequence_bytes,json=sequenceBytes" json:"sequence_bytes"`
	SectionNumber            uint32            `protobuf:"varint,5,opt,name=section_number,json=sectionNumber" json:"section_number"`
	UncompressedSampleOffset uint32            `protobuf:"varint,6,opt,name=uncompressed_sample_offset,json=uncompressedSampleOffset" json:"uncompressed_sample_offset"`
}

func (m *CCLCMsg_VoiceData) Reset()                    { *m = CCLCMsg_VoiceData{} }
func (m *CCLCMsg_VoiceData) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_VoiceData) ProtoMessage()               {}
func (*CCLCMsg_VoiceData) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{16} }

const Default_CCLCMsg_VoiceData_Format VoiceDataFormatT = VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE

func (m *CCLCMsg_VoiceData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CCLCMsg_VoiceData) GetXuid() uint64 {
	if m != nil {
		return m.Xuid
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetFormat() VoiceDataFormatT {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return Default_CCLCMsg_VoiceData_Format
}

func (m *CCLCMsg_VoiceData) GetSequenceBytes() int32 {
	if m != nil {
		return m.SequenceBytes
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetSectionNumber() uint32 {
	if m != nil {
		return m.SectionNumber
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetUncompressedSampleOffset() uint32 {
	if m != nil {
		return m.UncompressedSampleOffset
	}
	return 0
}

type CCLCMsg_BaselineAck struct {
	BaselineTick int32 `protobuf:"varint,1,opt,name=baseline_tick,json=baselineTick" json:"baseline_tick"`
	BaselineNr   int32 `protobuf:"varint,2,opt,name=baseline_nr,json=baselineNr" json:"baseline_nr"`
}

func (m *CCLCMsg_BaselineAck) Reset()                    { *m = CCLCMsg_BaselineAck{} }
func (m *CCLCMsg_BaselineAck) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_BaselineAck) ProtoMessage()               {}
func (*CCLCMsg_BaselineAck) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{17} }

func (m *CCLCMsg_BaselineAck) GetBaselineTick() int32 {
	if m != nil {
		return m.BaselineTick
	}
	return 0
}

func (m *CCLCMsg_BaselineAck) GetBaselineNr() int32 {
	if m != nil {
		return m.BaselineNr
	}
	return 0
}

type CCLCMsg_ListenEvents struct {
	EventMask []uint32 `protobuf:"fixed32,1,rep,name=event_mask,json=eventMask" json:"event_mask,omitempty"`
}

func (m *CCLCMsg_ListenEvents) Reset()                    { *m = CCLCMsg_ListenEvents{} }
func (m *CCLCMsg_ListenEvents) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_ListenEvents) ProtoMessage()               {}
func (*CCLCMsg_ListenEvents) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{18} }

func (m *CCLCMsg_ListenEvents) GetEventMask() []uint32 {
	if m != nil {
		return m.EventMask
	}
	return nil
}

type CCLCMsg_RespondCvarValue struct {
	Cookie     int32  `protobuf:"varint,1,opt,name=cookie" json:"cookie"`
	StatusCode int32  `protobuf:"varint,2,opt,name=status_code,json=statusCode" json:"status_code"`
	Name       string `protobuf:"bytes,3,opt,name=name" json:"name"`
	Value      string `protobuf:"bytes,4,opt,name=value" json:"value"`
}

func (m *CCLCMsg_RespondCvarValue) Reset()         { *m = CCLCMsg_RespondCvarValue{} }
func (m *CCLCMsg_RespondCvarValue) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_RespondCvarValue) ProtoMessage()    {}
func (*CCLCMsg_RespondCvarValue) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{19}
}

func (m *CCLCMsg_RespondCvarValue) GetCookie() int32 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *CCLCMsg_RespondCvarValue) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *CCLCMsg_RespondCvarValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CCLCMsg_RespondCvarValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CCLCMsg_FileCRCCheck struct {
	CodePath       int32  `protobuf:"varint,1,opt,name=code_path,json=codePath" json:"code_path"`
	Path           string `protobuf:"bytes,2,opt,name=path" json:"path"`
	CodeFilename   int32  `protobuf:"varint,3,opt,name=code_filename,json=codeFilename" json:"code_filename"`
	Filename       string `protobuf:"bytes,4,opt,name=filename" json:"filename"`
	FileFraction   int32  `protobuf:"varint,5,opt,name=file_fraction,json=fileFraction" json:"file_fraction"`
	Md5            []byte `protobuf:"bytes,6,opt,name=md5" json:"md5"`
	Crc            uint32 `protobuf:"varint,7,opt,name=crc" json:"crc"`
	FileHashType   int32  `protobuf:"varint,8,opt,name=file_hash_type,json=fileHashType" json:"file_hash_type"`
	FileLen        int32  `protobuf:"varint,9,opt,name=file_len,json=fileLen" json:"file_len"`
	PackFileId     int32  `protobuf:"varint,10,opt,name=pack_file_id,json=packFileId" json:"pack_file_id"`
	PackFileNumber int32  `protobuf:"varint,11,opt,name=pack_file_number,json=packFileNumber" json:"pack_file_number"`
}

func (m *CCLCMsg_FileCRCCheck) Reset()                    { *m = CCLCMsg_FileCRCCheck{} }
func (m *CCLCMsg_FileCRCCheck) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_FileCRCCheck) ProtoMessage()               {}
func (*CCLCMsg_FileCRCCheck) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{20} }

func (m *CCLCMsg_FileCRCCheck) GetCodePath() int32 {
	if m != nil {
		return m.CodePath
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *CCLCMsg_FileCRCCheck) GetCodeFilename() int32 {
	if m != nil {
		return m.CodeFilename
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *CCLCMsg_FileCRCCheck) GetFileFraction() int32 {
	if m != nil {
		return m.FileFraction
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *CCLCMsg_FileCRCCheck) GetCrc() uint32 {
	if m != nil {
		return m.Crc
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFileHashType() int32 {
	if m != nil {
		return m.FileHashType
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFileLen() int32 {
	if m != nil {
		return m.FileLen
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPackFileId() int32 {
	if m != nil {
		return m.PackFileId
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPackFileNumber() int32 {
	if m != nil {
		return m.PackFileNumber
	}
	return 0
}

type CCLCMsg_LoadingProgress struct {
	Progress int32 `protobuf:"varint,1,opt,name=progress" json:"progress"`
}

func (m *CCLCMsg_LoadingProgress) Reset()         { *m = CCLCMsg_LoadingProgress{} }
func (m *CCLCMsg_LoadingProgress) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_LoadingProgress) ProtoMessage()    {}
func (*CCLCMsg_LoadingProgress) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{21}
}

func (m *CCLCMsg_LoadingProgress) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type CCLCMsg_SplitPlayerConnect struct {
	Convars *CMsg_CVars `protobuf:"bytes,1,opt,name=convars" json:"convars,omitempty"`
}

func (m *CCLCMsg_SplitPlayerConnect) Reset()         { *m = CCLCMsg_SplitPlayerConnect{} }
func (m *CCLCMsg_SplitPlayerConnect) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_SplitPlayerConnect) ProtoMessage()    {}
func (*CCLCMsg_SplitPlayerConnect) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{22}
}

func (m *CCLCMsg_SplitPlayerConnect) GetConvars() *CMsg_CVars {
	if m != nil {
		return m.Convars
	}
	return nil
}

type CCLCMsg_CmdKeyValues struct {
	Keyvalues []byte `protobuf:"bytes,1,opt,name=keyvalues" json:"keyvalues"`
}

func (m *CCLCMsg_CmdKeyValues) Reset()                    { *m = CCLCMsg_CmdKeyValues{} }
func (m *CCLCMsg_CmdKeyValues) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_CmdKeyValues) ProtoMessage()               {}
func (*CCLCMsg_CmdKeyValues) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{23} }

func (m *CCLCMsg_CmdKeyValues) GetKeyvalues() []byte {
	if m != nil {
		return m.Keyvalues
	}
	return nil
}

type CSVCMsg_ServerInfo struct {
	Protocol                  int32   `protobuf:"varint,1,opt,name=protocol" json:"protocol"`
	ServerCount               int32   `protobuf:"varint,2,opt,name=server_count,json=serverCount" json:"server_count"`
	IsDedicated               bool    `protobuf:"varint,3,opt,name=is_dedicated,json=isDedicated" json:"is_dedicated"`
	IsOfficialValveServer     bool    `protobuf:"varint,4,opt,name=is_official_valve_server,json=isOfficialValveServer" json:"is_official_valve_server"`
	IsHltv                    bool    `protobuf:"varint,5,opt,name=is_hltv,json=isHltv" json:"is_hltv"`
	IsReplay                  bool    `protobuf:"varint,6,opt,name=is_replay,json=isReplay" json:"is_replay"`
	IsRedirectingToProxyRelay bool    `protobuf:"varint,21,opt,name=is_redirecting_to_proxy_relay,json=isRedirectingToProxyRelay" json:"is_redirecting_to_proxy_relay"`
	COs                       int32   `protobuf:"varint,7,opt,name=c_os,json=cOs" json:"c_os"`
	MapCrc                    uint32  `protobuf:"fixed32,8,opt,name=map_crc,json=mapCrc" json:"map_crc"`
	ClientCrc                 uint32  `protobuf:"fixed32,9,opt,name=client_crc,json=clientCrc" json:"client_crc"`
	StringTableCrc            uint32  `protobuf:"fixed32,10,opt,name=string_table_crc,json=stringTableCrc" json:"string_table_crc"`
	MaxClients                int32   `protobuf:"varint,11,opt,name=max_clients,json=maxClients" json:"max_clients"`
	MaxClasses                int32   `protobuf:"varint,12,opt,name=max_classes,json=maxClasses" json:"max_classes"`
	PlayerSlot                int32   `protobuf:"varint,13,opt,name=player_slot,json=playerSlot" json:"player_slot"`
	TickInterval              float32 `protobuf:"fixed32,14,opt,name=tick_interval,json=tickInterval" json:"tick_interval"`
	GameDir                   string  `protobuf:"bytes,15,opt,name=game_dir,json=gameDir" json:"game_dir"`
	MapName                   string  `protobuf:"bytes,16,opt,name=map_name,json=mapName" json:"map_name"`
	MapGroupName              string  `protobuf:"bytes,17,opt,name=map_group_name,json=mapGroupName" json:"map_group_name"`
	SkyName                   string  `protobuf:"bytes,18,opt,name=sky_name,json=skyName" json:"sky_name"`
	HostName                  string  `protobuf:"bytes,19,opt,name=host_name,json=hostName" json:"host_name"`
	PublicIp                  uint32  `protobuf:"varint,20,opt,name=public_ip,json=publicIp" json:"public_ip"`
	UgcMapId                  uint64  `protobuf:"varint,22,opt,name=ugc_map_id,json=ugcMapId" json:"ugc_map_id"`
}

func (m *CSVCMsg_ServerInfo) Reset()                    { *m = CSVCMsg_ServerInfo{} }
func (m *CSVCMsg_ServerInfo) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_ServerInfo) ProtoMessage()               {}
func (*CSVCMsg_ServerInfo) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{24} }

func (m *CSVCMsg_ServerInfo) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetServerCount() int32 {
	if m != nil {
		return m.ServerCount
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetIsDedicated() bool {
	if m != nil {
		return m.IsDedicated
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsOfficialValveServer() bool {
	if m != nil {
		return m.IsOfficialValveServer
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsHltv() bool {
	if m != nil {
		return m.IsHltv
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsReplay() bool {
	if m != nil {
		return m.IsReplay
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsRedirectingToProxyRelay() bool {
	if m != nil {
		return m.IsRedirectingToProxyRelay
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetCOs() int32 {
	if m != nil {
		return m.COs
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMapCrc() uint32 {
	if m != nil {
		return m.MapCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetClientCrc() uint32 {
	if m != nil {
		return m.ClientCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetStringTableCrc() uint32 {
	if m != nil {
		return m.StringTableCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMaxClients() int32 {
	if m != nil {
		return m.MaxClients
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMaxClasses() int32 {
	if m != nil {
		return m.MaxClasses
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetPlayerSlot() int32 {
	if m != nil {
		return m.PlayerSlot
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetTickInterval() float32 {
	if m != nil {
		return m.TickInterval
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetGameDir() string {
	if m != nil {
		return m.GameDir
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetMapGroupName() string {
	if m != nil {
		return m.MapGroupName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetSkyName() string {
	if m != nil {
		return m.SkyName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetPublicIp() uint32 {
	if m != nil {
		return m.PublicIp
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetUgcMapId() uint64 {
	if m != nil {
		return m.UgcMapId
	}
	return 0
}

type CSVCMsg_ClassInfo struct {
	CreateOnClient bool                       `protobuf:"varint,1,opt,name=create_on_client,json=createOnClient" json:"create_on_client"`
	Classes        []*CSVCMsg_ClassInfoClassT `protobuf:"bytes,2,rep,name=classes" json:"classes,omitempty"`
}

func (m *CSVCMsg_ClassInfo) Reset()                    { *m = CSVCMsg_ClassInfo{} }
func (m *CSVCMsg_ClassInfo) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_ClassInfo) ProtoMessage()               {}
func (*CSVCMsg_ClassInfo) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{25} }

func (m *CSVCMsg_ClassInfo) GetCreateOnClient() bool {
	if m != nil {
		return m.CreateOnClient
	}
	return false
}

func (m *CSVCMsg_ClassInfo) GetClasses() []*CSVCMsg_ClassInfoClassT {
	if m != nil {
		return m.Classes
	}
	return nil
}

type CSVCMsg_ClassInfoClassT struct {
	ClassId       int32  `protobuf:"varint,1,opt,name=class_id,json=classId" json:"class_id"`
	DataTableName string `protobuf:"bytes,2,opt,name=data_table_name,json=dataTableName" json:"data_table_name"`
	ClassName     string `protobuf:"bytes,3,opt,name=class_name,json=className" json:"class_name"`
}

func (m *CSVCMsg_ClassInfoClassT) Reset()         { *m = CSVCMsg_ClassInfoClassT{} }
func (m *CSVCMsg_ClassInfoClassT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_ClassInfoClassT) ProtoMessage()    {}
func (*CSVCMsg_ClassInfoClassT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{25, 0}
}

func (m *CSVCMsg_ClassInfoClassT) GetClassId() int32 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *CSVCMsg_ClassInfoClassT) GetDataTableName() string {
	if m != nil {
		return m.DataTableName
	}
	return ""
}

func (m *CSVCMsg_ClassInfoClassT) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

type CSVCMsg_SendTable struct {
	IsEnd        bool                          `protobuf:"varint,1,opt,name=is_end,json=isEnd" json:"is_end"`
	NetTableName string                        `protobuf:"bytes,2,opt,name=net_table_name,json=netTableName" json:"net_table_name"`
	NeedsDecoder bool                          `protobuf:"varint,3,opt,name=needs_decoder,json=needsDecoder" json:"needs_decoder"`
	Props        []*CSVCMsg_SendTableSendpropT `protobuf:"bytes,4,rep,name=props" json:"props,omitempty"`
}

func (m *CSVCMsg_SendTable) Reset()                    { *m = CSVCMsg_SendTable{} }
func (m *CSVCMsg_SendTable) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_SendTable) ProtoMessage()               {}
func (*CSVCMsg_SendTable) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{26} }

func (m *CSVCMsg_SendTable) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *CSVCMsg_SendTable) GetNetTableName() string {
	if m != nil {
		return m.NetTableName
	}
	return ""
}

func (m *CSVCMsg_SendTable) GetNeedsDecoder() bool {
	if m != nil {
		return m.NeedsDecoder
	}
	return false
}

func (m *CSVCMsg_SendTable) GetProps() []*CSVCMsg_SendTableSendpropT {
	if m != nil {
		return m.Props
	}
	return nil
}

type CSVCMsg_SendTableSendpropT struct {
	Type        int32   `protobuf:"varint,1,opt,name=type" json:"type"`
	VarName     string  `protobuf:"bytes,2,opt,name=var_name,json=varName" json:"var_name"`
	Flags       int32   `protobuf:"varint,3,opt,name=flags" json:"flags"`
	Priority    int32   `protobuf:"varint,4,opt,name=priority" json:"priority"`
	DtName      string  `protobuf:"bytes,5,opt,name=dt_name,json=dtName" json:"dt_name"`
	NumElements int32   `protobuf:"varint,6,opt,name=num_elements,json=numElements" json:"num_elements"`
	LowValue    float32 `protobuf:"fixed32,7,opt,name=low_value,json=lowValue" json:"low_value"`
	HighValue   float32 `protobuf:"fixed32,8,opt,name=high_value,json=highValue" json:"high_value"`
	NumBits     int32   `protobuf:"varint,9,opt,name=num_bits,json=numBits" json:"num_bits"`
}

func (m *CSVCMsg_SendTableSendpropT) Reset()         { *m = CSVCMsg_SendTableSendpropT{} }
func (m *CSVCMsg_SendTableSendpropT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SendTableSendpropT) ProtoMessage()    {}
func (*CSVCMsg_SendTableSendpropT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{26, 0}
}

func (m *CSVCMsg_SendTableSendpropT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetVarName() string {
	if m != nil {
		return m.VarName
	}
	return ""
}

func (m *CSVCMsg_SendTableSendpropT) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetDtName() string {
	if m != nil {
		return m.DtName
	}
	return ""
}

func (m *CSVCMsg_SendTableSendpropT) GetNumElements() int32 {
	if m != nil {
		return m.NumElements
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetLowValue() float32 {
	if m != nil {
		return m.LowValue
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetHighValue() float32 {
	if m != nil {
		return m.HighValue
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetNumBits() int32 {
	if m != nil {
		return m.NumBits
	}
	return 0
}

type CSVCMsg_Print struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text"`
}

func (m *CSVCMsg_Print) Reset()                    { *m = CSVCMsg_Print{} }
func (m *CSVCMsg_Print) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_Print) ProtoMessage()               {}
func (*CSVCMsg_Print) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{27} }

func (m *CSVCMsg_Print) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CSVCMsg_SetPause struct {
	Paused bool `protobuf:"varint,1,opt,name=paused" json:"paused"`
}

func (m *CSVCMsg_SetPause) Reset()                    { *m = CSVCMsg_SetPause{} }
func (m *CSVCMsg_SetPause) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_SetPause) ProtoMessage()               {}
func (*CSVCMsg_SetPause) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{28} }

func (m *CSVCMsg_SetPause) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

type CSVCMsg_SetView struct {
	EntityIndex int32 `protobuf:"varint,1,opt,name=entity_index,json=entityIndex" json:"entity_index"`
}

func (m *CSVCMsg_SetView) Reset()                    { *m = CSVCMsg_SetView{} }
func (m *CSVCMsg_SetView) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_SetView) ProtoMessage()               {}
func (*CSVCMsg_SetView) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{29} }

func (m *CSVCMsg_SetView) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

type CSVCMsg_CreateStringTable struct {
	Name              string `protobuf:"bytes,1,opt,name=name" json:"name"`
	MaxEntries        int32  `protobuf:"varint,2,opt,name=max_entries,json=maxEntries" json:"max_entries"`
	NumEntries        int32  `protobuf:"varint,3,opt,name=num_entries,json=numEntries" json:"num_entries"`
	UserDataFixedSize bool   `protobuf:"varint,4,opt,name=user_data_fixed_size,json=userDataFixedSize" json:"user_data_fixed_size"`
	UserDataSize      int32  `protobuf:"varint,5,opt,name=user_data_size,json=userDataSize" json:"user_data_size"`
	UserDataSizeBits  int32  `protobuf:"varint,6,opt,name=user_data_size_bits,json=userDataSizeBits" json:"user_data_size_bits"`
	Flags             int32  `protobuf:"varint,7,opt,name=flags" json:"flags"`
	StringData        []byte `protobuf:"bytes,8,opt,name=string_data,json=stringData" json:"string_data"`
}

func (m *CSVCMsg_CreateStringTable) Reset()         { *m = CSVCMsg_CreateStringTable{} }
func (m *CSVCMsg_CreateStringTable) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_CreateStringTable) ProtoMessage()    {}
func (*CSVCMsg_CreateStringTable) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{30}
}

func (m *CSVCMsg_CreateStringTable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSVCMsg_CreateStringTable) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetNumEntries() int32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetUserDataFixedSize() bool {
	if m != nil {
		return m.UserDataFixedSize
	}
	return false
}

func (m *CSVCMsg_CreateStringTable) GetUserDataSize() int32 {
	if m != nil {
		return m.UserDataSize
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetUserDataSizeBits() int32 {
	if m != nil {
		return m.UserDataSizeBits
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetStringData() []byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

type CSVCMsg_UpdateStringTable struct {
	TableId           int32  `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	NumChangedEntries int32  `protobuf:"varint,2,opt,name=num_changed_entries,json=numChangedEntries" json:"num_changed_entries"`
	StringData        []byte `protobuf:"bytes,3,opt,name=string_data,json=stringData" json:"string_data"`
}

func (m *CSVCMsg_UpdateStringTable) Reset()         { *m = CSVCMsg_UpdateStringTable{} }
func (m *CSVCMsg_UpdateStringTable) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_UpdateStringTable) ProtoMessage()    {}
func (*CSVCMsg_UpdateStringTable) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{31}
}

func (m *CSVCMsg_UpdateStringTable) GetTableId() int32 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *CSVCMsg_UpdateStringTable) GetNumChangedEntries() int32 {
	if m != nil {
		return m.NumChangedEntries
	}
	return 0
}

func (m *CSVCMsg_UpdateStringTable) GetStringData() []byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

type CSVCMsg_VoiceInit struct {
	Quality int32  `protobuf:"varint,1,opt,name=quality" json:"quality"`
	Codec   string `protobuf:"bytes,2,opt,name=codec" json:"codec"`
	Version *int32 `protobuf:"varint,3,opt,name=version,def=0" json:"version,omitempty"`
}

func (m *CSVCMsg_VoiceInit) Reset()                    { *m = CSVCMsg_VoiceInit{} }
func (m *CSVCMsg_VoiceInit) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_VoiceInit) ProtoMessage()               {}
func (*CSVCMsg_VoiceInit) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{32} }

const Default_CSVCMsg_VoiceInit_Version int32 = 0

func (m *CSVCMsg_VoiceInit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *CSVCMsg_VoiceInit) GetCodec() string {
	if m != nil {
		return m.Codec
	}
	return ""
}

func (m *CSVCMsg_VoiceInit) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_CSVCMsg_VoiceInit_Version
}

type CSVCMsg_VoiceData struct {
	Client                   int32             `protobuf:"varint,1,opt,name=client" json:"client"`
	Proximity                bool              `protobuf:"varint,2,opt,name=proximity" json:"proximity"`
	Xuid                     uint64            `protobuf:"fixed64,3,opt,name=xuid" json:"xuid"`
	AudibleMask              int32             `protobuf:"varint,4,opt,name=audible_mask,json=audibleMask" json:"audible_mask"`
	VoiceData                []byte            `protobuf:"bytes,5,opt,name=voice_data,json=voiceData" json:"voice_data"`
	Caster                   bool              `protobuf:"varint,6,opt,name=caster" json:"caster"`
	Format                   *VoiceDataFormatT `protobuf:"varint,7,opt,name=format,enum=VoiceDataFormatT,def=1" json:"format,omitempty"`
	SequenceBytes            int32             `protobuf:"varint,8,opt,name=sequence_bytes,json=sequenceBytes" json:"sequence_bytes"`
	SectionNumber            uint32            `protobuf:"varint,9,opt,name=section_number,json=sectionNumber" json:"section_number"`
	UncompressedSampleOffset uint32            `protobuf:"varint,10,opt,name=uncompressed_sample_offset,json=uncompressedSampleOffset" json:"uncompressed_sample_offset"`
}

func (m *CSVCMsg_VoiceData) Reset()                    { *m = CSVCMsg_VoiceData{} }
func (m *CSVCMsg_VoiceData) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_VoiceData) ProtoMessage()               {}
func (*CSVCMsg_VoiceData) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{33} }

const Default_CSVCMsg_VoiceData_Format VoiceDataFormatT = VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE

func (m *CSVCMsg_VoiceData) GetClient() int32 {
	if m != nil {
		return m.Client
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetProximity() bool {
	if m != nil {
		return m.Proximity
	}
	return false
}

func (m *CSVCMsg_VoiceData) GetXuid() uint64 {
	if m != nil {
		return m.Xuid
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetAudibleMask() int32 {
	if m != nil {
		return m.AudibleMask
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetVoiceData() []byte {
	if m != nil {
		return m.VoiceData
	}
	return nil
}

func (m *CSVCMsg_VoiceData) GetCaster() bool {
	if m != nil {
		return m.Caster
	}
	return false
}

func (m *CSVCMsg_VoiceData) GetFormat() VoiceDataFormatT {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return Default_CSVCMsg_VoiceData_Format
}

func (m *CSVCMsg_VoiceData) GetSequenceBytes() int32 {
	if m != nil {
		return m.SequenceBytes
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetSectionNumber() uint32 {
	if m != nil {
		return m.SectionNumber
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetUncompressedSampleOffset() uint32 {
	if m != nil {
		return m.UncompressedSampleOffset
	}
	return 0
}

type CSVCMsg_FixAngle struct {
	Relative bool        `protobuf:"varint,1,opt,name=relative" json:"relative"`
	Angle    *CMsgQAngle `protobuf:"bytes,2,opt,name=angle" json:"angle,omitempty"`
}

func (m *CSVCMsg_FixAngle) Reset()                    { *m = CSVCMsg_FixAngle{} }
func (m *CSVCMsg_FixAngle) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_FixAngle) ProtoMessage()               {}
func (*CSVCMsg_FixAngle) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{34} }

func (m *CSVCMsg_FixAngle) GetRelative() bool {
	if m != nil {
		return m.Relative
	}
	return false
}

func (m *CSVCMsg_FixAngle) GetAngle() *CMsgQAngle {
	if m != nil {
		return m.Angle
	}
	return nil
}

type CSVCMsg_CrosshairAngle struct {
	Angle *CMsgQAngle `protobuf:"bytes,1,opt,name=angle" json:"angle,omitempty"`
}

func (m *CSVCMsg_CrosshairAngle) Reset()         { *m = CSVCMsg_CrosshairAngle{} }
func (m *CSVCMsg_CrosshairAngle) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_CrosshairAngle) ProtoMessage()    {}
func (*CSVCMsg_CrosshairAngle) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{35}
}

func (m *CSVCMsg_CrosshairAngle) GetAngle() *CMsgQAngle {
	if m != nil {
		return m.Angle
	}
	return nil
}

type CSVCMsg_Prefetch struct {
	SoundIndex int32 `protobuf:"varint,1,opt,name=sound_index,json=soundIndex" json:"sound_index"`
}

func (m *CSVCMsg_Prefetch) Reset()                    { *m = CSVCMsg_Prefetch{} }
func (m *CSVCMsg_Prefetch) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_Prefetch) ProtoMessage()               {}
func (*CSVCMsg_Prefetch) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{36} }

func (m *CSVCMsg_Prefetch) GetSoundIndex() int32 {
	if m != nil {
		return m.SoundIndex
	}
	return 0
}

type CSVCMsg_BSPDecal struct {
	Pos               *CMsgVector `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	DecalTextureIndex int32       `protobuf:"varint,2,opt,name=decal_texture_index,json=decalTextureIndex" json:"decal_texture_index"`
	EntityIndex       int32       `protobuf:"varint,3,opt,name=entity_index,json=entityIndex" json:"entity_index"`
	ModelIndex        int32       `protobuf:"varint,4,opt,name=model_index,json=modelIndex" json:"model_index"`
	LowPriority       bool        `protobuf:"varint,5,opt,name=low_priority,json=lowPriority" json:"low_priority"`
}

func (m *CSVCMsg_BSPDecal) Reset()                    { *m = CSVCMsg_BSPDecal{} }
func (m *CSVCMsg_BSPDecal) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_BSPDecal) ProtoMessage()               {}
func (*CSVCMsg_BSPDecal) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{37} }

func (m *CSVCMsg_BSPDecal) GetPos() *CMsgVector {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CSVCMsg_BSPDecal) GetDecalTextureIndex() int32 {
	if m != nil {
		return m.DecalTextureIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetModelIndex() int32 {
	if m != nil {
		return m.ModelIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetLowPriority() bool {
	if m != nil {
		return m.LowPriority
	}
	return false
}

type CSVCMsg_SplitScreen struct {
	Type        *ESplitScreenMessageType `protobuf:"varint,1,opt,name=type,enum=ESplitScreenMessageType,def=0" json:"type,omitempty"`
	Slot        int32                    `protobuf:"varint,2,opt,name=slot" json:"slot"`
	PlayerIndex int32                    `protobuf:"varint,3,opt,name=player_index,json=playerIndex" json:"player_index"`
}

func (m *CSVCMsg_SplitScreen) Reset()                    { *m = CSVCMsg_SplitScreen{} }
func (m *CSVCMsg_SplitScreen) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_SplitScreen) ProtoMessage()               {}
func (*CSVCMsg_SplitScreen) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{38} }

const Default_CSVCMsg_SplitScreen_Type ESplitScreenMessageType = ESplitScreenMessageType_MSG_SPLITSCREEN_ADDUSER

func (m *CSVCMsg_SplitScreen) GetType() ESplitScreenMessageType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_CSVCMsg_SplitScreen_Type
}

func (m *CSVCMsg_SplitScreen) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *CSVCMsg_SplitScreen) GetPlayerIndex() int32 {
	if m != nil {
		return m.PlayerIndex
	}
	return 0
}

type CSVCMsg_GetCvarValue struct {
	Cookie   int32  `protobuf:"varint,1,opt,name=cookie" json:"cookie"`
	CvarName string `protobuf:"bytes,2,opt,name=cvar_name,json=cvarName" json:"cvar_name"`
}

func (m *CSVCMsg_GetCvarValue) Reset()                    { *m = CSVCMsg_GetCvarValue{} }
func (m *CSVCMsg_GetCvarValue) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_GetCvarValue) ProtoMessage()               {}
func (*CSVCMsg_GetCvarValue) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{39} }

func (m *CSVCMsg_GetCvarValue) GetCookie() int32 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *CSVCMsg_GetCvarValue) GetCvarName() string {
	if m != nil {
		return m.CvarName
	}
	return ""
}

type CSVCMsg_Menu struct {
	DialogType    int32  `protobuf:"varint,1,opt,name=dialog_type,json=dialogType" json:"dialog_type"`
	MenuKeyValues []byte `protobuf:"bytes,2,opt,name=menu_key_values,json=menuKeyValues" json:"menu_key_values"`
}

func (m *CSVCMsg_Menu) Reset()                    { *m = CSVCMsg_Menu{} }
func (m *CSVCMsg_Menu) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_Menu) ProtoMessage()               {}
func (*CSVCMsg_Menu) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{40} }

func (m *CSVCMsg_Menu) GetDialogType() int32 {
	if m != nil {
		return m.DialogType
	}
	return 0
}

func (m *CSVCMsg_Menu) GetMenuKeyValues() []byte {
	if m != nil {
		return m.MenuKeyValues
	}
	return nil
}

type CSVCMsg_UserMessage struct {
	MsgType     int32  `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	MsgData     []byte `protobuf:"bytes,2,opt,name=msg_data,json=msgData" json:"msg_data"`
	Passthrough int32  `protobuf:"varint,3,opt,name=passthrough" json:"passthrough"`
}

func (m *CSVCMsg_UserMessage) Reset()                    { *m = CSVCMsg_UserMessage{} }
func (m *CSVCMsg_UserMessage) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_UserMessage) ProtoMessage()               {}
func (*CSVCMsg_UserMessage) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{41} }

func (m *CSVCMsg_UserMessage) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CSVCMsg_UserMessage) GetMsgData() []byte {
	if m != nil {
		return m.MsgData
	}
	return nil
}

func (m *CSVCMsg_UserMessage) GetPassthrough() int32 {
	if m != nil {
		return m.Passthrough
	}
	return 0
}

type CSVCMsg_PaintmapData struct {
	Paintmap []byte `protobuf:"bytes,1,opt,name=paintmap" json:"paintmap"`
}

func (m *CSVCMsg_PaintmapData) Reset()                    { *m = CSVCMsg_PaintmapData{} }
func (m *CSVCMsg_PaintmapData) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_PaintmapData) ProtoMessage()               {}
func (*CSVCMsg_PaintmapData) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{42} }

func (m *CSVCMsg_PaintmapData) GetPaintmap() []byte {
	if m != nil {
		return m.Paintmap
	}
	return nil
}

type CSVCMsg_GameEvent struct {
	EventName   string                   `protobuf:"bytes,1,opt,name=event_name,json=eventName" json:"event_name"`
	Eventid     int32                    `protobuf:"varint,2,opt,name=eventid" json:"eventid"`
	Keys        []*CSVCMsg_GameEventKeyT `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	Passthrough int32                    `protobuf:"varint,4,opt,name=passthrough" json:"passthrough"`
}

func (m *CSVCMsg_GameEvent) Reset()                    { *m = CSVCMsg_GameEvent{} }
func (m *CSVCMsg_GameEvent) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEvent) ProtoMessage()               {}
func (*CSVCMsg_GameEvent) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{43} }

func (m *CSVCMsg_GameEvent) GetEventName() string {
	if m != nil {
		return m.EventName
	}
	return ""
}

func (m *CSVCMsg_GameEvent) GetEventid() int32 {
	if m != nil {
		return m.Eventid
	}
	return 0
}

func (m *CSVCMsg_GameEvent) GetKeys() []*CSVCMsg_GameEventKeyT {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CSVCMsg_GameEvent) GetPassthrough() int32 {
	if m != nil {
		return m.Passthrough
	}
	return 0
}

type CSVCMsg_GameEventKeyT struct {
	Type       int32   `protobuf:"varint,1,opt,name=type" json:"type"`
	ValString  string  `protobuf:"bytes,2,opt,name=val_string,json=valString" json:"val_string"`
	ValFloat   float32 `protobuf:"fixed32,3,opt,name=val_float,json=valFloat" json:"val_float"`
	ValLong    int32   `protobuf:"varint,4,opt,name=val_long,json=valLong" json:"val_long"`
	ValShort   int32   `protobuf:"varint,5,opt,name=val_short,json=valShort" json:"val_short"`
	ValByte    int32   `protobuf:"varint,6,opt,name=val_byte,json=valByte" json:"val_byte"`
	ValBool    bool    `protobuf:"varint,7,opt,name=val_bool,json=valBool" json:"val_bool"`
	ValUint64  uint64  `protobuf:"varint,8,opt,name=val_uint64,json=valUint64" json:"val_uint64"`
	ValWstring []byte  `protobuf:"bytes,9,opt,name=val_wstring,json=valWstring" json:"val_wstring"`
}

func (m *CSVCMsg_GameEventKeyT) Reset()         { *m = CSVCMsg_GameEventKeyT{} }
func (m *CSVCMsg_GameEventKeyT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventKeyT) ProtoMessage()    {}
func (*CSVCMsg_GameEventKeyT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{43, 0}
}

func (m *CSVCMsg_GameEventKeyT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValString() string {
	if m != nil {
		return m.ValString
	}
	return ""
}

func (m *CSVCMsg_GameEventKeyT) GetValFloat() float32 {
	if m != nil {
		return m.ValFloat
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValLong() int32 {
	if m != nil {
		return m.ValLong
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValShort() int32 {
	if m != nil {
		return m.ValShort
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValByte() int32 {
	if m != nil {
		return m.ValByte
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValBool() bool {
	if m != nil {
		return m.ValBool
	}
	return false
}

func (m *CSVCMsg_GameEventKeyT) GetValUint64() uint64 {
	if m != nil {
		return m.ValUint64
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValWstring() []byte {
	if m != nil {
		return m.ValWstring
	}
	return nil
}

type CSVCMsg_GameEventList struct {
	Descriptors []*CSVCMsg_GameEventListDescriptorT `protobuf:"bytes,1,rep,name=descriptors" json:"descriptors,omitempty"`
}

func (m *CSVCMsg_GameEventList) Reset()         { *m = CSVCMsg_GameEventList{} }
func (m *CSVCMsg_GameEventList) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventList) ProtoMessage()    {}
func (*CSVCMsg_GameEventList) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{44}
}

func (m *CSVCMsg_GameEventList) GetDescriptors() []*CSVCMsg_GameEventListDescriptorT {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

type CSVCMsg_GameEventListKeyT struct {
	Type int32  `protobuf:"varint,1,opt,name=type" json:"type"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
}

func (m *CSVCMsg_GameEventListKeyT) Reset()         { *m = CSVCMsg_GameEventListKeyT{} }
func (m *CSVCMsg_GameEventListKeyT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventListKeyT) ProtoMessage()    {}
func (*CSVCMsg_GameEventListKeyT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{44, 0}
}

func (m *CSVCMsg_GameEventListKeyT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_GameEventListKeyT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CSVCMsg_GameEventListDescriptorT struct {
	Eventid int32                        `protobuf:"varint,1,opt,name=eventid" json:"eventid"`
	Name    string                       `protobuf:"bytes,2,opt,name=name" json:"name"`
	Keys    []*CSVCMsg_GameEventListKeyT `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
}

func (m *CSVCMsg_GameEventListDescriptorT) Reset()         { *m = CSVCMsg_GameEventListDescriptorT{} }
func (m *CSVCMsg_GameEventListDescriptorT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventListDescriptorT) ProtoMessage()    {}
func (*CSVCMsg_GameEventListDescriptorT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{44, 1}
}

func (m *CSVCMsg_GameEventListDescriptorT) GetEventid() int32 {
	if m != nil {
		return m.Eventid
	}
	return 0
}

func (m *CSVCMsg_GameEventListDescriptorT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSVCMsg_GameEventListDescriptorT) GetKeys() []*CSVCMsg_GameEventListKeyT {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CSVCMsg_TempEntities struct {
	Reliable   bool   `protobuf:"varint,1,opt,name=reliable" json:"reliable"`
	NumEntries int32  `protobuf:"varint,2,opt,name=num_entries,json=numEntries" json:"num_entries"`
	EntityData []byte `protobuf:"bytes,3,opt,name=entity_data,json=entityData" json:"entity_data"`
}

func (m *CSVCMsg_TempEntities) Reset()                    { *m = CSVCMsg_TempEntities{} }
func (m *CSVCMsg_TempEntities) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_TempEntities) ProtoMessage()               {}
func (*CSVCMsg_TempEntities) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{45} }

func (m *CSVCMsg_TempEntities) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *CSVCMsg_TempEntities) GetNumEntries() int32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

func (m *CSVCMsg_TempEntities) GetEntityData() []byte {
	if m != nil {
		return m.EntityData
	}
	return nil
}

type CSVCMsg_PacketEntities struct {
	MaxEntries     int32  `protobuf:"varint,1,opt,name=max_entries,json=maxEntries" json:"max_entries"`
	UpdatedEntries int32  `protobuf:"varint,2,opt,name=updated_entries,json=updatedEntries" json:"updated_entries"`
	IsDelta        bool   `protobuf:"varint,3,opt,name=is_delta,json=isDelta" json:"is_delta"`
	UpdateBaseline bool   `protobuf:"varint,4,opt,name=update_baseline,json=updateBaseline" json:"update_baseline"`
	Baseline       int32  `protobuf:"varint,5,opt,name=baseline" json:"baseline"`
	DeltaFrom      int32  `protobuf:"varint,6,opt,name=delta_from,json=deltaFrom" json:"delta_from"`
	EntityData     []byte `protobuf:"bytes,7,opt,name=entity_data,json=entityData" json:"entity_data"`
}

func (m *CSVCMsg_PacketEntities) Reset()         { *m = CSVCMsg_PacketEntities{} }
func (m *CSVCMsg_PacketEntities) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_PacketEntities) ProtoMessage()    {}
func (*CSVCMsg_PacketEntities) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{46}
}

func (m *CSVCMsg_PacketEntities) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetUpdatedEntries() int32 {
	if m != nil {
		return m.UpdatedEntries
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetIsDelta() bool {
	if m != nil {
		return m.IsDelta
	}
	return false
}

func (m *CSVCMsg_PacketEntities) GetUpdateBaseline() bool {
	if m != nil {
		return m.UpdateBaseline
	}
	return false
}

func (m *CSVCMsg_PacketEntities) GetBaseline() int32 {
	if m != nil {
		return m.Baseline
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetDeltaFrom() int32 {
	if m != nil {
		return m.DeltaFrom
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetEntityData() []byte {
	if m != nil {
		return m.EntityData
	}
	return nil
}

type CSVCMsg_Sounds struct {
	ReliableSound bool                        `protobuf:"varint,1,opt,name=reliable_sound,json=reliableSound" json:"reliable_sound"`
	Sounds        []*CSVCMsg_SoundsSounddataT `protobuf:"bytes,2,rep,name=sounds" json:"sounds,omitempty"`
}

func (m *CSVCMsg_Sounds) Reset()                    { *m = CSVCMsg_Sounds{} }
func (m *CSVCMsg_Sounds) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_Sounds) ProtoMessage()               {}
func (*CSVCMsg_Sounds) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{47} }

func (m *CSVCMsg_Sounds) GetReliableSound() bool {
	if m != nil {
		return m.ReliableSound
	}
	return false
}

func (m *CSVCMsg_Sounds) GetSounds() []*CSVCMsg_SoundsSounddataT {
	if m != nil {
		return m.Sounds
	}
	return nil
}

type CSVCMsg_SoundsSounddataT struct {
	OriginX        int32   `protobuf:"zigzag32,1,opt,name=origin_x,json=originX" json:"origin_x"`
	OriginY        int32   `protobuf:"zigzag32,2,opt,name=origin_y,json=originY" json:"origin_y"`
	OriginZ        int32   `protobuf:"zigzag32,3,opt,name=origin_z,json=originZ" json:"origin_z"`
	Volume         uint32  `protobuf:"varint,4,opt,name=volume" json:"volume"`
	DelayValue     float32 `protobuf:"fixed32,5,opt,name=delay_value,json=delayValue" json:"delay_value"`
	SequenceNumber int32   `protobuf:"varint,6,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number"`
	EntityIndex    int32   `protobuf:"varint,7,opt,name=entity_index,json=entityIndex" json:"entity_index"`
	Channel        int32   `protobuf:"varint,8,opt,name=channel" json:"channel"`
	Pitch          int32   `protobuf:"varint,9,opt,name=pitch" json:"pitch"`
	Flags          int32   `protobuf:"varint,10,opt,name=flags" json:"flags"`
	SoundNum       uint32  `protobuf:"varint,11,opt,name=sound_num,json=soundNum" json:"sound_num"`
	SoundNumHandle uint32  `protobuf:"fixed32,12,opt,name=sound_num_handle,json=soundNumHandle" json:"sound_num_handle"`
	SpeakerEntity  int32   `protobuf:"varint,13,opt,name=speaker_entity,json=speakerEntity" json:"speaker_entity"`
	RandomSeed     int32   `protobuf:"varint,14,opt,name=random_seed,json=randomSeed" json:"random_seed"`
	SoundLevel     int32   `protobuf:"varint,15,opt,name=sound_level,json=soundLevel" json:"sound_level"`
	IsSentence     bool    `protobuf:"varint,16,opt,name=is_sentence,json=isSentence" json:"is_sentence"`
	IsAmbient      bool    `protobuf:"varint,17,opt,name=is_ambient,json=isAmbient" json:"is_ambient"`
}

func (m *CSVCMsg_SoundsSounddataT) Reset()         { *m = CSVCMsg_SoundsSounddataT{} }
func (m *CSVCMsg_SoundsSounddataT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SoundsSounddataT) ProtoMessage()    {}
func (*CSVCMsg_SoundsSounddataT) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{47, 0}
}

func (m *CSVCMsg_SoundsSounddataT) GetOriginX() int32 {
	if m != nil {
		return m.OriginX
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetOriginY() int32 {
	if m != nil {
		return m.OriginY
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetOriginZ() int32 {
	if m != nil {
		return m.OriginZ
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetVolume() uint32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetDelayValue() float32 {
	if m != nil {
		return m.DelayValue
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetPitch() int32 {
	if m != nil {
		return m.Pitch
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundNum() uint32 {
	if m != nil {
		return m.SoundNum
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundNumHandle() uint32 {
	if m != nil {
		return m.SoundNumHandle
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSpeakerEntity() int32 {
	if m != nil {
		return m.SpeakerEntity
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetRandomSeed() int32 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundLevel() int32 {
	if m != nil {
		return m.SoundLevel
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetIsSentence() bool {
	if m != nil {
		return m.IsSentence
	}
	return false
}

func (m *CSVCMsg_SoundsSounddataT) GetIsAmbient() bool {
	if m != nil {
		return m.IsAmbient
	}
	return false
}

type CSVCMsg_EntityMsg struct {
	EntIndex int32  `protobuf:"varint,1,opt,name=ent_index,json=entIndex" json:"ent_index"`
	ClassId  int32  `protobuf:"varint,2,opt,name=class_id,json=classId" json:"class_id"`
	EntData  []byte `protobuf:"bytes,3,opt,name=ent_data,json=entData" json:"ent_data"`
}

func (m *CSVCMsg_EntityMsg) Reset()                    { *m = CSVCMsg_EntityMsg{} }
func (m *CSVCMsg_EntityMsg) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_EntityMsg) ProtoMessage()               {}
func (*CSVCMsg_EntityMsg) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{48} }

func (m *CSVCMsg_EntityMsg) GetEntIndex() int32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *CSVCMsg_EntityMsg) GetClassId() int32 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *CSVCMsg_EntityMsg) GetEntData() []byte {
	if m != nil {
		return m.EntData
	}
	return nil
}

type CSVCMsg_CmdKeyValues struct {
	Keyvalues []byte `protobuf:"bytes,1,opt,name=keyvalues" json:"keyvalues"`
}

func (m *CSVCMsg_CmdKeyValues) Reset()                    { *m = CSVCMsg_CmdKeyValues{} }
func (m *CSVCMsg_CmdKeyValues) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_CmdKeyValues) ProtoMessage()               {}
func (*CSVCMsg_CmdKeyValues) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{49} }

func (m *CSVCMsg_CmdKeyValues) GetKeyvalues() []byte {
	if m != nil {
		return m.Keyvalues
	}
	return nil
}

type CSVCMsg_EncryptedData struct {
	Encrypted []byte `protobuf:"bytes,1,opt,name=encrypted" json:"encrypted"`
	KeyType   int32  `protobuf:"varint,2,opt,name=key_type,json=keyType" json:"key_type"`
}

func (m *CSVCMsg_EncryptedData) Reset()         { *m = CSVCMsg_EncryptedData{} }
func (m *CSVCMsg_EncryptedData) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_EncryptedData) ProtoMessage()    {}
func (*CSVCMsg_EncryptedData) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{50}
}

func (m *CSVCMsg_EncryptedData) GetEncrypted() []byte {
	if m != nil {
		return m.Encrypted
	}
	return nil
}

func (m *CSVCMsg_EncryptedData) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

type CSVCMsg_HltvReplay struct {
	Delay               int32   `protobuf:"varint,1,opt,name=delay" json:"delay"`
	PrimaryTarget       int32   `protobuf:"varint,2,opt,name=primary_target,json=primaryTarget" json:"primary_target"`
	ReplayStopAt        int32   `protobuf:"varint,3,opt,name=replay_stop_at,json=replayStopAt" json:"replay_stop_at"`
	ReplayStartAt       int32   `protobuf:"varint,4,opt,name=replay_start_at,json=replayStartAt" json:"replay_start_at"`
	ReplaySlowdownBegin int32   `protobuf:"varint,5,opt,name=replay_slowdown_begin,json=replaySlowdownBegin" json:"replay_slowdown_begin"`
	ReplaySlowdownEnd   int32   `protobuf:"varint,6,opt,name=replay_slowdown_end,json=replaySlowdownEnd" json:"replay_slowdown_end"`
	ReplaySlowdownRate  float32 `protobuf:"fixed32,7,opt,name=replay_slowdown_rate,json=replaySlowdownRate" json:"replay_slowdown_rate"`
}

func (m *CSVCMsg_HltvReplay) Reset()                    { *m = CSVCMsg_HltvReplay{} }
func (m *CSVCMsg_HltvReplay) String() string            { return proto.CompactTextString(m) }
func (*CSVCMsg_HltvReplay) ProtoMessage()               {}
func (*CSVCMsg_HltvReplay) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{51} }

func (m *CSVCMsg_HltvReplay) GetDelay() int32 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetPrimaryTarget() int32 {
	if m != nil {
		return m.PrimaryTarget
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplayStopAt() int32 {
	if m != nil {
		return m.ReplayStopAt
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplayStartAt() int32 {
	if m != nil {
		return m.ReplayStartAt
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownBegin() int32 {
	if m != nil {
		return m.ReplaySlowdownBegin
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownEnd() int32 {
	if m != nil {
		return m.ReplaySlowdownEnd
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownRate() float32 {
	if m != nil {
		return m.ReplaySlowdownRate
	}
	return 0
}

type CCLCMsg_HltvReplay struct {
	Request               int32   `protobuf:"varint,1,opt,name=request" json:"request"`
	SlowdownLength        float32 `protobuf:"fixed32,2,opt,name=slowdown_length,json=slowdownLength" json:"slowdown_length"`
	SlowdownRate          float32 `protobuf:"fixed32,3,opt,name=slowdown_rate,json=slowdownRate" json:"slowdown_rate"`
	PrimaryTargetEntIndex int32   `protobuf:"varint,4,opt,name=primary_target_ent_index,json=primaryTargetEntIndex" json:"primary_target_ent_index"`
	EventTime             float32 `protobuf:"fixed32,5,opt,name=event_time,json=eventTime" json:"event_time"`
}

func (m *CCLCMsg_HltvReplay) Reset()                    { *m = CCLCMsg_HltvReplay{} }
func (m *CCLCMsg_HltvReplay) String() string            { return proto.CompactTextString(m) }
func (*CCLCMsg_HltvReplay) ProtoMessage()               {}
func (*CCLCMsg_HltvReplay) Descriptor() ([]byte, []int) { return fileDescriptorNetmessages, []int{52} }

func (m *CCLCMsg_HltvReplay) GetRequest() int32 {
	if m != nil {
		return m.Request
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetSlowdownLength() float32 {
	if m != nil {
		return m.SlowdownLength
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetSlowdownRate() float32 {
	if m != nil {
		return m.SlowdownRate
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetPrimaryTargetEntIndex() int32 {
	if m != nil {
		return m.PrimaryTargetEntIndex
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetEventTime() float32 {
	if m != nil {
		return m.EventTime
	}
	return 0
}

type CSVCMsg_Broadcast_Command struct {
	Cmd string `protobuf:"bytes,1,opt,name=cmd" json:"cmd"`
}

func (m *CSVCMsg_Broadcast_Command) Reset()         { *m = CSVCMsg_Broadcast_Command{} }
func (m *CSVCMsg_Broadcast_Command) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Broadcast_Command) ProtoMessage()    {}
func (*CSVCMsg_Broadcast_Command) Descriptor() ([]byte, []int) {
	return fileDescriptorNetmessages, []int{53}
}

func (m *CSVCMsg_Broadcast_Command) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

func init() {
	proto.RegisterType((*CMsgVector)(nil), "CMsgVector")
	proto.RegisterType((*CMsgVector2D)(nil), "CMsgVector2D")
	proto.RegisterType((*CMsgQAngle)(nil), "CMsgQAngle")
	proto.RegisterType((*CMsgRGBA)(nil), "CMsgRGBA")
	proto.RegisterType((*CNETMsg_Tick)(nil), "CNETMsg_Tick")
	proto.RegisterType((*CNETMsg_StringCmd)(nil), "CNETMsg_StringCmd")
	proto.RegisterType((*CNETMsg_SignonState)(nil), "CNETMsg_SignonState")
	proto.RegisterType((*CMsg_CVars)(nil), "CMsg_CVars")
	proto.RegisterType((*CMsg_CVars_CVar)(nil), "CMsg_CVars.CVar")
	proto.RegisterType((*CNETMsg_SetConVar)(nil), "CNETMsg_SetConVar")
	proto.RegisterType((*CNETMsg_NOP)(nil), "CNETMsg_NOP")
	proto.RegisterType((*CNETMsg_Disconnect)(nil), "CNETMsg_Disconnect")
	proto.RegisterType((*CNETMsg_File)(nil), "CNETMsg_File")
	proto.RegisterType((*CNETMsg_SplitScreenUser)(nil), "CNETMsg_SplitScreenUser")
	proto.RegisterType((*CNETMsg_PlayerAvatarData)(nil), "CNETMsg_PlayerAvatarData")
	proto.RegisterType((*CCLCMsg_ClientInfo)(nil), "CCLCMsg_ClientInfo")
	proto.RegisterType((*CCLCMsg_Move)(nil), "CCLCMsg_Move")
	proto.RegisterType((*CCLCMsg_VoiceData)(nil), "CCLCMsg_VoiceData")
	proto.RegisterType((*CCLCMsg_BaselineAck)(nil), "CCLCMsg_BaselineAck")
	proto.RegisterType((*CCLCMsg_ListenEvents)(nil), "CCLCMsg_ListenEvents")
	proto.RegisterType((*CCLCMsg_RespondCvarValue)(nil), "CCLCMsg_RespondCvarValue")
	proto.RegisterType((*CCLCMsg_FileCRCCheck)(nil), "CCLCMsg_FileCRCCheck")
	proto.RegisterType((*CCLCMsg_LoadingProgress)(nil), "CCLCMsg_LoadingProgress")
	proto.RegisterType((*CCLCMsg_SplitPlayerConnect)(nil), "CCLCMsg_SplitPlayerConnect")
	proto.RegisterType((*CCLCMsg_CmdKeyValues)(nil), "CCLCMsg_CmdKeyValues")
	proto.RegisterType((*CSVCMsg_ServerInfo)(nil), "CSVCMsg_ServerInfo")
	proto.RegisterType((*CSVCMsg_ClassInfo)(nil), "CSVCMsg_ClassInfo")
	proto.RegisterType((*CSVCMsg_ClassInfoClassT)(nil), "CSVCMsg_ClassInfo.class_t")
	proto.RegisterType((*CSVCMsg_SendTable)(nil), "CSVCMsg_SendTable")
	proto.RegisterType((*CSVCMsg_SendTableSendpropT)(nil), "CSVCMsg_SendTable.sendprop_t")
	proto.RegisterType((*CSVCMsg_Print)(nil), "CSVCMsg_Print")
	proto.RegisterType((*CSVCMsg_SetPause)(nil), "CSVCMsg_SetPause")
	proto.RegisterType((*CSVCMsg_SetView)(nil), "CSVCMsg_SetView")
	proto.RegisterType((*CSVCMsg_CreateStringTable)(nil), "CSVCMsg_CreateStringTable")
	proto.RegisterType((*CSVCMsg_UpdateStringTable)(nil), "CSVCMsg_UpdateStringTable")
	proto.RegisterType((*CSVCMsg_VoiceInit)(nil), "CSVCMsg_VoiceInit")
	proto.RegisterType((*CSVCMsg_VoiceData)(nil), "CSVCMsg_VoiceData")
	proto.RegisterType((*CSVCMsg_FixAngle)(nil), "CSVCMsg_FixAngle")
	proto.RegisterType((*CSVCMsg_CrosshairAngle)(nil), "CSVCMsg_CrosshairAngle")
	proto.RegisterType((*CSVCMsg_Prefetch)(nil), "CSVCMsg_Prefetch")
	proto.RegisterType((*CSVCMsg_BSPDecal)(nil), "CSVCMsg_BSPDecal")
	proto.RegisterType((*CSVCMsg_SplitScreen)(nil), "CSVCMsg_SplitScreen")
	proto.RegisterType((*CSVCMsg_GetCvarValue)(nil), "CSVCMsg_GetCvarValue")
	proto.RegisterType((*CSVCMsg_Menu)(nil), "CSVCMsg_Menu")
	proto.RegisterType((*CSVCMsg_UserMessage)(nil), "CSVCMsg_UserMessage")
	proto.RegisterType((*CSVCMsg_PaintmapData)(nil), "CSVCMsg_PaintmapData")
	proto.RegisterType((*CSVCMsg_GameEvent)(nil), "CSVCMsg_GameEvent")
	proto.RegisterType((*CSVCMsg_GameEventKeyT)(nil), "CSVCMsg_GameEvent.key_t")
	proto.RegisterType((*CSVCMsg_GameEventList)(nil), "CSVCMsg_GameEventList")
	proto.RegisterType((*CSVCMsg_GameEventListKeyT)(nil), "CSVCMsg_GameEventList.key_t")
	proto.RegisterType((*CSVCMsg_GameEventListDescriptorT)(nil), "CSVCMsg_GameEventList.descriptor_t")
	proto.RegisterType((*CSVCMsg_TempEntities)(nil), "CSVCMsg_TempEntities")
	proto.RegisterType((*CSVCMsg_PacketEntities)(nil), "CSVCMsg_PacketEntities")
	proto.RegisterType((*CSVCMsg_Sounds)(nil), "CSVCMsg_Sounds")
	proto.RegisterType((*CSVCMsg_SoundsSounddataT)(nil), "CSVCMsg_Sounds.sounddata_t")
	proto.RegisterType((*CSVCMsg_EntityMsg)(nil), "CSVCMsg_EntityMsg")
	proto.RegisterType((*CSVCMsg_CmdKeyValues)(nil), "CSVCMsg_CmdKeyValues")
	proto.RegisterType((*CSVCMsg_EncryptedData)(nil), "CSVCMsg_EncryptedData")
	proto.RegisterType((*CSVCMsg_HltvReplay)(nil), "CSVCMsg_HltvReplay")
	proto.RegisterType((*CCLCMsg_HltvReplay)(nil), "CCLCMsg_HltvReplay")
	proto.RegisterType((*CSVCMsg_Broadcast_Command)(nil), "CSVCMsg_Broadcast_Command")
	proto.RegisterEnum("NET_Messages", NET_Messages_name, NET_Messages_value)
	proto.RegisterEnum("CLC_Messages", CLC_Messages_name, CLC_Messages_value)
	proto.RegisterEnum("VoiceDataFormatT", VoiceDataFormatT_name, VoiceDataFormatT_value)
	proto.RegisterEnum("ESplitScreenMessageType", ESplitScreenMessageType_name, ESplitScreenMessageType_value)
	proto.RegisterEnum("SVC_Messages", SVC_Messages_name, SVC_Messages_value)
	proto.RegisterEnum("ReplayEventTypeT", ReplayEventTypeT_name, ReplayEventTypeT_value)
}
func (m *CMsgVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.Y))))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.Z))))
	return i, nil
}

func (m *CMsgVector2D) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgVector2D) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.Y))))
	return i, nil
}

func (m *CMsgQAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgQAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.Y))))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.Z))))
	return i, nil
}

func (m *CMsgRGBA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgRGBA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.R))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.G))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.B))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.A))
	return i, nil
}

func (m *CNETMsg_Tick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_Tick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Tick))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostComputationtime))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostComputationtimeStdDeviation))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostFramestarttimeStdDeviation))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HltvReplayFlags))
	return i, nil
}

func (m *CNETMsg_StringCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_StringCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Command)))
	i += copy(dAtA[i:], m.Command)
	return i, nil
}

func (m *CNETMsg_SignonState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SignonState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SignonState))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SpawnCount))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumServerPlayers))
	if len(m.PlayersNetworkids) > 0 {
		for _, s := range m.PlayersNetworkids {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapName)))
	i += copy(dAtA[i:], m.MapName)
	return i, nil
}

func (m *CMsg_CVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsg_CVars) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cvars) > 0 {
		for _, msg := range m.Cvars {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsg_CVars_CVar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsg_CVars_CVar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DictionaryName))
	return i, nil
}

func (m *CNETMsg_SetConVar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SetConVar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Convars != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Convars.Size()))
		n1, err := m.Convars.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CNETMsg_NOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_NOP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CNETMsg_Disconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_Disconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CNETMsg_File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.TransferId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	dAtA[i] = 0x18
	i++
	if m.IsReplayDemoFile {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.Deny {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CNETMsg_SplitScreenUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SplitScreenUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Slot))
	return i, nil
}

func (m *CNETMsg_PlayerAvatarData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_PlayerAvatarData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Accountid))
	if m.Rgb != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Rgb)))
		i += copy(dAtA[i:], m.Rgb)
	}
	return i, nil
}

func (m *CCLCMsg_ClientInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_ClientInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(m.SendTableCrc))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ServerCount))
	dAtA[i] = 0x18
	i++
	if m.IsHltv {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.IsReplay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FriendsId))
	dAtA[i] = 0x32
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.FriendsName)))
	i += copy(dAtA[i:], m.FriendsName)
	if len(m.CustomFiles) > 0 {
		for _, num := range m.CustomFiles {
			dAtA[i] = 0x3d
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	return i, nil
}

func (m *CCLCMsg_Move) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_Move) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumBackupCommands))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumNewCommands))
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *CCLCMsg_VoiceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_VoiceData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Netmessages(dAtA, i, uint64(m.Xuid))
	if m.Format != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Format))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceBytes))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SectionNumber))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UncompressedSampleOffset))
	return i, nil
}

func (m *CCLCMsg_BaselineAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_BaselineAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.BaselineTick))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.BaselineNr))
	return i, nil
}

func (m *CCLCMsg_ListenEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_ListenEvents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventMask) > 0 {
		for _, num := range m.EventMask {
			dAtA[i] = 0xd
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	return i, nil
}

func (m *CCLCMsg_RespondCvarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_RespondCvarValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Cookie))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.StatusCode))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x22
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CCLCMsg_FileCRCCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_FileCRCCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.CodePath))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.CodeFilename))
	dAtA[i] = 0x22
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Filename)))
	i += copy(dAtA[i:], m.Filename)
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileFraction))
	if m.Md5 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Crc))
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileHashType))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileLen))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PackFileId))
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PackFileNumber))
	return i, nil
}

func (m *CCLCMsg_LoadingProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_LoadingProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Progress))
	return i, nil
}

func (m *CCLCMsg_SplitPlayerConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_SplitPlayerConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Convars != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Convars.Size()))
		n2, err := m.Convars.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CCLCMsg_CmdKeyValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_CmdKeyValues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyvalues != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Keyvalues)))
		i += copy(dAtA[i:], m.Keyvalues)
	}
	return i, nil
}

func (m *CSVCMsg_ServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ServerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Protocol))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ServerCount))
	dAtA[i] = 0x18
	i++
	if m.IsDedicated {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.IsOfficialValveServer {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsHltv {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.IsReplay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.COs))
	dAtA[i] = 0x45
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(m.MapCrc))
	dAtA[i] = 0x4d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(m.ClientCrc))
	dAtA[i] = 0x55
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(m.StringTableCrc))
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxClients))
	dAtA[i] = 0x60
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxClasses))
	dAtA[i] = 0x68
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PlayerSlot))
	dAtA[i] = 0x75
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.TickInterval))))
	dAtA[i] = 0x7a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.GameDir)))
	i += copy(dAtA[i:], m.GameDir)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapName)))
	i += copy(dAtA[i:], m.MapName)
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapGroupName)))
	i += copy(dAtA[i:], m.MapGroupName)
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.SkyName)))
	i += copy(dAtA[i:], m.SkyName)
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.HostName)))
	i += copy(dAtA[i:], m.HostName)
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PublicIp))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsRedirectingToProxyRelay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xb0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UgcMapId))
	return i, nil
}

func (m *CSVCMsg_ClassInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ClassInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.CreateOnClient {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Classes) > 0 {
		for _, msg := range m.Classes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_ClassInfoClassT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ClassInfoClassT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ClassId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.DataTableName)))
	i += copy(dAtA[i:], m.DataTableName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ClassName)))
	i += copy(dAtA[i:], m.ClassName)
	return i, nil
}

func (m *CSVCMsg_SendTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SendTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.IsEnd {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.NetTableName)))
	i += copy(dAtA[i:], m.NetTableName)
	dAtA[i] = 0x18
	i++
	if m.NeedsDecoder {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Props) > 0 {
		for _, msg := range m.Props {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_SendTableSendpropT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SendTableSendpropT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.VarName)))
	i += copy(dAtA[i:], m.VarName)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Priority))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.DtName)))
	i += copy(dAtA[i:], m.DtName)
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumElements))
	dAtA[i] = 0x3d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.LowValue))))
	dAtA[i] = 0x45
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.HighValue))))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumBits))
	return i, nil
}

func (m *CSVCMsg_Print) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Print) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CSVCMsg_SetPause) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SetPause) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Paused {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_SetView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SetView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	return i, nil
}

func (m *CSVCMsg_CreateStringTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CreateStringTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxEntries))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumEntries))
	dAtA[i] = 0x20
	i++
	if m.UserDataFixedSize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UserDataSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UserDataSizeBits))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	if m.StringData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.StringData)))
		i += copy(dAtA[i:], m.StringData)
	}
	return i, nil
}

func (m *CSVCMsg_UpdateStringTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_UpdateStringTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.TableId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumChangedEntries))
	if m.StringData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.StringData)))
		i += copy(dAtA[i:], m.StringData)
	}
	return i, nil
}

func (m *CSVCMsg_VoiceInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_VoiceInit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Quality))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Codec)))
	i += copy(dAtA[i:], m.Codec)
	if m.Version != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Version))
	}
	return i, nil
}

func (m *CSVCMsg_VoiceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_VoiceData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Client))
	dAtA[i] = 0x10
	i++
	if m.Proximity {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x19
	i++
	i = encodeFixed64Netmessages(dAtA, i, uint64(m.Xuid))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.AudibleMask))
	if m.VoiceData != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.VoiceData)))
		i += copy(dAtA[i:], m.VoiceData)
	}
	dAtA[i] = 0x30
	i++
	if m.Caster {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Format != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Format))
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceBytes))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SectionNumber))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UncompressedSampleOffset))
	return i, nil
}

func (m *CSVCMsg_FixAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_FixAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Relative {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Angle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Angle.Size()))
		n3, err := m.Angle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CSVCMsg_CrosshairAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CrosshairAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Angle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Angle.Size()))
		n4, err := m.Angle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *CSVCMsg_Prefetch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Prefetch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundIndex))
	return i, nil
}

func (m *CSVCMsg_BSPDecal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_BSPDecal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Pos.Size()))
		n5, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DecalTextureIndex))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ModelIndex))
	dAtA[i] = 0x28
	i++
	if m.LowPriority {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_SplitScreen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SplitScreen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Type))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Slot))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PlayerIndex))
	return i, nil
}

func (m *CSVCMsg_GetCvarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GetCvarValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Cookie))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.CvarName)))
	i += copy(dAtA[i:], m.CvarName)
	return i, nil
}

func (m *CSVCMsg_Menu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Menu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DialogType))
	if m.MenuKeyValues != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MenuKeyValues)))
		i += copy(dAtA[i:], m.MenuKeyValues)
	}
	return i, nil
}

func (m *CSVCMsg_UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MsgType))
	if m.MsgData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MsgData)))
		i += copy(dAtA[i:], m.MsgData)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Passthrough))
	return i, nil
}

func (m *CSVCMsg_PaintmapData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_PaintmapData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Paintmap != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Paintmap)))
		i += copy(dAtA[i:], m.Paintmap)
	}
	return i, nil
}

func (m *CSVCMsg_GameEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EventName)))
	i += copy(dAtA[i:], m.EventName)
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Eventid))
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Passthrough))
	return i, nil
}

func (m *CSVCMsg_GameEventKeyT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventKeyT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ValString)))
	i += copy(dAtA[i:], m.ValString)
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.ValFloat))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValLong))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValShort))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValByte))
	dAtA[i] = 0x38
	i++
	if m.ValBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValUint64))
	if m.ValWstring != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ValWstring)))
		i += copy(dAtA[i:], m.ValWstring)
	}
	return i, nil
}

func (m *CSVCMsg_GameEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, msg := range m.Descriptors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_GameEventListKeyT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventListKeyT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *CSVCMsg_GameEventListDescriptorT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventListDescriptorT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Eventid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_TempEntities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_TempEntities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Reliable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumEntries))
	if m.EntityData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntityData)))
		i += copy(dAtA[i:], m.EntityData)
	}
	return i, nil
}

func (m *CSVCMsg_PacketEntities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_PacketEntities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxEntries))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UpdatedEntries))
	dAtA[i] = 0x18
	i++
	if m.IsDelta {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.UpdateBaseline {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Baseline))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DeltaFrom))
	if m.EntityData != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntityData)))
		i += copy(dAtA[i:], m.EntityData)
	}
	return i, nil
}

func (m *CSVCMsg_Sounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Sounds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.ReliableSound {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Sounds) > 0 {
		for _, msg := range m.Sounds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_SoundsSounddataT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SoundsSounddataT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginX)<<1)^uint32((m.OriginX>>31))))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginY)<<1)^uint32((m.OriginY>>31))))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginZ)<<1)^uint32((m.OriginZ>>31))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Volume))
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.DelayValue))))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceNumber))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Channel))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Pitch))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundNum))
	dAtA[i] = 0x65
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(m.SoundNumHandle))
	dAtA[i] = 0x68
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SpeakerEntity))
	dAtA[i] = 0x70
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.RandomSeed))
	dAtA[i] = 0x78
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundLevel))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	if m.IsSentence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.IsAmbient {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_EntityMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_EntityMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntIndex))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ClassId))
	if m.EntData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntData)))
		i += copy(dAtA[i:], m.EntData)
	}
	return i, nil
}

func (m *CSVCMsg_CmdKeyValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CmdKeyValues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyvalues != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Keyvalues)))
		i += copy(dAtA[i:], m.Keyvalues)
	}
	return i, nil
}

func (m *CSVCMsg_EncryptedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_EncryptedData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encrypted != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Encrypted)))
		i += copy(dAtA[i:], m.Encrypted)
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.KeyType))
	return i, nil
}

func (m *CSVCMsg_HltvReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_HltvReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Delay))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PrimaryTarget))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplayStopAt))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplayStartAt))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplaySlowdownBegin))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplaySlowdownEnd))
	dAtA[i] = 0x3d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.ReplaySlowdownRate))))
	return i, nil
}

func (m *CCLCMsg_HltvReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_HltvReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Request))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.SlowdownLength))))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.SlowdownRate))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PrimaryTargetEntIndex))
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32Netmessages(dAtA, i, uint32(math.Float32bits(float32(m.EventTime))))
	return i, nil
}

func (m *CSVCMsg_Broadcast_Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Broadcast_Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Cmd)))
	i += copy(dAtA[i:], m.Cmd)
	return i, nil
}

func encodeFixed64Netmessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Netmessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNetmessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgVector) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	return n
}

func (m *CMsgVector2D) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func (m *CMsgQAngle) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	return n
}

func (m *CMsgRGBA) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.R))
	n += 1 + sovNetmessages(uint64(m.G))
	n += 1 + sovNetmessages(uint64(m.B))
	n += 1 + sovNetmessages(uint64(m.A))
	return n
}

func (m *CNETMsg_Tick) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Tick))
	n += 1 + sovNetmessages(uint64(m.HostComputationtime))
	n += 1 + sovNetmessages(uint64(m.HostComputationtimeStdDeviation))
	n += 1 + sovNetmessages(uint64(m.HostFramestarttimeStdDeviation))
	n += 1 + sovNetmessages(uint64(m.HltvReplayFlags))
	return n
}

func (m *CNETMsg_StringCmd) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CNETMsg_SignonState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.SignonState))
	n += 1 + sovNetmessages(uint64(m.SpawnCount))
	n += 1 + sovNetmessages(uint64(m.NumServerPlayers))
	if len(m.PlayersNetworkids) > 0 {
		for _, s := range m.PlayersNetworkids {
			l = len(s)
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	l = len(m.MapName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CMsg_CVars) Size() (n int) {
	var l int
	_ = l
	if len(m.Cvars) > 0 {
		for _, e := range m.Cvars {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsg_CVars_CVar) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.DictionaryName))
	return n
}

func (m *CNETMsg_SetConVar) Size() (n int) {
	var l int
	_ = l
	if m.Convars != nil {
		l = m.Convars.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CNETMsg_NOP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CNETMsg_Disconnect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CNETMsg_File) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.TransferId))
	l = len(m.FileName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 2
	n += 2
	return n
}

func (m *CNETMsg_SplitScreenUser) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Slot))
	return n
}

func (m *CNETMsg_PlayerAvatarData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Accountid))
	if m.Rgb != nil {
		l = len(m.Rgb)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_ClientInfo) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 1 + sovNetmessages(uint64(m.ServerCount))
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.FriendsId))
	l = len(m.FriendsName)
	n += 1 + l + sovNetmessages(uint64(l))
	if len(m.CustomFiles) > 0 {
		n += 5 * len(m.CustomFiles)
	}
	return n
}

func (m *CCLCMsg_Move) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.NumBackupCommands))
	n += 1 + sovNetmessages(uint64(m.NumNewCommands))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_VoiceData) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 9
	if m.Format != nil {
		n += 1 + sovNetmessages(uint64(*m.Format))
	}
	n += 1 + sovNetmessages(uint64(m.SequenceBytes))
	n += 1 + sovNetmessages(uint64(m.SectionNumber))
	n += 1 + sovNetmessages(uint64(m.UncompressedSampleOffset))
	return n
}

func (m *CCLCMsg_BaselineAck) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.BaselineTick))
	n += 1 + sovNetmessages(uint64(m.BaselineNr))
	return n
}

func (m *CCLCMsg_ListenEvents) Size() (n int) {
	var l int
	_ = l
	if len(m.EventMask) > 0 {
		n += 5 * len(m.EventMask)
	}
	return n
}

func (m *CCLCMsg_RespondCvarValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Cookie))
	n += 1 + sovNetmessages(uint64(m.StatusCode))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CCLCMsg_FileCRCCheck) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.CodePath))
	l = len(m.Path)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.CodeFilename))
	l = len(m.Filename)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.FileFraction))
	if m.Md5 != nil {
		l = len(m.Md5)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.Crc))
	n += 1 + sovNetmessages(uint64(m.FileHashType))
	n += 1 + sovNetmessages(uint64(m.FileLen))
	n += 1 + sovNetmessages(uint64(m.PackFileId))
	n += 1 + sovNetmessages(uint64(m.PackFileNumber))
	return n
}

func (m *CCLCMsg_LoadingProgress) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Progress))
	return n
}

func (m *CCLCMsg_SplitPlayerConnect) Size() (n int) {
	var l int
	_ = l
	if m.Convars != nil {
		l = m.Convars.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_CmdKeyValues) Size() (n int) {
	var l int
	_ = l
	if m.Keyvalues != nil {
		l = len(m.Keyvalues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_ServerInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Protocol))
	n += 1 + sovNetmessages(uint64(m.ServerCount))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.COs))
	n += 5
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.MaxClients))
	n += 1 + sovNetmessages(uint64(m.MaxClasses))
	n += 1 + sovNetmessages(uint64(m.PlayerSlot))
	n += 5
	l = len(m.GameDir)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.MapName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.MapGroupName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.SkyName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.HostName)
	n += 2 + l + sovNetmessages(uint64(l))
	n += 2 + sovNetmessages(uint64(m.PublicIp))
	n += 3
	n += 2 + sovNetmessages(uint64(m.UgcMapId))
	return n
}

func (m *CSVCMsg_ClassInfo) Size() (n int) {
	var l int
	_ = l
	n += 2
	if len(m.Classes) > 0 {
		for _, e := range m.Classes {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_ClassInfoClassT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.ClassId))
	l = len(m.DataTableName)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.ClassName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_SendTable) Size() (n int) {
	var l int
	_ = l
	n += 2
	l = len(m.NetTableName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 2
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_SendTableSendpropT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.VarName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.Flags))
	n += 1 + sovNetmessages(uint64(m.Priority))
	l = len(m.DtName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.NumElements))
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.NumBits))
	return n
}

func (m *CSVCMsg_Print) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_SetPause) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}

func (m *CSVCMsg_SetView) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	return n
}

func (m *CSVCMsg_CreateStringTable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.MaxEntries))
	n += 1 + sovNetmessages(uint64(m.NumEntries))
	n += 2
	n += 1 + sovNetmessages(uint64(m.UserDataSize))
	n += 1 + sovNetmessages(uint64(m.UserDataSizeBits))
	n += 1 + sovNetmessages(uint64(m.Flags))
	if m.StringData != nil {
		l = len(m.StringData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_UpdateStringTable) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.TableId))
	n += 1 + sovNetmessages(uint64(m.NumChangedEntries))
	if m.StringData != nil {
		l = len(m.StringData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_VoiceInit) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Quality))
	l = len(m.Codec)
	n += 1 + l + sovNetmessages(uint64(l))
	if m.Version != nil {
		n += 1 + sovNetmessages(uint64(*m.Version))
	}
	return n
}

func (m *CSVCMsg_VoiceData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Client))
	n += 2
	n += 9
	n += 1 + sovNetmessages(uint64(m.AudibleMask))
	if m.VoiceData != nil {
		l = len(m.VoiceData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 2
	if m.Format != nil {
		n += 1 + sovNetmessages(uint64(*m.Format))
	}
	n += 1 + sovNetmessages(uint64(m.SequenceBytes))
	n += 1 + sovNetmessages(uint64(m.SectionNumber))
	n += 1 + sovNetmessages(uint64(m.UncompressedSampleOffset))
	return n
}

func (m *CSVCMsg_FixAngle) Size() (n int) {
	var l int
	_ = l
	n += 2
	if m.Angle != nil {
		l = m.Angle.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_CrosshairAngle) Size() (n int) {
	var l int
	_ = l
	if m.Angle != nil {
		l = m.Angle.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_Prefetch) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.SoundIndex))
	return n
}

func (m *CSVCMsg_BSPDecal) Size() (n int) {
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.DecalTextureIndex))
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	n += 1 + sovNetmessages(uint64(m.ModelIndex))
	n += 2
	return n
}

func (m *CSVCMsg_SplitScreen) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovNetmessages(uint64(*m.Type))
	}
	n += 1 + sovNetmessages(uint64(m.Slot))
	n += 1 + sovNetmessages(uint64(m.PlayerIndex))
	return n
}

func (m *CSVCMsg_GetCvarValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Cookie))
	l = len(m.CvarName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_Menu) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.DialogType))
	if m.MenuKeyValues != nil {
		l = len(m.MenuKeyValues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_UserMessage) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.MsgType))
	if m.MsgData != nil {
		l = len(m.MsgData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.Passthrough))
	return n
}

func (m *CSVCMsg_PaintmapData) Size() (n int) {
	var l int
	_ = l
	if m.Paintmap != nil {
		l = len(m.Paintmap)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_GameEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.Eventid))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	n += 1 + sovNetmessages(uint64(m.Passthrough))
	return n
}

func (m *CSVCMsg_GameEventKeyT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.ValString)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 5
	n += 1 + sovNetmessages(uint64(m.ValLong))
	n += 1 + sovNetmessages(uint64(m.ValShort))
	n += 1 + sovNetmessages(uint64(m.ValByte))
	n += 2
	n += 1 + sovNetmessages(uint64(m.ValUint64))
	if m.ValWstring != nil {
		l = len(m.ValWstring)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_GameEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_GameEventListKeyT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_GameEventListDescriptorT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Eventid))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_TempEntities) Size() (n int) {
	var l int
	_ = l
	n += 2
	n += 1 + sovNetmessages(uint64(m.NumEntries))
	if m.EntityData != nil {
		l = len(m.EntityData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_PacketEntities) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.MaxEntries))
	n += 1 + sovNetmessages(uint64(m.UpdatedEntries))
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.Baseline))
	n += 1 + sovNetmessages(uint64(m.DeltaFrom))
	if m.EntityData != nil {
		l = len(m.EntityData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_Sounds) Size() (n int) {
	var l int
	_ = l
	n += 2
	if len(m.Sounds) > 0 {
		for _, e := range m.Sounds {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_SoundsSounddataT) Size() (n int) {
	var l int
	_ = l
	n += 1 + sozNetmessages(uint64(m.OriginX))
	n += 1 + sozNetmessages(uint64(m.OriginY))
	n += 1 + sozNetmessages(uint64(m.OriginZ))
	n += 1 + sovNetmessages(uint64(m.Volume))
	n += 5
	n += 1 + sovNetmessages(uint64(m.SequenceNumber))
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	n += 1 + sovNetmessages(uint64(m.Channel))
	n += 1 + sovNetmessages(uint64(m.Pitch))
	n += 1 + sovNetmessages(uint64(m.Flags))
	n += 1 + sovNetmessages(uint64(m.SoundNum))
	n += 5
	n += 1 + sovNetmessages(uint64(m.SpeakerEntity))
	n += 1 + sovNetmessages(uint64(m.RandomSeed))
	n += 1 + sovNetmessages(uint64(m.SoundLevel))
	n += 3
	n += 3
	return n
}

func (m *CSVCMsg_EntityMsg) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.EntIndex))
	n += 1 + sovNetmessages(uint64(m.ClassId))
	if m.EntData != nil {
		l = len(m.EntData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_CmdKeyValues) Size() (n int) {
	var l int
	_ = l
	if m.Keyvalues != nil {
		l = len(m.Keyvalues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_EncryptedData) Size() (n int) {
	var l int
	_ = l
	if m.Encrypted != nil {
		l = len(m.Encrypted)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.KeyType))
	return n
}

func (m *CSVCMsg_HltvReplay) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Delay))
	n += 1 + sovNetmessages(uint64(m.PrimaryTarget))
	n += 1 + sovNetmessages(uint64(m.ReplayStopAt))
	n += 1 + sovNetmessages(uint64(m.ReplayStartAt))
	n += 1 + sovNetmessages(uint64(m.ReplaySlowdownBegin))
	n += 1 + sovNetmessages(uint64(m.ReplaySlowdownEnd))
	n += 5
	return n
}

func (m *CCLCMsg_HltvReplay) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Request))
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.PrimaryTargetEntIndex))
	n += 5
	return n
}

func (m *CSVCMsg_Broadcast_Command) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cmd)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func sovNetmessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNetmessages(x uint64) (n int) {
	return sovNetmessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgVector2D) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgVector2D: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgVector2D: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgQAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgQAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgQAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgRGBA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgRGBA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgRGBA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			m.R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.R |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			m.G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.G |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_Tick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_Tick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_Tick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tick", wireType)
			}
			m.Tick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tick |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostComputationtime", wireType)
			}
			m.HostComputationtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostComputationtime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostComputationtimeStdDeviation", wireType)
			}
			m.HostComputationtimeStdDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostComputationtimeStdDeviation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostFramestarttimeStdDeviation", wireType)
			}
			m.HostFramestarttimeStdDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostFramestarttimeStdDeviation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HltvReplayFlags", wireType)
			}
			m.HltvReplayFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HltvReplayFlags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_StringCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_StringCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_StringCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SignonState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SignonState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SignonState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignonState", wireType)
			}
			m.SignonState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignonState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpawnCount", wireType)
			}
			m.SpawnCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpawnCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumServerPlayers", wireType)
			}
			m.NumServerPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumServerPlayers |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayersNetworkids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayersNetworkids = append(m.PlayersNetworkids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsg_CVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsg_CVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsg_CVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cvars = append(m.Cvars, &CMsg_CVars_CVar{})
			if err := m.Cvars[len(m.Cvars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsg_CVars_CVar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DictionaryName", wireType)
			}
			m.DictionaryName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DictionaryName |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SetConVar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SetConVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SetConVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Convars == nil {
				m.Convars = &CMsg_CVars{}
			}
			if err := m.Convars.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_NOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_NOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_NOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_Disconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_Disconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_Disconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			m.TransferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplayDemoFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplayDemoFile = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deny", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deny = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SplitScreenUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SplitScreenUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SplitScreenUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_PlayerAvatarData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_PlayerAvatarData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_PlayerAvatarData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accountid", wireType)
			}
			m.Accountid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accountid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rgb", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rgb = append(m.Rgb[:0], dAtA[iNdEx:postIndex]...)
			if m.Rgb == nil {
				m.Rgb = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_ClientInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_ClientInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_ClientInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTableCrc", wireType)
			}
			m.SendTableCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.SendTableCrc = uint32(dAtA[iNdEx-4])
			m.SendTableCrc |= uint32(dAtA[iNdEx-3]) << 8
			m.SendTableCrc |= uint32(dAtA[iNdEx-2]) << 16
			m.SendTableCrc |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCount", wireType)
			}
			m.ServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHltv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHltv = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplay = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendsId", wireType)
			}
			m.FriendsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendsId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				m.CustomFiles = append(m.CustomFiles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					m.CustomFiles = append(m.CustomFiles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFiles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_Move) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_Move: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_Move: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBackupCommands", wireType)
			}
			m.NumBackupCommands = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBackupCommands |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNewCommands", wireType)
			}
			m.NumNewCommands = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNewCommands |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_VoiceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_VoiceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_VoiceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xuid", wireType)
			}
			m.Xuid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Xuid = uint64(dAtA[iNdEx-8])
			m.Xuid |= uint64(dAtA[iNdEx-7]) << 8
			m.Xuid |= uint64(dAtA[iNdEx-6]) << 16
			m.Xuid |= uint64(dAtA[iNdEx-5]) << 24
			m.Xuid |= uint64(dAtA[iNdEx-4]) << 32
			m.Xuid |= uint64(dAtA[iNdEx-3]) << 40
			m.Xuid |= uint64(dAtA[iNdEx-2]) << 48
			m.Xuid |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var v VoiceDataFormatT
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (VoiceDataFormatT(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Format = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceBytes", wireType)
			}
			m.SequenceBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceBytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionNumber", wireType)
			}
			m.SectionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSampleOffset", wireType)
			}
			m.UncompressedSampleOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedSampleOffset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_BaselineAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_BaselineAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_BaselineAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineTick", wireType)
			}
			m.BaselineTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaselineTick |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineNr", wireType)
			}
			m.BaselineNr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaselineNr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_ListenEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_ListenEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_ListenEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				m.EventMask = append(m.EventMask, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					m.EventMask = append(m.EventMask, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventMask", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_RespondCvarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_RespondCvarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_RespondCvarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_FileCRCCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_FileCRCCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_FileCRCCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodePath", wireType)
			}
			m.CodePath = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodePath |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeFilename", wireType)
			}
			m.CodeFilename = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeFilename |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFraction", wireType)
			}
			m.FileFraction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFraction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc", wireType)
			}
			m.Crc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashType", wireType)
			}
			m.FileHashType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHashType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLen", wireType)
			}
			m.FileLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackFileId", wireType)
			}
			m.PackFileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackFileId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackFileNumber", wireType)
			}
			m.PackFileNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackFileNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_LoadingProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_LoadingProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_LoadingProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_SplitPlayerConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_SplitPlayerConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_SplitPlayerConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Convars == nil {
				m.Convars = &CMsg_CVars{}
			}
			if err := m.Convars.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_CmdKeyValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_CmdKeyValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_CmdKeyValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyvalues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyvalues = append(m.Keyvalues[:0], dAtA[iNdEx:postIndex]...)
			if m.Keyvalues == nil {
				m.Keyvalues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_ServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_ServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCount", wireType)
			}
			m.ServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDedicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDedicated = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOfficialValveServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOfficialValveServer = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHltv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHltv = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplay = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field COs", wireType)
			}
			m.COs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.COs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapCrc", wireType)
			}
			m.MapCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.MapCrc = uint32(dAtA[iNdEx-4])
			m.MapCrc |= uint32(dAtA[iNdEx-3]) << 8
			m.MapCrc |= uint32(dAtA[iNdEx-2]) << 16
			m.MapCrc |= uint32(dAtA[iNdEx-1]) << 24
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCrc", wireType)
			}
			m.ClientCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCrc = uint32(dAtA[iNdEx-4])
			m.ClientCrc |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCrc |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCrc |= uint32(dAtA[iNdEx-1]) << 24
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTableCrc", wireType)
			}
			m.StringTableCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.StringTableCrc = uint32(dAtA[iNdEx-4])
			m.StringTableCrc |= uint32(dAtA[iNdEx-3]) << 8
			m.StringTableCrc |= uint32(dAtA[iNdEx-2]) << 16
			m.StringTableCrc |= uint32(dAtA[iNdEx-1]) << 24
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClients", wireType)
			}
			m.MaxClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClasses", wireType)
			}
			m.MaxClasses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClasses |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerSlot", wireType)
			}
			m.PlayerSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerSlot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickInterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.TickInterval = float32(math.Float32frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			m.PublicIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicIp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRedirectingToProxyRelay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRedirectingToProxyRelay = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UgcMapId", wireType)
			}
			m.UgcMapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UgcMapId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ClassInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_ClassInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_ClassInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOnClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateOnClient = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classes = append(m.Classes, &CSVCMsg_ClassInfoClassT{})
			if err := m.Classes[len(m.Classes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ClassInfoClassT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: class_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: class_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SendTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SendTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SendTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedsDecoder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedsDecoder = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &CSVCMsg_SendTableSendpropT{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SendTableSendpropT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendprop_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendprop_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VarName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VarName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumElements", wireType)
			}
			m.NumElements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumElements |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.LowValue = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.HighValue = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBits", wireType)
			}
			m.NumBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Print) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Print: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Print: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SetPause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SetPause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SetPause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SetView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SetView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SetView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CreateStringTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CreateStringTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CreateStringTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntries", wireType)
			}
			m.MaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataFixedSize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserDataFixedSize = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataSize", wireType)
			}
			m.UserDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserDataSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataSizeBits", wireType)
			}
			m.UserDataSizeBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserDataSizeBits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData[:0], dAtA[iNdEx:postIndex]...)
			if m.StringData == nil {
				m.StringData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_UpdateStringTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_UpdateStringTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_UpdateStringTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumChangedEntries", wireType)
			}
			m.NumChangedEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumChangedEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData[:0], dAtA[iNdEx:postIndex]...)
			if m.StringData == nil {
				m.StringData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_VoiceInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_VoiceInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_VoiceInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_VoiceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_VoiceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_VoiceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			m.Client = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Client |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proximity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proximity = bool(v != 0)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xuid", wireType)
			}
			m.Xuid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Xuid = uint64(dAtA[iNdEx-8])
			m.Xuid |= uint64(dAtA[iNdEx-7]) << 8
			m.Xuid |= uint64(dAtA[iNdEx-6]) << 16
			m.Xuid |= uint64(dAtA[iNdEx-5]) << 24
			m.Xuid |= uint64(dAtA[iNdEx-4]) << 32
			m.Xuid |= uint64(dAtA[iNdEx-3]) << 40
			m.Xuid |= uint64(dAtA[iNdEx-2]) << 48
			m.Xuid |= uint64(dAtA[iNdEx-1]) << 56
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudibleMask", wireType)
			}
			m.AudibleMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudibleMask |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoiceData = append(m.VoiceData[:0], dAtA[iNdEx:postIndex]...)
			if m.VoiceData == nil {
				m.VoiceData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Caster = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var v VoiceDataFormatT
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (VoiceDataFormatT(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Format = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceBytes", wireType)
			}
			m.SequenceBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceBytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionNumber", wireType)
			}
			m.SectionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSampleOffset", wireType)
			}
			m.UncompressedSampleOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedSampleOffset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_FixAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_FixAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_FixAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Relative = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Angle == nil {
				m.Angle = &CMsgQAngle{}
			}
			if err := m.Angle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CrosshairAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CrosshairAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CrosshairAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Angle == nil {
				m.Angle = &CMsgQAngle{}
			}
			if err := m.Angle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Prefetch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Prefetch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Prefetch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundIndex", wireType)
			}
			m.SoundIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_BSPDecal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_BSPDecal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_BSPDecal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &CMsgVector{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecalTextureIndex", wireType)
			}
			m.DecalTextureIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecalTextureIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelIndex", wireType)
			}
			m.ModelIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowPriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowPriority = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SplitScreen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SplitScreen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SplitScreen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ESplitScreenMessageType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ESplitScreenMessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerIndex", wireType)
			}
			m.PlayerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GetCvarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GetCvarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GetCvarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvarName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CvarName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Menu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Menu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Menu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogType", wireType)
			}
			m.DialogType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DialogType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MenuKeyValues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MenuKeyValues = append(m.MenuKeyValues[:0], dAtA[iNdEx:postIndex]...)
			if m.MenuKeyValues == nil {
				m.MenuKeyValues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_UserMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgData = append(m.MsgData[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgData == nil {
				m.MsgData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passthrough", wireType)
			}
			m.Passthrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passthrough |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_PaintmapData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_PaintmapData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_PaintmapData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paintmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paintmap = append(m.Paintmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Paintmap == nil {
				m.Paintmap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GameEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GameEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eventid", wireType)
			}
			m.Eventid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Eventid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CSVCMsg_GameEventKeyT{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passthrough", wireType)
			}
			m.Passthrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passthrough |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventKeyT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: key_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: key_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ValFloat = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValLong", wireType)
			}
			m.ValLong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValLong |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValShort", wireType)
			}
			m.ValShort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValShort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValByte", wireType)
			}
			m.ValByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValByte |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValBool = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValUint64", wireType)
			}
			m.ValUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValUint64 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValWstring", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValWstring = append(m.ValWstring[:0], dAtA[iNdEx:postIndex]...)
			if m.ValWstring == nil {
				m.ValWstring = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GameEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GameEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, &CSVCMsg_GameEventListDescriptorT{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventListKeyT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: key_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: key_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventListDescriptorT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: descriptor_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: descriptor_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eventid", wireType)
			}
			m.Eventid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Eventid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CSVCMsg_GameEventListKeyT{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_TempEntities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_TempEntities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_TempEntities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityData = append(m.EntityData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntityData == nil {
				m.EntityData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_PacketEntities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_PacketEntities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_PacketEntities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntries", wireType)
			}
			m.MaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedEntries", wireType)
			}
			m.UpdatedEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedEntries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelta", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDelta = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBaseline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBaseline = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseline", wireType)
			}
			m.Baseline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseline |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFrom", wireType)
			}
			m.DeltaFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeltaFrom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityData = append(m.EntityData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntityData == nil {
				m.EntityData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Sounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Sounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Sounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliableSound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReliableSound = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sounds = append(m.Sounds, &CSVCMsg_SoundsSounddataT{})
			if err := m.Sounds[len(m.Sounds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SoundsSounddataT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sounddata_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sounddata_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginX = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginY = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginZ", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginZ = v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DelayValue = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pitch", wireType)
			}
			m.Pitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pitch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundNum", wireType)
			}
			m.SoundNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundNumHandle", wireType)
			}
			m.SoundNumHandle = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.SoundNumHandle = uint32(dAtA[iNdEx-4])
			m.SoundNumHandle |= uint32(dAtA[iNdEx-3]) << 8
			m.SoundNumHandle |= uint32(dAtA[iNdEx-2]) << 16
			m.SoundNumHandle |= uint32(dAtA[iNdEx-1]) << 24
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeakerEntity", wireType)
			}
			m.SpeakerEntity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeakerEntity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			m.RandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomSeed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundLevel", wireType)
			}
			m.SoundLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSentence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSentence = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAmbient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAmbient = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_EntityMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_EntityMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_EntityMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntData = append(m.EntData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntData == nil {
				m.EntData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CmdKeyValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CmdKeyValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CmdKeyValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyvalues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyvalues = append(m.Keyvalues[:0], dAtA[iNdEx:postIndex]...)
			if m.Keyvalues == nil {
				m.Keyvalues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_EncryptedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_EncryptedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_EncryptedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypted", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encrypted = append(m.Encrypted[:0], dAtA[iNdEx:postIndex]...)
			if m.Encrypted == nil {
				m.Encrypted = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_HltvReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_HltvReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_HltvReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryTarget", wireType)
			}
			m.PrimaryTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryTarget |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayStopAt", wireType)
			}
			m.ReplayStopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayStopAt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayStartAt", wireType)
			}
			m.ReplayStartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayStartAt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownBegin", wireType)
			}
			m.ReplaySlowdownBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaySlowdownBegin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownEnd", wireType)
			}
			m.ReplaySlowdownEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaySlowdownEnd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ReplaySlowdownRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_HltvReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_HltvReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_HltvReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowdownLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.SlowdownLength = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowdownRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.SlowdownRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryTargetEntIndex", wireType)
			}
			m.PrimaryTargetEntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryTargetEntIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EventTime = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Broadcast_Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Broadcast_Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Broadcast_Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetmessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNetmessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNetmessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNetmessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetmessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("netmessages.proto", fileDescriptorNetmessages) }

var fileDescriptorNetmessages = []byte{
	// 4344 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x7a, 0xcf, 0x6f, 0x24, 0x49,
	0x56, 0x7f, 0x57, 0xf9, 0x47, 0x95, 0xa3, 0xca, 0x76, 0x3a, 0xdc, 0x3f, 0x6a, 0x3c, 0xd3, 0xee,
	0xee, 0xec, 0xef, 0xcc, 0xf4, 0xf4, 0x77, 0xc6, 0x1a, 0x75, 0xcf, 0x0c, 0x4b, 0x8f, 0xf6, 0x60,
	0x97, 0xcb, 0xdd, 0xd6, 0xda, 0x6e, 0x6f, 0x55, 0xb5, 0x87, 0x19, 0x21, 0x85, 0xc2, 0x99, 0xe1,
	0x72, 0xca, 0xf9, 0xa3, 0x36, 0x23, 0xaa, 0xec, 0x6a, 0x09, 0xc1, 0x09, 0x6e, 0x88, 0x03, 0x08,
	0x21, 0x21, 0x01, 0x27, 0x24, 0xc4, 0x19, 0x84, 0x90, 0x38, 0xef, 0x91, 0xbf, 0x60, 0x59, 0xcd,
	0x9e, 0x90, 0x38, 0x21, 0x10, 0xdc, 0x40, 0xef, 0x45, 0x46, 0x66, 0x64, 0x95, 0x3d, 0x3b, 0x0b,
	0x5c, 0x2c, 0xd7, 0xe7, 0x7d, 0x22, 0x32, 0xe2, 0xc5, 0x8b, 0xf7, 0x2b, 0x93, 0xac, 0xc5, 0x42,
	0x45, 0x42, 0x4a, 0x3e, 0x10, 0x72, 0x6b, 0x98, 0x26, 0x2a, 0x71, 0x5f, 0x11, 0xd2, 0x3e, 0x94,
	0x83, 0x13, 0xe1, 0xa9, 0x24, 0xa5, 0x94, 0x54, 0xae, 0x5a, 0x95, 0x87, 0x95, 0x27, 0xd5, 0x9d,
	0xf9, 0x9f, 0xfe, 0xec, 0xc1, 0xad, 0x6e, 0xe5, 0x0a, 0xb0, 0x49, 0xab, 0x6a, 0x63, 0x13, 0xc0,
	0xde, 0xb6, 0xe6, 0x6c, 0xec, 0xad, 0xfb, 0x05, 0x69, 0x16, 0x33, 0x3d, 0xdb, 0xfd, 0xbe, 0x73,
	0x99, 0x15, 0xfc, 0x78, 0x3b, 0x1e, 0x84, 0xe2, 0x7f, 0xb5, 0x82, 0x6f, 0x48, 0x1d, 0x66, 0xea,
	0xbe, 0xdc, 0xd9, 0x06, 0x79, 0x8a, 0xf3, 0x2c, 0x18, 0x39, 0xee, 0x6e, 0x80, 0xf3, 0xe4, 0xd8,
	0x00, 0xb0, 0x53, 0x9c, 0x27, 0xc7, 0x4e, 0x01, 0xe3, 0xad, 0x79, 0x1b, 0xe3, 0xee, 0xdf, 0x56,
	0x49, 0xb3, 0x7d, 0xd4, 0xe9, 0x1f, 0xca, 0x01, 0xeb, 0x07, 0xde, 0x05, 0x6d, 0x91, 0x79, 0x15,
	0x78, 0x17, 0xf8, 0x8c, 0xe5, 0x8c, 0x87, 0x08, 0xfd, 0x35, 0x72, 0xfb, 0x3c, 0x91, 0x8a, 0x79,
	0x49, 0x34, 0x1c, 0x29, 0xae, 0x82, 0x24, 0x56, 0x41, 0x24, 0x70, 0x46, 0xc3, 0x5c, 0x07, 0x46,
	0xbb, 0x4c, 0xa0, 0x3f, 0x26, 0xee, 0x75, 0x03, 0x99, 0x54, 0x3e, 0xf3, 0xc5, 0x38, 0x40, 0xa4,
	0xb5, 0x60, 0x4d, 0xf3, 0xe0, 0x9a, 0x69, 0x7a, 0xca, 0xdf, 0x35, 0x64, 0xfa, 0x9a, 0x3c, 0xc2,
	0x29, 0xcf, 0x52, 0x1e, 0x09, 0xa9, 0x78, 0xaa, 0xae, 0x99, 0x71, 0xd1, 0x9a, 0x71, 0x13, 0xe8,
	0x7b, 0x25, 0x76, 0x69, 0xc2, 0x4f, 0xc9, 0xda, 0x79, 0xa8, 0xc6, 0x2c, 0x15, 0xc3, 0x90, 0x4f,
	0xd8, 0x59, 0xc8, 0x07, 0xb2, 0x55, 0xb3, 0x26, 0x58, 0x05, 0x71, 0x17, 0xa5, 0x7b, 0x20, 0x74,
	0x9f, 0x93, 0x35, 0xa3, 0xb8, 0x9e, 0x4a, 0x83, 0x78, 0xd0, 0x8e, 0x7c, 0xba, 0x49, 0x6a, 0x5e,
	0x12, 0x45, 0x3c, 0xf6, 0x51, 0x81, 0x4b, 0xd9, 0x60, 0x03, 0xba, 0xff, 0x5c, 0x21, 0xeb, 0xf9,
	0xa8, 0x60, 0x10, 0x27, 0x71, 0x4f, 0x71, 0x25, 0xe8, 0x87, 0xa4, 0x29, 0xf1, 0x27, 0x93, 0xf0,
	0xbb, 0xa4, 0xfd, 0x86, 0xb4, 0x88, 0xef, 0x93, 0x86, 0x1c, 0xf2, 0xcb, 0x98, 0x79, 0xc9, 0x28,
	0x56, 0x78, 0xea, 0x86, 0x47, 0x50, 0xd0, 0x06, 0x9c, 0x3e, 0x23, 0x34, 0x1e, 0x45, 0x4c, 0x8a,
	0x74, 0x2c, 0x52, 0x06, 0x8b, 0x16, 0xa9, 0x44, 0x7b, 0x30, 0x6c, 0x27, 0x1e, 0x45, 0x3d, 0x14,
	0x1f, 0x6b, 0x29, 0xfd, 0x84, 0xd0, 0x8c, 0xc8, 0x62, 0xa1, 0x2e, 0x93, 0xf4, 0x22, 0xf0, 0x65,
	0x6b, 0xfe, 0xe1, 0xdc, 0x93, 0xa5, 0xee, 0x5a, 0x26, 0x39, 0xca, 0x05, 0xf4, 0x01, 0xa9, 0x47,
	0x7c, 0xc8, 0x62, 0x1e, 0x09, 0x3c, 0xbb, 0x7c, 0xaf, 0x11, 0x1f, 0x1e, 0xf1, 0x48, 0xb8, 0x7f,
	0x51, 0xd1, 0x37, 0x80, 0xb5, 0x4f, 0x78, 0x2a, 0xe9, 0x07, 0x64, 0xc1, 0x1b, 0xf3, 0x54, 0xb6,
	0x2a, 0x0f, 0xe7, 0x9e, 0x34, 0x9e, 0x39, 0x5b, 0x85, 0x6c, 0x0b, 0xfe, 0x76, 0xb5, 0x78, 0xe3,
	0x82, 0xcc, 0xc3, 0x4f, 0x30, 0x44, 0x9c, 0xdb, 0xd6, 0x23, 0x22, 0x74, 0x83, 0x2c, 0x8c, 0x79,
	0x38, 0x12, 0xb8, 0x7b, 0x23, 0xd2, 0x10, 0xfd, 0x84, 0xac, 0xfa, 0x81, 0x07, 0x47, 0xca, 0xd3,
	0x89, 0x5e, 0x9c, 0xbd, 0xeb, 0x95, 0x42, 0x88, 0x6b, 0x7c, 0x61, 0x1d, 0xa2, 0x50, 0xed, 0x24,
	0x86, 0x27, 0xbf, 0x0f, 0x87, 0x18, 0x67, 0x6b, 0xad, 0x3c, 0x69, 0x3c, 0x6b, 0x58, 0x6b, 0xed,
	0x1a, 0x99, 0xbb, 0x4c, 0x1a, 0x66, 0xec, 0xd1, 0xeb, 0x63, 0x77, 0x8b, 0x50, 0xf3, 0x73, 0x37,
	0x90, 0x5e, 0x12, 0xc7, 0xc2, 0x53, 0x78, 0x9d, 0xc4, 0x95, 0x2a, 0xef, 0x02, 0x10, 0xf7, 0x2f,
	0x2b, 0xc5, 0xcd, 0xdb, 0x0b, 0x42, 0x3c, 0x5a, 0x95, 0xf2, 0x58, 0x9e, 0x89, 0x94, 0x05, 0x7e,
	0xe9, 0x92, 0x13, 0x23, 0xd8, 0xf7, 0xe9, 0x23, 0xb2, 0x74, 0x16, 0x84, 0x42, 0xef, 0xcd, 0xd6,
	0x40, 0x1d, 0x60, 0xd8, 0x15, 0x7d, 0x4e, 0xd6, 0x03, 0x69, 0x4c, 0xd9, 0x17, 0x51, 0xc2, 0x40,
	0x84, 0x8a, 0xa8, 0x9b, 0xe3, 0x0f, 0xa4, 0x36, 0xe6, 0x5d, 0x11, 0x25, 0xf8, 0xf8, 0x16, 0x99,
	0xf7, 0x45, 0x3c, 0xc1, 0xeb, 0x6c, 0x58, 0x88, 0xb8, 0xcf, 0xc9, 0xbd, 0x5c, 0x49, 0xc3, 0x30,
	0x50, 0x3d, 0x2f, 0x15, 0x22, 0x7e, 0x23, 0x05, 0x1e, 0x92, 0x0c, 0x13, 0x55, 0x5a, 0x2c, 0x22,
	0xee, 0x09, 0x69, 0x99, 0x41, 0xda, 0xc0, 0xb6, 0xc7, 0x5c, 0xf1, 0x74, 0x97, 0x2b, 0x4e, 0x5d,
	0xb2, 0xc4, 0x3d, 0x34, 0xe0, 0x6c, 0x9f, 0xe6, 0x78, 0x0a, 0x98, 0xde, 0x25, 0x73, 0xe9, 0xe0,
	0x14, 0x37, 0xd8, 0xcc, 0xa4, 0x00, 0xb8, 0x7f, 0x5a, 0x25, 0xb4, 0xdd, 0x3e, 0xd0, 0x07, 0x12,
	0x06, 0x22, 0x56, 0xfb, 0xf1, 0x59, 0x42, 0x9f, 0x92, 0x15, 0x29, 0x62, 0x9f, 0x29, 0x7e, 0x1a,
	0x0a, 0xe6, 0xa5, 0x1e, 0xce, 0x5b, 0xcb, 0x46, 0x36, 0x41, 0xd6, 0x07, 0x51, 0x3b, 0xf5, 0xf0,
	0xb2, 0xe9, 0x8b, 0x31, 0x7b, 0x89, 0x1a, 0x5a, 0xa2, 0x6f, 0xd1, 0x7d, 0x52, 0x0b, 0x24, 0x83,
	0x8b, 0x5f, 0xd2, 0xdd, 0x62, 0x20, 0x5f, 0x85, 0x6a, 0x0c, 0x27, 0x91, 0xab, 0xb9, 0xa4, 0xb6,
	0xba, 0x51, 0x2e, 0x7d, 0x4c, 0xc8, 0x59, 0x1a, 0x88, 0xd8, 0x97, 0x70, 0xa4, 0xb6, 0x8b, 0x5b,
	0xca, 0xf0, 0x7d, 0x1f, 0xd6, 0x63, 0x48, 0x78, 0xa8, 0x8b, 0xd6, 0xa1, 0x36, 0x32, 0x09, 0x9e,
	0xeb, 0x23, 0xd2, 0xf4, 0x46, 0x52, 0x25, 0x11, 0x9e, 0x27, 0xf8, 0xa7, 0xb9, 0x27, 0xb5, 0x6e,
	0x43, 0x63, 0x70, 0x88, 0xd2, 0xfd, 0x7d, 0xb0, 0xaa, 0x4c, 0x3d, 0x87, 0xc9, 0x58, 0xd0, 0xcf,
	0xc8, 0x3a, 0x78, 0x82, 0x53, 0xee, 0x5d, 0x8c, 0x86, 0x2c, 0xf3, 0x43, 0xb2, 0xa4, 0xf5, 0xb5,
	0x78, 0x14, 0xed, 0xa0, 0xbc, 0x9d, 0x89, 0xe9, 0x16, 0x01, 0xff, 0xc0, 0x62, 0x71, 0x59, 0x0c,
	0xb1, 0xd5, 0xb4, 0x12, 0x8f, 0xa2, 0x23, 0x71, 0x99, 0xf3, 0xc1, 0x78, 0xb8, 0xe2, 0xa8, 0xa6,
	0x66, 0x6e, 0x3c, 0x5c, 0x71, 0xf7, 0xaf, 0xaa, 0x64, 0xcd, 0x2c, 0xe8, 0x24, 0x09, 0x3c, 0x81,
	0x16, 0x60, 0xf8, 0x95, 0x69, 0x3e, 0x48, 0xae, 0x46, 0x81, 0x8f, 0x4f, 0x5b, 0x34, 0x12, 0x40,
	0x68, 0x9b, 0x2c, 0x9e, 0x25, 0x69, 0xc4, 0x15, 0x3e, 0x65, 0xe5, 0x19, 0xdd, 0xca, 0xe7, 0xdb,
	0x43, 0x9c, 0xa9, 0x17, 0xf7, 0x4e, 0x5e, 0xef, 0xb7, 0x3b, 0xbb, 0xdb, 0xfd, 0x6d, 0xb6, 0xf7,
	0xba, 0x7b, 0xb8, 0xdd, 0x67, 0x9d, 0xa3, 0x97, 0xfb, 0x47, 0x9d, 0x6e, 0x36, 0x94, 0xfe, 0x7f,
	0xb0, 0x93, 0x9f, 0x8c, 0x44, 0xec, 0x09, 0x76, 0x3a, 0x51, 0x42, 0x96, 0x02, 0xe2, 0xb2, 0x91,
	0xed, 0x80, 0x48, 0x93, 0xd1, 0x5f, 0xb0, 0x78, 0x14, 0x9d, 0x8a, 0xb4, 0x74, 0x82, 0xcb, 0x99,
	0xec, 0x08, 0x45, 0x74, 0x87, 0x6c, 0x8c, 0x62, 0x08, 0x71, 0xa9, 0x90, 0x52, 0xf8, 0x4c, 0xf2,
	0x68, 0x18, 0x0a, 0x96, 0x9c, 0x9d, 0x49, 0xa1, 0x4a, 0xb1, 0xa8, 0x65, 0xf3, 0x7a, 0x48, 0x7b,
	0x8d, 0x2c, 0x77, 0x40, 0xd6, 0x8d, 0xae, 0x76, 0xb8, 0x14, 0x61, 0x10, 0x8b, 0x6d, 0xef, 0x82,
	0x7e, 0x44, 0x96, 0x4f, 0xb3, 0x9f, 0x2c, 0x0f, 0xce, 0x66, 0xcd, 0x4d, 0x23, 0xc2, 0xf0, 0xfd,
	0x3e, 0x69, 0xe4, 0xd4, 0x38, 0x2d, 0x65, 0x05, 0xc4, 0x08, 0x8e, 0x52, 0xf7, 0x73, 0x72, 0xdb,
	0x3c, 0xe8, 0x20, 0x90, 0x4a, 0xc4, 0x9d, 0xb1, 0x88, 0x95, 0xa4, 0xf7, 0x09, 0x11, 0xf0, 0x1f,
	0x8b, 0xb8, 0xbc, 0x40, 0x4f, 0x5d, 0xeb, 0x2e, 0x21, 0x72, 0xc8, 0xe5, 0x85, 0xfb, 0x47, 0x15,
	0xd2, 0x32, 0xe3, 0xba, 0x42, 0x0e, 0x93, 0xd8, 0x6f, 0x8f, 0x79, 0x7a, 0x82, 0xae, 0xf7, 0x3d,
	0xb2, 0xe8, 0x25, 0xc9, 0x45, 0x20, 0x4a, 0xcb, 0xcb, 0x30, 0x0c, 0x5c, 0x8a, 0xab, 0x91, 0x64,
	0x5e, 0xe2, 0x8b, 0xf2, 0xc2, 0xb4, 0xa0, 0x9d, 0xf8, 0x22, 0xf7, 0xfa, 0x73, 0x37, 0x7b, 0xfd,
	0xf9, 0x19, 0xaf, 0xef, 0xfe, 0xf9, 0x5c, 0xb1, 0x1f, 0xb8, 0x07, 0xed, 0x6e, 0xbb, 0x7d, 0x2e,
	0xbc, 0x0b, 0xb8, 0xa2, 0xf0, 0x38, 0x36, 0xe4, 0xea, 0xbc, 0xb4, 0xac, 0x3a, 0xc0, 0xc7, 0x5c,
	0x9d, 0xc3, 0x13, 0x51, 0x6a, 0xbb, 0x52, 0x44, 0x40, 0xed, 0x38, 0x18, 0x2e, 0x5b, 0xbe, 0xa8,
	0x5c, 0xed, 0x20, 0xda, 0xcb, 0x24, 0xf4, 0x21, 0xa9, 0xe7, 0xac, 0xf9, 0x69, 0x9f, 0x8c, 0x8c,
	0x8f, 0xc8, 0x32, 0xba, 0xed, 0xb3, 0x94, 0x7b, 0x79, 0xbe, 0x93, 0x4f, 0x06, 0xa2, 0xbd, 0x4c,
	0x02, 0xae, 0x2f, 0xf2, 0x3f, 0x47, 0x93, 0xc9, 0x5d, 0x5f, 0xe4, 0x7f, 0x0e, 0x38, 0x38, 0x36,
	0x3b, 0x2b, 0x01, 0x00, 0x7c, 0x1f, 0x4e, 0x7d, 0xce, 0xe5, 0x39, 0x53, 0x93, 0xa1, 0x68, 0xd5,
	0xa7, 0xe7, 0x7e, 0xc5, 0xe5, 0x79, 0x7f, 0x32, 0x14, 0x10, 0xb5, 0x91, 0x1b, 0x8a, 0xb8, 0xb5,
	0x64, 0xb1, 0x6a, 0x80, 0x1e, 0x88, 0x98, 0x7e, 0x40, 0x9a, 0x43, 0xee, 0x5d, 0xe0, 0xa6, 0xc1,
	0x67, 0x11, 0xfb, 0xa0, 0x40, 0x02, 0x7b, 0xde, 0xf7, 0xc1, 0x43, 0x14, 0xbc, 0xec, 0x76, 0x34,
	0x2c, 0xee, 0x8a, 0xe1, 0xea, 0xeb, 0xe1, 0x7e, 0x49, 0xee, 0xe5, 0x16, 0x97, 0x70, 0x3f, 0x88,
	0x07, 0xc7, 0x69, 0x32, 0x80, 0x3b, 0x00, 0xca, 0x1b, 0x66, 0xff, 0x97, 0xcf, 0xc8, 0xa0, 0x6e,
	0x9b, 0x6c, 0x98, 0xc1, 0x18, 0x81, 0x74, 0x44, 0x69, 0x67, 0x31, 0xf6, 0x7b, 0xc6, 0xeb, 0x17,
	0x85, 0x8d, 0xb4, 0x23, 0xff, 0x47, 0x62, 0x82, 0x66, 0x2b, 0x21, 0x1a, 0x5d, 0x88, 0x09, 0x1a,
	0x92, 0x2c, 0x39, 0xa4, 0x02, 0x76, 0xff, 0x63, 0x91, 0xd0, 0x76, 0xef, 0x44, 0xaf, 0x00, 0x23,
	0x04, 0x46, 0x1d, 0xbd, 0x72, 0x95, 0x78, 0x49, 0x38, 0xb3, 0x72, 0x44, 0xaf, 0x8d, 0x35, 0x0b,
	0xd7, 0xc5, 0x9a, 0x0f, 0x49, 0x33, 0x90, 0xcc, 0x17, 0x7e, 0xe0, 0x71, 0x25, 0xfc, 0x52, 0xc0,
	0x69, 0x04, 0x72, 0xd7, 0x08, 0xe8, 0x0f, 0x49, 0x2b, 0x90, 0xe0, 0x56, 0x02, 0x2f, 0xe0, 0x21,
	0x1b, 0xf3, 0x70, 0x2c, 0xb2, 0x44, 0xaf, 0x14, 0x84, 0xee, 0x04, 0xf2, 0x75, 0x46, 0x3a, 0x01,
	0x8e, 0x5e, 0xb6, 0x1d, 0xd3, 0x16, 0x7e, 0x59, 0x4c, 0x5b, 0xbc, 0x36, 0xa6, 0xdd, 0x23, 0xf3,
	0x1e, 0x4b, 0x74, 0x76, 0xbc, 0x90, 0xdb, 0xe1, 0x6b, 0x70, 0x1e, 0x90, 0xfb, 0x61, 0xf0, 0xad,
	0x5b, 0xc1, 0x77, 0x31, 0xe2, 0x43, 0x08, 0xbb, 0x8f, 0x09, 0xf1, 0x30, 0x60, 0x23, 0x63, 0xc9,
	0x62, 0x2c, 0x69, 0x1c, 0x48, 0x5b, 0xc4, 0x91, 0x98, 0x4d, 0x5b, 0x91, 0x9c, 0x58, 0xd4, 0x15,
	0x2d, 0xcd, 0x63, 0xf9, 0xfb, 0xa4, 0x11, 0xf1, 0x2b, 0xa6, 0x27, 0x90, 0x25, 0x0b, 0x24, 0x11,
	0xbf, 0xd2, 0x19, 0x82, 0x2c, 0x68, 0x5c, 0x4a, 0x21, 0x5b, 0xcd, 0x19, 0x1a, 0xe2, 0x40, 0xd3,
	0x89, 0x2e, 0xc3, 0xac, 0x66, 0xb9, 0x64, 0xfb, 0x28, 0xe8, 0x85, 0x89, 0x82, 0xbb, 0x0c, 0x6e,
	0x98, 0x05, 0xb1, 0x12, 0xe9, 0x98, 0x87, 0xad, 0x15, 0xab, 0x60, 0x6b, 0x82, 0x68, 0x3f, 0x93,
	0xc0, 0x7d, 0x1b, 0xf0, 0x48, 0x30, 0x3f, 0x48, 0x5b, 0xab, 0x76, 0x96, 0x0c, 0xe8, 0x6e, 0x90,
	0x96, 0xd2, 0x68, 0xe7, 0x9a, 0x34, 0x1a, 0x6e, 0x37, 0x10, 0x06, 0x69, 0x32, 0xca, 0x68, 0x6b,
	0x16, 0xad, 0x19, 0xf1, 0xe1, 0x4b, 0x10, 0x21, 0xf7, 0x01, 0xa9, 0xcb, 0x8b, 0x2c, 0xed, 0xa5,
	0xf6, 0x64, 0xf2, 0x62, 0x92, 0x65, 0x10, 0x4b, 0x58, 0x37, 0x21, 0x63, 0xdd, 0x76, 0x54, 0x00,
	0x1b, 0xca, 0x70, 0x74, 0x1a, 0x06, 0x1e, 0x0b, 0x86, 0xad, 0xdb, 0x96, 0xaf, 0xa9, 0x6b, 0x78,
	0x7f, 0x48, 0xf7, 0xc8, 0x7d, 0x34, 0x12, 0x3f, 0x48, 0x21, 0x04, 0xc2, 0x61, 0x25, 0x6c, 0x98,
	0x26, 0x57, 0x13, 0x96, 0x0a, 0x30, 0x9c, 0x3b, 0x96, 0xe1, 0xbc, 0x03, 0x86, 0x93, 0x33, 0xfb,
	0xc9, 0x31, 0xf0, 0xba, 0x40, 0xa3, 0x2e, 0x21, 0xa3, 0x81, 0xc7, 0x60, 0x7b, 0x81, 0xdf, 0xba,
	0xfb, 0xb0, 0xf2, 0x64, 0xde, 0x3c, 0x6b, 0x34, 0xf0, 0x0e, 0xf9, 0x70, 0xdf, 0x77, 0xff, 0xb3,
	0x42, 0xd6, 0xcc, 0xcd, 0xc3, 0x63, 0xc2, 0x8b, 0xb7, 0x45, 0x1c, 0x2f, 0x15, 0x5c, 0x09, 0x96,
	0xc4, 0xd9, 0xe1, 0xe3, 0x05, 0x34, 0x0f, 0x5d, 0xd1, 0xd2, 0xd7, 0xb1, 0x36, 0x00, 0xfa, 0x19,
	0xa9, 0x99, 0xb3, 0xaf, 0x62, 0xf9, 0xb1, 0xb1, 0x35, 0x33, 0xe9, 0x16, 0x32, 0x98, 0xea, 0x1a,
	0xea, 0xc6, 0x6f, 0x65, 0xa3, 0x98, 0x02, 0xcd, 0xea, 0x7f, 0xa7, 0x32, 0x73, 0x4d, 0xd8, 0xf7,
	0xe9, 0xc7, 0x64, 0x15, 0xf2, 0x97, 0xcc, 0x6c, 0x67, 0x92, 0xf3, 0x65, 0x10, 0xa2, 0xd5, 0xa2,
	0x92, 0xf1, 0x2e, 0xc0, 0x74, 0x33, 0xc1, 0x6e, 0x09, 0x71, 0x2c, 0x4e, 0xfe, 0x7d, 0xae, 0xd8,
	0x7a, 0xcf, 0x24, 0xb0, 0xf4, 0x5d, 0xb2, 0x18, 0x48, 0x26, 0xb2, 0x0a, 0xd3, 0x6c, 0x78, 0x21,
	0x90, 0x9d, 0xd8, 0x07, 0x63, 0x89, 0x85, 0xba, 0x69, 0x11, 0xcd, 0x58, 0xa8, 0x62, 0x0d, 0x1f,
	0x91, 0xe5, 0x58, 0x08, 0x1f, 0x9c, 0x0e, 0xc4, 0xb2, 0xb4, 0xe4, 0x72, 0x9a, 0x28, 0xda, 0xd5,
	0x12, 0xfa, 0x9c, 0x2c, 0x0c, 0xd3, 0x64, 0xa8, 0xab, 0xc1, 0xc6, 0xb3, 0xfb, 0x5b, 0x33, 0xcb,
	0xda, 0x82, 0x0c, 0x1b, 0x38, 0x4c, 0x75, 0x35, 0x77, 0xe3, 0x6f, 0xaa, 0x84, 0x14, 0x28, 0x56,
	0x42, 0x10, 0x9b, 0x4a, 0xa5, 0x82, 0xca, 0x62, 0xd2, 0x98, 0xa7, 0xb3, 0xcb, 0xad, 0x8d, 0x79,
	0x7a, 0x94, 0x85, 0x7e, 0x5d, 0x90, 0xdb, 0x01, 0x58, 0x43, 0xda, 0x05, 0x07, 0x49, 0x1a, 0xa8,
	0x49, 0x29, 0x95, 0xcb, 0x51, 0x70, 0x4b, 0xbe, 0x9a, 0xad, 0x53, 0x17, 0x7d, 0x6d, 0xef, 0x1f,
	0x92, 0x26, 0xa4, 0xba, 0x22, 0x14, 0x11, 0xba, 0x90, 0x45, 0xdb, 0x43, 0xc7, 0xa3, 0xa8, 0x93,
	0x09, 0xe0, 0x62, 0x84, 0xc9, 0x25, 0xd3, 0x49, 0x48, 0xcd, 0xba, 0xf1, 0xf5, 0x30, 0xb9, 0xd4,
	0x29, 0xd0, 0x63, 0x42, 0xce, 0x83, 0xc1, 0x79, 0xc6, 0xa9, 0x5b, 0x9c, 0x25, 0xc0, 0x35, 0xe9,
	0x01, 0xa9, 0x63, 0x46, 0x1e, 0x28, 0x59, 0x0e, 0xc1, 0x90, 0x86, 0x07, 0x4a, 0xba, 0x1f, 0x91,
	0x65, 0xa3, 0xdf, 0xe3, 0x34, 0x88, 0xbf, 0xab, 0x88, 0xfc, 0x94, 0x38, 0xc5, 0x51, 0xa8, 0x63,
	0x3e, 0x92, 0x98, 0x87, 0x0d, 0xe1, 0x9f, 0xb2, 0x81, 0x64, 0x98, 0xfb, 0x82, 0xac, 0x5a, 0x23,
	0x4e, 0x02, 0x71, 0x09, 0x1a, 0x10, 0xb1, 0x0a, 0xd4, 0x84, 0x05, 0xb1, 0x2f, 0xae, 0x4a, 0x27,
	0xd4, 0xd0, 0x92, 0x7d, 0x10, 0xb8, 0x3f, 0xab, 0x92, 0x77, 0xf2, 0x6b, 0x83, 0x17, 0xac, 0x57,
	0x78, 0xe3, 0xef, 0x28, 0xd8, 0x33, 0xef, 0x2b, 0x62, 0x95, 0x06, 0x42, 0x96, 0x73, 0xbf, 0x88,
	0x5f, 0x75, 0x34, 0x0e, 0x34, 0x3c, 0x89, 0x8c, 0x66, 0x1f, 0x36, 0x81, 0x83, 0xc8, 0x68, 0x9f,
	0x93, 0xdb, 0x23, 0x29, 0x52, 0x86, 0xd7, 0xed, 0x2c, 0xb8, 0x82, 0x5c, 0x3b, 0x78, 0x2b, 0x4a,
	0xc1, 0x6f, 0x0d, 0x18, 0x58, 0x19, 0x80, 0xbc, 0x17, 0xbc, 0x45, 0x3f, 0x5a, 0x0c, 0xc3, 0x01,
	0xa5, 0x0c, 0xcc, 0x0c, 0x40, 0xee, 0x73, 0xb2, 0x5e, 0xe6, 0xea, 0xd3, 0xb2, 0x4d, 0xc3, 0xb1,
	0x07, 0xc0, 0xb1, 0x15, 0x56, 0x5a, 0x9b, 0xb5, 0x52, 0xcc, 0x7e, 0x31, 0xac, 0x61, 0xd9, 0x53,
	0xb7, 0xb2, 0x0c, 0xa2, 0x05, 0x30, 0x95, 0xfb, 0x27, 0x95, 0x42, 0xc1, 0x6f, 0x86, 0xfe, 0x94,
	0x82, 0x1f, 0x90, 0xba, 0xbe, 0xd8, 0xd3, 0x3e, 0x08, 0xd1, 0x7d, 0xdf, 0xd4, 0x7a, 0xde, 0x39,
	0x8f, 0x07, 0xc2, 0xbf, 0x56, 0xdf, 0x50, 0xeb, 0xb5, 0xb5, 0xdc, 0x52, 0xbb, 0xbd, 0xb6, 0xb9,
	0x1b, 0xd6, 0x16, 0x16, 0xce, 0x08, 0xeb, 0xae, 0xfd, 0x38, 0x50, 0x74, 0x93, 0xd4, 0x7e, 0x32,
	0xe2, 0x21, 0x5c, 0xbe, 0xd2, 0x8a, 0x32, 0x10, 0x74, 0x02, 0x1e, 0xc4, 0x2b, 0xb7, 0x6a, 0x10,
	0xa2, 0xef, 0x92, 0xda, 0x58, 0xa4, 0x12, 0x72, 0x61, 0x3c, 0xea, 0x17, 0x95, 0x4f, 0xbb, 0x06,
	0x71, 0xff, 0x61, 0x6e, 0xea, 0x71, 0x58, 0x36, 0x42, 0x89, 0x51, 0x38, 0xfb, 0xa2, 0xc4, 0xd0,
	0x4e, 0xde, 0x25, 0x4b, 0x10, 0x84, 0x82, 0x08, 0x96, 0x53, 0xb5, 0xac, 0xa1, 0x80, 0xf3, 0xf2,
	0x72, 0x6e, 0xa6, 0xbc, 0xfc, 0x90, 0x34, 0xf9, 0xc8, 0x0f, 0x40, 0xbf, 0x58, 0xfc, 0xd8, 0xce,
	0xa4, 0x91, 0x49, 0xa0, 0x08, 0x82, 0x4b, 0x3e, 0x86, 0x15, 0x69, 0x75, 0x2d, 0xd8, 0x09, 0xe3,
	0xb8, 0xb4, 0x52, 0x2e, 0x95, 0x48, 0x4b, 0x49, 0x54, 0x86, 0x59, 0xa5, 0x6c, 0xed, 0xff, 0xb2,
	0x94, 0xad, 0xff, 0x2a, 0xa5, 0xec, 0xd2, 0xff, 0xb4, 0x94, 0x25, 0xdf, 0xab, 0x94, 0xfd, 0xaa,
	0xf0, 0x4c, 0x7b, 0xc1, 0x95, 0x6e, 0x82, 0x3f, 0x24, 0x75, 0xc8, 0x0f, 0x54, 0x30, 0x16, 0x25,
	0xdf, 0x94, 0xa3, 0xf4, 0x11, 0x59, 0xe0, 0x40, 0xc5, 0xe3, 0x33, 0x89, 0xbc, 0x6e, 0xa1, 0x77,
	0xb5, 0xc4, 0xfd, 0x92, 0xdc, 0x2d, 0x7c, 0x50, 0x22, 0xe5, 0x39, 0x0f, 0x52, 0x3d, 0x7d, 0x3e,
	0xb8, 0x72, 0xe3, 0xe0, 0x5f, 0x2f, 0x56, 0x75, 0x9c, 0x8a, 0x33, 0xa1, 0xbc, 0x73, 0xb4, 0xff,
	0x64, 0x14, 0xfb, 0xd7, 0x78, 0x3f, 0x82, 0x02, 0xed, 0xfc, 0x7e, 0x5e, 0x29, 0xc6, 0xee, 0xf4,
	0x8e, 0x77, 0x85, 0xc7, 0x43, 0x7a, 0x9f, 0xcc, 0x0d, 0x93, 0x72, 0xd9, 0xa1, 0x5f, 0x14, 0x74,
	0x01, 0x87, 0x0b, 0xe9, 0x03, 0x8f, 0x81, 0xb3, 0x1e, 0xa5, 0x22, 0x7b, 0x44, 0xe9, 0x42, 0x22,
	0xa1, 0xaf, 0xe5, 0xf8, 0xa4, 0x19, 0x7f, 0x3c, 0x77, 0x83, 0x3f, 0x46, 0xbf, 0x9a, 0xf8, 0x22,
	0xcc, 0x78, 0xf3, 0x25, 0xbf, 0x0a, 0x82, 0x7c, 0x3e, 0x08, 0x5c, 0x79, 0x98, 0xb4, 0xf3, 0xfe,
	0x46, 0x98, 0x5c, 0x1e, 0x67, 0x02, 0xf7, 0xcf, 0x2a, 0x64, 0x3d, 0x0f, 0x0e, 0x45, 0xa7, 0x8f,
	0x76, 0xac, 0xd0, 0xbd, 0xf2, 0xac, 0xb5, 0xd5, 0xb1, 0x84, 0x87, 0xfa, 0xbd, 0x0b, 0x14, 0x97,
	0x2f, 0xee, 0x1d, 0xf6, 0x5e, 0xb2, 0xde, 0xf1, 0xc1, 0x7e, 0xbf, 0xd7, 0xee, 0x76, 0x3a, 0x47,
	0x6c, 0x7b, 0x77, 0xf7, 0x4d, 0xaf, 0xd3, 0xcd, 0xe2, 0xbc, 0x69, 0x16, 0x56, 0xa7, 0x9b, 0x85,
	0xb0, 0xc2, 0x2c, 0xef, 0xbe, 0x66, 0xc7, 0x5a, 0xa2, 0x0f, 0xe1, 0x2b, 0x72, 0xdb, 0x2c, 0xf0,
	0xa5, 0x50, 0xdf, 0xb7, 0xf7, 0xf0, 0x88, 0x2c, 0x79, 0xd7, 0x66, 0x18, 0x75, 0x2f, 0x4b, 0x31,
	0x5c, 0x8f, 0x34, 0xcd, 0xc4, 0x87, 0x22, 0x1e, 0x81, 0x6a, 0xfd, 0x80, 0x87, 0xc9, 0x80, 0xcd,
	0x24, 0x2d, 0x44, 0x0b, 0xb0, 0x9c, 0xfe, 0x98, 0xac, 0x46, 0x22, 0x1e, 0xb1, 0x0b, 0x31, 0x61,
	0x59, 0x05, 0x69, 0x77, 0x2c, 0x97, 0x41, 0x98, 0x57, 0x9a, 0xee, 0x6f, 0x17, 0xea, 0x7d, 0x23,
	0x45, 0x9a, 0xa9, 0x0e, 0x4b, 0x00, 0x79, 0xcd, 0x83, 0x6a, 0x91, 0x1c, 0x98, 0xa2, 0x1d, 0x08,
	0xe8, 0x6f, 0xec, 0xe9, 0x81, 0x80, 0xde, 0xe6, 0x03, 0xd2, 0x18, 0x72, 0x29, 0xd5, 0x79, 0x9a,
	0x8c, 0x06, 0xe7, 0x53, 0xea, 0x2b, 0x04, 0xee, 0x0f, 0x0a, 0xf5, 0x1d, 0xf3, 0x20, 0x56, 0x11,
	0x1f, 0xe2, 0x78, 0x48, 0xa2, 0xb2, 0xdf, 0xa5, 0x0a, 0x38, 0x47, 0xdd, 0x7f, 0xb1, 0xfc, 0xf1,
	0x4b, 0x1e, 0x09, 0xec, 0x17, 0x81, 0x2b, 0xd4, 0xed, 0xa2, 0x99, 0xc0, 0xaf, 0x9b, 0x46, 0x98,
	0x60, 0x6d, 0x92, 0x1a, 0xfe, 0xc8, 0x9a, 0x7a, 0xf9, 0xee, 0x32, 0x90, 0x7e, 0x4c, 0xe6, 0x2f,
	0xc4, 0x04, 0xe2, 0x3d, 0xe4, 0x96, 0xad, 0xad, 0x99, 0xc7, 0x6c, 0x81, 0x76, 0x55, 0x17, 0x59,
	0xd3, 0x5b, 0x9d, 0xbf, 0x61, 0xab, 0x1b, 0x7f, 0x5f, 0x25, 0x0b, 0x38, 0xee, 0x3b, 0x12, 0x4f,
	0xf0, 0xe4, 0x3c, 0x64, 0x3a, 0xc8, 0x95, 0x0c, 0x63, 0x69, 0xcc, 0x43, 0x1d, 0x7a, 0xc1, 0x78,
	0x80, 0x74, 0x16, 0x26, 0x59, 0xe7, 0x31, 0x4f, 0xfb, 0xc6, 0x3c, 0xdc, 0x03, 0x54, 0x27, 0xb0,
	0x21, 0x0b, 0x93, 0x78, 0x50, 0x5a, 0x50, 0x6d, 0xcc, 0xc3, 0x83, 0xa4, 0x98, 0x43, 0x9e, 0x27,
	0xa9, 0x2a, 0xa5, 0x1d, 0x30, 0xae, 0x07, 0xa8, 0x99, 0x03, 0x1c, 0x79, 0x29, 0xcf, 0x80, 0x39,
	0xc0, 0x85, 0xe7, 0x84, 0x24, 0x09, 0x31, 0x6a, 0xd4, 0x6d, 0x42, 0x92, 0x84, 0x66, 0x37, 0xa3,
	0x20, 0x56, 0x5f, 0x7c, 0x86, 0xb1, 0x60, 0xde, 0xda, 0xcd, 0x1b, 0x84, 0xc1, 0xae, 0x81, 0x74,
	0x99, 0xed, 0x79, 0xc9, 0x0e, 0xf6, 0x63, 0x1e, 0x7e, 0xa5, 0x71, 0xf7, 0x8f, 0xab, 0xe4, 0xce,
	0xcc, 0x39, 0x1c, 0x04, 0x52, 0xd1, 0x0e, 0x69, 0xf8, 0x42, 0x7a, 0x69, 0x30, 0x54, 0x49, 0xfe,
	0x32, 0xe7, 0xf1, 0xd6, 0xb5, 0xe4, 0xad, 0x82, 0xc9, 0x54, 0xd7, 0x1e, 0xb7, 0xf1, 0xe5, 0x2f,
	0x3f, 0x1d, 0x93, 0x4f, 0x56, 0xa7, 0xf3, 0xc9, 0x8d, 0xb7, 0xa4, 0x69, 0xcf, 0x6c, 0x5b, 0x58,
	0xe5, 0x3a, 0x0b, 0xbb, 0x71, 0x26, 0xfa, 0x69, 0xc9, 0xf6, 0xde, 0xbb, 0x61, 0x1b, 0x96, 0xfd,
	0xb9, 0xbf, 0x5b, 0x29, 0xee, 0x50, 0x5f, 0x44, 0xc3, 0x0e, 0xf8, 0x63, 0x48, 0xa3, 0x74, 0x70,
	0x0b, 0x20, 0x15, 0x9b, 0x09, 0x6e, 0x88, 0x4e, 0xe7, 0xb7, 0xd5, 0x1b, 0xf2, 0xdb, 0xf7, 0x49,
	0xe6, 0xe4, 0xaf, 0xc9, 0xc7, 0xb4, 0x00, 0xf3, 0xb1, 0xbf, 0xae, 0x16, 0x81, 0xf0, 0x98, 0x7b,
	0x17, 0x42, 0xe5, 0x4b, 0x99, 0xca, 0xb7, 0x2b, 0x37, 0xe4, 0xdb, 0x9f, 0x90, 0xd5, 0x11, 0x26,
	0x99, 0xd7, 0xa7, 0x8a, 0x2b, 0x99, 0xd0, 0xd0, 0x1f, 0x90, 0x3a, 0x76, 0xa8, 0xc2, 0x6c, 0x51,
	0xb9, 0x01, 0x06, 0x72, 0x17, 0xc0, 0x62, 0x3e, 0x66, 0x3a, 0xcd, 0xa5, 0x9c, 0x3c, 0x9b, 0xcf,
	0x34, 0xb6, 0x41, 0x61, 0x39, 0xaf, 0x74, 0x27, 0x0c, 0x0a, 0x16, 0x8d, 0x8f, 0x63, 0x67, 0x69,
	0x12, 0x95, 0x6e, 0xc5, 0x12, 0xe2, 0x7b, 0x69, 0x12, 0x4d, 0xab, 0xab, 0x76, 0x83, 0xba, 0xfe,
	0x6d, 0x81, 0xac, 0xe4, 0xb1, 0x0d, 0xa2, 0x3a, 0xe6, 0x44, 0xe6, 0x6c, 0x18, 0x06, 0xfa, 0xd2,
	0xb9, 0x2d, 0x1b, 0x19, 0xb2, 0xe9, 0x73, 0xb2, 0x88, 0x1c, 0xd3, 0x40, 0x78, 0x77, 0xab, 0x3c,
	0xdb, 0x16, 0x4a, 0x75, 0x0b, 0xa0, 0x9b, 0x51, 0x37, 0xfe, 0x6b, 0x3e, 0xcb, 0x2d, 0x34, 0x0e,
	0x2a, 0x4c, 0xd2, 0x60, 0x10, 0xc4, 0x4c, 0xe7, 0x19, 0x6b, 0x46, 0x85, 0x1a, 0xfd, 0x0d, 0x8b,
	0xa0, 0x33, 0xd8, 0x29, 0xc2, 0xd7, 0x16, 0x41, 0x7f, 0x26, 0x30, 0x45, 0xf8, 0x06, 0x22, 0xe1,
	0x38, 0x09, 0x47, 0x53, 0xef, 0xe5, 0x33, 0x0c, 0xc3, 0x9a, 0x08, 0x79, 0x16, 0xac, 0x50, 0xed,
	0xd5, 0x3c, 0xac, 0x81, 0xe0, 0xc4, 0xbc, 0x45, 0xcd, 0x53, 0xcb, 0x2c, 0x5d, 0xb4, 0xb5, 0x9f,
	0xe7, 0x9d, 0x59, 0xbe, 0x38, 0x9d, 0xb0, 0xd4, 0x6e, 0x4a, 0x58, 0x36, 0x49, 0x0d, 0x8a, 0x93,
	0x58, 0x84, 0xa5, 0x5c, 0xd5, 0x80, 0x50, 0x2e, 0x0c, 0x03, 0xe5, 0x9d, 0x97, 0xea, 0x62, 0x0d,
	0x15, 0xe5, 0x15, 0x99, 0x2d, 0xaf, 0x1e, 0x91, 0x25, 0x9d, 0xc2, 0xc5, 0xa3, 0x08, 0x7b, 0x80,
	0x79, 0xcf, 0x0a, 0xe1, 0xa3, 0x51, 0x84, 0x8d, 0x45, 0x43, 0x61, 0xe7, 0x3c, 0xf6, 0x43, 0x81,
	0x6d, 0xc0, 0xa2, 0xb1, 0x98, 0x31, 0x5f, 0xa1, 0x0c, 0x13, 0xe6, 0xa1, 0xe0, 0x17, 0x22, 0x65,
	0x7a, 0x07, 0xa5, 0x6e, 0xe0, 0x72, 0x26, 0xc3, 0x2b, 0x37, 0x01, 0xb5, 0xa6, 0x3c, 0xf6, 0x93,
	0x88, 0x49, 0x21, 0x7c, 0x6c, 0x07, 0xe6, 0x17, 0x4e, 0x0b, 0x7a, 0x42, 0xf8, 0x45, 0xa6, 0x19,
	0x8a, 0xb1, 0x08, 0xb1, 0x1f, 0x58, 0xce, 0x34, 0x0f, 0x00, 0x07, 0x5a, 0x20, 0x99, 0x14, 0xb1,
	0x02, 0x1d, 0x63, 0x57, 0xd0, 0x18, 0x25, 0x09, 0x64, 0x2f, 0xc3, 0xe1, 0x76, 0x04, 0x92, 0xf1,
	0xe8, 0x14, 0x0b, 0xa2, 0x35, 0xbb, 0xde, 0x09, 0xe4, 0xb6, 0x86, 0xdd, 0xab, 0x22, 0x6c, 0xeb,
	0xb5, 0x1e, 0x4a, 0x0c, 0x47, 0x10, 0xb4, 0x67, 0xf3, 0xdd, 0x3a, 0xbe, 0x4e, 0x85, 0x93, 0xb2,
	0xfb, 0x5d, 0xd5, 0xeb, 0xfa, 0x5d, 0x0f, 0x08, 0x90, 0x67, 0x5d, 0x54, 0x4d, 0xc4, 0x0a, 0x2f,
	0xdc, 0x8b, 0xc2, 0x4f, 0xfe, 0xca, 0xed, 0xf6, 0xdf, 0x2c, 0xa2, 0x4f, 0x27, 0xf6, 0xd2, 0xc9,
	0x50, 0x09, 0xdf, 0xbc, 0x39, 0x16, 0x06, 0x28, 0x0f, 0xce, 0x61, 0x58, 0x19, 0x3a, 0x6c, 0x88,
	0x2a, 0xa5, 0xa5, 0x5f, 0x88, 0x09, 0xa4, 0x53, 0xee, 0x3f, 0x55, 0x8b, 0x66, 0xfe, 0xab, 0xfc,
	0xab, 0x0e, 0x30, 0x30, 0xbc, 0x02, 0x25, 0x8d, 0x68, 0x08, 0xac, 0x61, 0x98, 0x06, 0x11, 0x4f,
	0x27, 0x4c, 0xf1, 0x74, 0x20, 0xca, 0x49, 0xec, 0x72, 0x26, 0xeb, 0xa3, 0x88, 0x3e, 0x05, 0xbf,
	0x82, 0xef, 0xde, 0xa5, 0x4a, 0x86, 0x2c, 0x4b, 0x1b, 0xf2, 0x4e, 0x83, 0x96, 0xf5, 0x54, 0x32,
	0xdc, 0x56, 0x90, 0x40, 0xe6, 0x5c, 0x9e, 0x2a, 0x20, 0x97, 0x5e, 0x48, 0x1a, 0x32, 0x4f, 0xd5,
	0xb6, 0xa2, 0x3f, 0x20, 0x77, 0x0c, 0x3b, 0x4c, 0x2e, 0xfd, 0xe4, 0x32, 0x66, 0xa7, 0x62, 0x10,
	0x94, 0x5f, 0x26, 0xad, 0x67, 0x63, 0x32, 0xc6, 0x0e, 0x10, 0xa0, 0x12, 0x99, 0x1e, 0x29, 0x62,
	0xbf, 0x74, 0xab, 0xd7, 0xca, 0xe3, 0x3a, 0xb1, 0x4f, 0xbf, 0x20, 0xb7, 0xa7, 0x47, 0xa5, 0x5c,
	0x95, 0xbb, 0x5f, 0xb4, 0x3c, 0xac, 0xcb, 0x95, 0x70, 0xff, 0xb5, 0x52, 0xbc, 0xa4, 0xb7, 0x34,
	0xbc, 0x49, 0x6a, 0x29, 0x78, 0x0e, 0x59, 0xae, 0xdf, 0x0d, 0x88, 0x6e, 0xc7, 0x3c, 0x27, 0x14,
	0xf1, 0x20, 0x7b, 0x2b, 0x57, 0xcd, 0xaf, 0x68, 0x26, 0x3c, 0x40, 0x19, 0xfd, 0x88, 0x2c, 0x97,
	0x97, 0x65, 0x67, 0x67, 0x4d, 0x69, 0x2d, 0x88, 0xfe, 0x90, 0xb4, 0xca, 0xe7, 0xc7, 0x8a, 0x0b,
	0x60, 0xeb, 0xfb, 0x4e, 0xe9, 0x24, 0x3b, 0xe6, 0x36, 0xe4, 0x79, 0x2e, 0x7e, 0xf0, 0x64, 0x7b,
	0x4d, 0x9d, 0xe7, 0xf6, 0x83, 0x48, 0xb8, 0xcf, 0x8b, 0xde, 0xcd, 0x4e, 0x9a, 0x70, 0x1f, 0x6a,
	0x7d, 0x96, 0xbd, 0x21, 0xc7, 0x77, 0x77, 0x51, 0xf9, 0xa3, 0x20, 0x00, 0x9e, 0xfe, 0x5d, 0x85,
	0x34, 0x8f, 0x3a, 0x7d, 0x96, 0xd5, 0x02, 0x92, 0x36, 0x48, 0x2d, 0x16, 0x8a, 0x1d, 0xbd, 0x3e,
	0x76, 0x6e, 0x51, 0xaa, 0xdb, 0xb9, 0xc5, 0xf7, 0x24, 0x4e, 0x85, 0x36, 0x49, 0x1d, 0xb0, 0xbd,
	0x20, 0x14, 0x4e, 0x95, 0xde, 0x23, 0xeb, 0xf0, 0x6b, 0xea, 0xbb, 0x0c, 0x67, 0xce, 0xd0, 0xfa,
	0x81, 0x77, 0xe1, 0xcc, 0xd3, 0x35, 0xb2, 0x8c, 0x34, 0xf3, 0xa1, 0x92, 0xb3, 0x90, 0x43, 0xe6,
	0xb3, 0x17, 0x67, 0x91, 0xae, 0x93, 0x55, 0x84, 0x8a, 0xef, 0x8d, 0x9c, 0x1a, 0x6d, 0x91, 0xdb,
	0x00, 0x4e, 0x7f, 0xc4, 0xe1, 0xf8, 0x4f, 0xff, 0xb0, 0x4a, 0x9a, 0xed, 0x83, 0x76, 0xb1, 0x76,
	0x4a, 0x56, 0xbc, 0xd0, 0xb3, 0x3e, 0xcb, 0x70, 0xea, 0xb0, 0x0e, 0xc0, 0x0e, 0x93, 0xb1, 0x70,
	0x96, 0xe0, 0xa1, 0xf0, 0x2b, 0xef, 0x76, 0x38, 0x04, 0x1e, 0x0a, 0x90, 0xf5, 0xbe, 0xdb, 0x69,
	0xd0, 0xdb, 0xc4, 0x01, 0xd0, 0x7e, 0x37, 0xed, 0x34, 0x61, 0x29, 0x80, 0x4e, 0xbf, 0x79, 0x76,
	0x96, 0x0d, 0xdf, 0x7e, 0xf7, 0xeb, 0xac, 0x80, 0x72, 0x70, 0x96, 0xf2, 0xfb, 0x46, 0x67, 0x95,
	0x6e, 0x90, 0xbb, 0x20, 0x98, 0x7d, 0x97, 0xe8, 0x38, 0xf4, 0x0e, 0x59, 0x2b, 0x36, 0x91, 0x6d,
	0xcd, 0x59, 0x33, 0x4f, 0xb0, 0x5d, 0x99, 0x43, 0xcd, 0x8e, 0x0b, 0x1b, 0x77, 0x6e, 0x3f, 0x3d,
	0x20, 0x6b, 0x33, 0xdd, 0x1c, 0x78, 0xe2, 0x4c, 0x3f, 0xa7, 0xd7, 0xef, 0x6c, 0x1f, 0x3a, 0xb7,
	0xe8, 0xbb, 0xe4, 0xa6, 0x5e, 0x8f, 0x53, 0x79, 0x3a, 0x21, 0xf7, 0x6e, 0x28, 0xb7, 0x61, 0xdc,
	0x0d, 0x05, 0xb7, 0x73, 0x8b, 0x6e, 0x92, 0x8d, 0x69, 0x61, 0xb7, 0x73, 0xf8, 0xfa, 0xa4, 0x83,
	0xf2, 0x0a, 0xbd, 0x4f, 0xde, 0x99, 0x96, 0xf7, 0xbf, 0x3e, 0xee, 0xb0, 0x9d, 0xfd, 0x7e, 0xcf,
	0xa9, 0x6c, 0x54, 0x9d, 0xca, 0xd3, 0x5f, 0xcc, 0x93, 0x66, 0xef, 0xa4, 0x7c, 0xbe, 0x72, 0xec,
	0x59, 0x2f, 0x40, 0x9d, 0x3a, 0x9c, 0xa8, 0xc6, 0xb2, 0x17, 0x01, 0xfa, 0x90, 0x01, 0xca, 0x5f,
	0xac, 0x38, 0x84, 0x3a, 0xa4, 0xa9, 0x59, 0xba, 0x47, 0xed, 0x34, 0xe8, 0x3b, 0xe4, 0x0e, 0x92,
	0xa6, 0xdb, 0xc8, 0x4e, 0xd3, 0x88, 0x66, 0x1a, 0xa0, 0xce, 0xb2, 0x99, 0x3a, 0x6f, 0x40, 0x3a,
	0x2b, 0x25, 0x08, 0x4d, 0x6a, 0x95, 0x2e, 0x93, 0x25, 0x80, 0xb0, 0x79, 0xee, 0x38, 0x74, 0x85,
	0x10, 0x7c, 0x38, 0xe6, 0x64, 0xce, 0x1a, 0x5d, 0x25, 0x8d, 0x6c, 0x31, 0x27, 0x81, 0xb8, 0x74,
	0xa8, 0x59, 0x9d, 0xe9, 0x53, 0x39, 0xeb, 0xf4, 0x2e, 0xa1, 0x7a, 0x75, 0x76, 0x83, 0xc9, 0xb9,
	0x6d, 0x98, 0xa6, 0xff, 0xe3, 0xdc, 0x01, 0xf3, 0xc5, 0xc9, 0x8a, 0x23, 0x72, 0xee, 0x1a, 0xd0,
	0x2a, 0xf2, 0x9d, 0x7b, 0x60, 0x58, 0x00, 0x66, 0x61, 0x38, 0x83, 0x5b, 0x66, 0xfd, 0x79, 0xc5,
	0xe1, 0xbc, 0x63, 0x9e, 0x5e, 0xce, 0xea, 0x9d, 0x0d, 0xb0, 0x41, 0xc0, 0xed, 0xb2, 0xc3, 0x79,
	0xd7, 0xac, 0xc9, 0xf4, 0xb3, 0x9c, 0xf7, 0xe0, 0xce, 0x01, 0x72, 0x28, 0xe2, 0x91, 0x73, 0xdf,
	0x3c, 0xb7, 0x54, 0xd2, 0x38, 0x9b, 0x66, 0x32, 0xbb, 0x8d, 0xe2, 0x3c, 0x30, 0xa8, 0xdd, 0x1d,
	0x70, 0x1e, 0x19, 0xb4, 0x64, 0xfc, 0x6e, 0xb1, 0x21, 0x2b, 0x42, 0x3b, 0x8f, 0x8d, 0x95, 0x58,
	0x77, 0xe2, 0xff, 0x99, 0x23, 0x9d, 0xf1, 0x8b, 0xce, 0x07, 0x4f, 0x7f, 0xaf, 0x42, 0xd6, 0x34,
	0x0f, 0x57, 0x07, 0x96, 0xcd, 0x14, 0x5c, 0xdd, 0x6e, 0xe7, 0xf8, 0x60, 0xfb, 0x6b, 0xd6, 0x39,
	0xe9, 0x1c, 0xf5, 0x59, 0x7b, 0xfb, 0xa8, 0xdd, 0x39, 0x70, 0x6e, 0x81, 0x6e, 0x4a, 0x82, 0xdd,
	0xce, 0x76, 0xff, 0x95, 0x53, 0x01, 0xdf, 0x50, 0xc2, 0x5f, 0x76, 0x8e, 0x3a, 0xdd, 0xfd, 0xb6,
	0x53, 0xa5, 0x1f, 0x92, 0xc7, 0x25, 0x49, 0xaf, 0xff, 0xa6, 0xfd, 0x23, 0x76, 0xd4, 0xe9, 0xec,
	0xb2, 0xbd, 0x37, 0x07, 0x07, 0xec, 0xcd, 0xf1, 0xee, 0x76, 0xbf, 0xe3, 0xcc, 0xed, 0xb4, 0x7e,
	0xfa, 0xed, 0x66, 0xe5, 0x1f, 0xbf, 0xdd, 0xac, 0xfc, 0xfc, 0xdb, 0xcd, 0xca, 0x1f, 0xfc, 0x62,
	0xf3, 0xd6, 0x37, 0x73, 0x91, 0x1c, 0xfc, 0x4e, 0xe5, 0xd6, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff,
	0xfa, 0xce, 0x4d, 0x21, 0x61, 0x2c, 0x00, 0x00,
}
