// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: netmessages.proto

package msg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NET_Messages int32

const (
	NET_Messages_net_NOP              NET_Messages = 0
	NET_Messages_net_Disconnect       NET_Messages = 1
	NET_Messages_net_File             NET_Messages = 2
	NET_Messages_net_SplitScreenUser  NET_Messages = 3
	NET_Messages_net_Tick             NET_Messages = 4
	NET_Messages_net_StringCmd        NET_Messages = 5
	NET_Messages_net_SetConVar        NET_Messages = 6
	NET_Messages_net_SignonState      NET_Messages = 7
	NET_Messages_net_PlayerAvatarData NET_Messages = 100
)

var NET_Messages_name = map[int32]string{
	0:   "net_NOP",
	1:   "net_Disconnect",
	2:   "net_File",
	3:   "net_SplitScreenUser",
	4:   "net_Tick",
	5:   "net_StringCmd",
	6:   "net_SetConVar",
	7:   "net_SignonState",
	100: "net_PlayerAvatarData",
}

var NET_Messages_value = map[string]int32{
	"net_NOP":              0,
	"net_Disconnect":       1,
	"net_File":             2,
	"net_SplitScreenUser":  3,
	"net_Tick":             4,
	"net_StringCmd":        5,
	"net_SetConVar":        6,
	"net_SignonState":      7,
	"net_PlayerAvatarData": 100,
}

func (x NET_Messages) Enum() *NET_Messages {
	p := new(NET_Messages)
	*p = x
	return p
}

func (x NET_Messages) String() string {
	return proto.EnumName(NET_Messages_name, int32(x))
}

func (x *NET_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NET_Messages_value, data, "NET_Messages")
	if err != nil {
		return err
	}
	*x = NET_Messages(value)
	return nil
}

func (NET_Messages) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{0}
}

type CLC_Messages int32

const (
	CLC_Messages_clc_ClientInfo         CLC_Messages = 8
	CLC_Messages_clc_Move               CLC_Messages = 9
	CLC_Messages_clc_VoiceData          CLC_Messages = 10
	CLC_Messages_clc_BaselineAck        CLC_Messages = 11
	CLC_Messages_clc_ListenEvents       CLC_Messages = 12
	CLC_Messages_clc_RespondCvarValue   CLC_Messages = 13
	CLC_Messages_clc_FileCRCCheck       CLC_Messages = 14
	CLC_Messages_clc_LoadingProgress    CLC_Messages = 15
	CLC_Messages_clc_SplitPlayerConnect CLC_Messages = 16
	CLC_Messages_clc_ClientMessage      CLC_Messages = 17
	CLC_Messages_clc_CmdKeyValues       CLC_Messages = 18
	CLC_Messages_clc_HltvReplay         CLC_Messages = 20
)

var CLC_Messages_name = map[int32]string{
	8:  "clc_ClientInfo",
	9:  "clc_Move",
	10: "clc_VoiceData",
	11: "clc_BaselineAck",
	12: "clc_ListenEvents",
	13: "clc_RespondCvarValue",
	14: "clc_FileCRCCheck",
	15: "clc_LoadingProgress",
	16: "clc_SplitPlayerConnect",
	17: "clc_ClientMessage",
	18: "clc_CmdKeyValues",
	20: "clc_HltvReplay",
}

var CLC_Messages_value = map[string]int32{
	"clc_ClientInfo":         8,
	"clc_Move":               9,
	"clc_VoiceData":          10,
	"clc_BaselineAck":        11,
	"clc_ListenEvents":       12,
	"clc_RespondCvarValue":   13,
	"clc_FileCRCCheck":       14,
	"clc_LoadingProgress":    15,
	"clc_SplitPlayerConnect": 16,
	"clc_ClientMessage":      17,
	"clc_CmdKeyValues":       18,
	"clc_HltvReplay":         20,
}

func (x CLC_Messages) Enum() *CLC_Messages {
	p := new(CLC_Messages)
	*p = x
	return p
}

func (x CLC_Messages) String() string {
	return proto.EnumName(CLC_Messages_name, int32(x))
}

func (x *CLC_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CLC_Messages_value, data, "CLC_Messages")
	if err != nil {
		return err
	}
	*x = CLC_Messages(value)
	return nil
}

func (CLC_Messages) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{1}
}

type VoiceDataFormatT int32

const (
	VoiceDataFormatT_VOICEDATA_FORMAT_STEAM  VoiceDataFormatT = 0
	VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE VoiceDataFormatT = 1
)

var VoiceDataFormatT_name = map[int32]string{
	0: "VOICEDATA_FORMAT_STEAM",
	1: "VOICEDATA_FORMAT_ENGINE",
}

var VoiceDataFormatT_value = map[string]int32{
	"VOICEDATA_FORMAT_STEAM":  0,
	"VOICEDATA_FORMAT_ENGINE": 1,
}

func (x VoiceDataFormatT) Enum() *VoiceDataFormatT {
	p := new(VoiceDataFormatT)
	*p = x
	return p
}

func (x VoiceDataFormatT) String() string {
	return proto.EnumName(VoiceDataFormatT_name, int32(x))
}

func (x *VoiceDataFormatT) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VoiceDataFormatT_value, data, "VoiceDataFormatT")
	if err != nil {
		return err
	}
	*x = VoiceDataFormatT(value)
	return nil
}

func (VoiceDataFormatT) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{2}
}

type ESplitScreenMessageType int32

const (
	ESplitScreenMessageType_MSG_SPLITSCREEN_ADDUSER    ESplitScreenMessageType = 0
	ESplitScreenMessageType_MSG_SPLITSCREEN_REMOVEUSER ESplitScreenMessageType = 1
	ESplitScreenMessageType_MSG_SPLITSCREEN_TYPE_BITS  ESplitScreenMessageType = 1
)

var ESplitScreenMessageType_name = map[int32]string{
	0: "MSG_SPLITSCREEN_ADDUSER",
	1: "MSG_SPLITSCREEN_REMOVEUSER",
	// Duplicate value: 1: "MSG_SPLITSCREEN_TYPE_BITS",
}

var ESplitScreenMessageType_value = map[string]int32{
	"MSG_SPLITSCREEN_ADDUSER":    0,
	"MSG_SPLITSCREEN_REMOVEUSER": 1,
	"MSG_SPLITSCREEN_TYPE_BITS":  1,
}

func (x ESplitScreenMessageType) Enum() *ESplitScreenMessageType {
	p := new(ESplitScreenMessageType)
	*p = x
	return p
}

func (x ESplitScreenMessageType) String() string {
	return proto.EnumName(ESplitScreenMessageType_name, int32(x))
}

func (x *ESplitScreenMessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ESplitScreenMessageType_value, data, "ESplitScreenMessageType")
	if err != nil {
		return err
	}
	*x = ESplitScreenMessageType(value)
	return nil
}

func (ESplitScreenMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{3}
}

type SVC_Messages int32

const (
	SVC_Messages_svc_ServerInfo        SVC_Messages = 8
	SVC_Messages_svc_SendTable         SVC_Messages = 9
	SVC_Messages_svc_ClassInfo         SVC_Messages = 10
	SVC_Messages_svc_SetPause          SVC_Messages = 11
	SVC_Messages_svc_CreateStringTable SVC_Messages = 12
	SVC_Messages_svc_UpdateStringTable SVC_Messages = 13
	SVC_Messages_svc_VoiceInit         SVC_Messages = 14
	SVC_Messages_svc_VoiceData         SVC_Messages = 15
	SVC_Messages_svc_Print             SVC_Messages = 16
	SVC_Messages_svc_Sounds            SVC_Messages = 17
	SVC_Messages_svc_SetView           SVC_Messages = 18
	SVC_Messages_svc_FixAngle          SVC_Messages = 19
	SVC_Messages_svc_CrosshairAngle    SVC_Messages = 20
	SVC_Messages_svc_BSPDecal          SVC_Messages = 21
	SVC_Messages_svc_SplitScreen       SVC_Messages = 22
	SVC_Messages_svc_UserMessage       SVC_Messages = 23
	SVC_Messages_svc_EntityMessage     SVC_Messages = 24
	SVC_Messages_svc_GameEvent         SVC_Messages = 25
	SVC_Messages_svc_PacketEntities    SVC_Messages = 26
	SVC_Messages_svc_TempEntities      SVC_Messages = 27
	SVC_Messages_svc_Prefetch          SVC_Messages = 28
	SVC_Messages_svc_Menu              SVC_Messages = 29
	SVC_Messages_svc_GameEventList     SVC_Messages = 30
	SVC_Messages_svc_GetCvarValue      SVC_Messages = 31
	SVC_Messages_svc_PaintmapData      SVC_Messages = 33
	SVC_Messages_svc_CmdKeyValues      SVC_Messages = 34
	SVC_Messages_svc_EncryptedData     SVC_Messages = 35
	SVC_Messages_svc_HltvReplay        SVC_Messages = 36
	SVC_Messages_svc_Broadcast_Command SVC_Messages = 38
)

var SVC_Messages_name = map[int32]string{
	8:  "svc_ServerInfo",
	9:  "svc_SendTable",
	10: "svc_ClassInfo",
	11: "svc_SetPause",
	12: "svc_CreateStringTable",
	13: "svc_UpdateStringTable",
	14: "svc_VoiceInit",
	15: "svc_VoiceData",
	16: "svc_Print",
	17: "svc_Sounds",
	18: "svc_SetView",
	19: "svc_FixAngle",
	20: "svc_CrosshairAngle",
	21: "svc_BSPDecal",
	22: "svc_SplitScreen",
	23: "svc_UserMessage",
	24: "svc_EntityMessage",
	25: "svc_GameEvent",
	26: "svc_PacketEntities",
	27: "svc_TempEntities",
	28: "svc_Prefetch",
	29: "svc_Menu",
	30: "svc_GameEventList",
	31: "svc_GetCvarValue",
	33: "svc_PaintmapData",
	34: "svc_CmdKeyValues",
	35: "svc_EncryptedData",
	36: "svc_HltvReplay",
	38: "svc_Broadcast_Command",
}

var SVC_Messages_value = map[string]int32{
	"svc_ServerInfo":        8,
	"svc_SendTable":         9,
	"svc_ClassInfo":         10,
	"svc_SetPause":          11,
	"svc_CreateStringTable": 12,
	"svc_UpdateStringTable": 13,
	"svc_VoiceInit":         14,
	"svc_VoiceData":         15,
	"svc_Print":             16,
	"svc_Sounds":            17,
	"svc_SetView":           18,
	"svc_FixAngle":          19,
	"svc_CrosshairAngle":    20,
	"svc_BSPDecal":          21,
	"svc_SplitScreen":       22,
	"svc_UserMessage":       23,
	"svc_EntityMessage":     24,
	"svc_GameEvent":         25,
	"svc_PacketEntities":    26,
	"svc_TempEntities":      27,
	"svc_Prefetch":          28,
	"svc_Menu":              29,
	"svc_GameEventList":     30,
	"svc_GetCvarValue":      31,
	"svc_PaintmapData":      33,
	"svc_CmdKeyValues":      34,
	"svc_EncryptedData":     35,
	"svc_HltvReplay":        36,
	"svc_Broadcast_Command": 38,
}

func (x SVC_Messages) Enum() *SVC_Messages {
	p := new(SVC_Messages)
	*p = x
	return p
}

func (x SVC_Messages) String() string {
	return proto.EnumName(SVC_Messages_name, int32(x))
}

func (x *SVC_Messages) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SVC_Messages_value, data, "SVC_Messages")
	if err != nil {
		return err
	}
	*x = SVC_Messages(value)
	return nil
}

func (SVC_Messages) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{4}
}

type ReplayEventTypeT int32

const (
	ReplayEventTypeT_REPLAY_EVENT_CANCEL                 ReplayEventTypeT = 0
	ReplayEventTypeT_REPLAY_EVENT_DEATH                  ReplayEventTypeT = 1
	ReplayEventTypeT_REPLAY_EVENT_GENERIC                ReplayEventTypeT = 2
	ReplayEventTypeT_REPLAY_EVENT_STUCK_NEED_FULL_UPDATE ReplayEventTypeT = 3
)

var ReplayEventTypeT_name = map[int32]string{
	0: "REPLAY_EVENT_CANCEL",
	1: "REPLAY_EVENT_DEATH",
	2: "REPLAY_EVENT_GENERIC",
	3: "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE",
}

var ReplayEventTypeT_value = map[string]int32{
	"REPLAY_EVENT_CANCEL":                 0,
	"REPLAY_EVENT_DEATH":                  1,
	"REPLAY_EVENT_GENERIC":                2,
	"REPLAY_EVENT_STUCK_NEED_FULL_UPDATE": 3,
}

func (x ReplayEventTypeT) Enum() *ReplayEventTypeT {
	p := new(ReplayEventTypeT)
	*p = x
	return p
}

func (x ReplayEventTypeT) String() string {
	return proto.EnumName(ReplayEventTypeT_name, int32(x))
}

func (x *ReplayEventTypeT) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReplayEventTypeT_value, data, "ReplayEventTypeT")
	if err != nil {
		return err
	}
	*x = ReplayEventTypeT(value)
	return nil
}

func (ReplayEventTypeT) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{5}
}

type CMsgVector struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
	Z float32 `protobuf:"fixed32,3,opt,name=z" json:"z"`
}

func (m *CMsgVector) Reset()         { *m = CMsgVector{} }
func (m *CMsgVector) String() string { return proto.CompactTextString(m) }
func (*CMsgVector) ProtoMessage()    {}
func (*CMsgVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{0}
}
func (m *CMsgVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgVector.Merge(m, src)
}
func (m *CMsgVector) XXX_Size() int {
	return m.Size()
}
func (m *CMsgVector) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgVector.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgVector proto.InternalMessageInfo

func (m *CMsgVector) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgVector) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CMsgVector) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type CMsgVector2D struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
}

func (m *CMsgVector2D) Reset()         { *m = CMsgVector2D{} }
func (m *CMsgVector2D) String() string { return proto.CompactTextString(m) }
func (*CMsgVector2D) ProtoMessage()    {}
func (*CMsgVector2D) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{1}
}
func (m *CMsgVector2D) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgVector2D) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgVector2D.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgVector2D) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgVector2D.Merge(m, src)
}
func (m *CMsgVector2D) XXX_Size() int {
	return m.Size()
}
func (m *CMsgVector2D) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgVector2D.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgVector2D proto.InternalMessageInfo

func (m *CMsgVector2D) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgVector2D) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type CMsgQAngle struct {
	X float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
	Z float32 `protobuf:"fixed32,3,opt,name=z" json:"z"`
}

func (m *CMsgQAngle) Reset()         { *m = CMsgQAngle{} }
func (m *CMsgQAngle) String() string { return proto.CompactTextString(m) }
func (*CMsgQAngle) ProtoMessage()    {}
func (*CMsgQAngle) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{2}
}
func (m *CMsgQAngle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgQAngle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgQAngle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgQAngle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgQAngle.Merge(m, src)
}
func (m *CMsgQAngle) XXX_Size() int {
	return m.Size()
}
func (m *CMsgQAngle) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgQAngle.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgQAngle proto.InternalMessageInfo

func (m *CMsgQAngle) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CMsgQAngle) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CMsgQAngle) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type CMsgRGBA struct {
	R int32 `protobuf:"varint,1,opt,name=r" json:"r"`
	G int32 `protobuf:"varint,2,opt,name=g" json:"g"`
	B int32 `protobuf:"varint,3,opt,name=b" json:"b"`
	A int32 `protobuf:"varint,4,opt,name=a" json:"a"`
}

func (m *CMsgRGBA) Reset()         { *m = CMsgRGBA{} }
func (m *CMsgRGBA) String() string { return proto.CompactTextString(m) }
func (*CMsgRGBA) ProtoMessage()    {}
func (*CMsgRGBA) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{3}
}
func (m *CMsgRGBA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsgRGBA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsgRGBA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsgRGBA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsgRGBA.Merge(m, src)
}
func (m *CMsgRGBA) XXX_Size() int {
	return m.Size()
}
func (m *CMsgRGBA) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsgRGBA.DiscardUnknown(m)
}

var xxx_messageInfo_CMsgRGBA proto.InternalMessageInfo

func (m *CMsgRGBA) GetR() int32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *CMsgRGBA) GetG() int32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *CMsgRGBA) GetB() int32 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *CMsgRGBA) GetA() int32 {
	if m != nil {
		return m.A
	}
	return 0
}

type CNETMsg_Tick struct {
	Tick                            uint32 `protobuf:"varint,1,opt,name=tick" json:"tick"`
	HostComputationtime             uint32 `protobuf:"varint,4,opt,name=host_computationtime,json=hostComputationtime" json:"host_computationtime"`
	HostComputationtimeStdDeviation uint32 `protobuf:"varint,5,opt,name=host_computationtime_std_deviation,json=hostComputationtimeStdDeviation" json:"host_computationtime_std_deviation"`
	HostFramestarttimeStdDeviation  uint32 `protobuf:"varint,6,opt,name=host_framestarttime_std_deviation,json=hostFramestarttimeStdDeviation" json:"host_framestarttime_std_deviation"`
	HltvReplayFlags                 uint32 `protobuf:"varint,7,opt,name=hltv_replay_flags,json=hltvReplayFlags" json:"hltv_replay_flags"`
}

func (m *CNETMsg_Tick) Reset()         { *m = CNETMsg_Tick{} }
func (m *CNETMsg_Tick) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_Tick) ProtoMessage()    {}
func (*CNETMsg_Tick) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{4}
}
func (m *CNETMsg_Tick) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_Tick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_Tick.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_Tick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_Tick.Merge(m, src)
}
func (m *CNETMsg_Tick) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_Tick) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_Tick.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_Tick proto.InternalMessageInfo

func (m *CNETMsg_Tick) GetTick() uint32 {
	if m != nil {
		return m.Tick
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostComputationtime() uint32 {
	if m != nil {
		return m.HostComputationtime
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostComputationtimeStdDeviation() uint32 {
	if m != nil {
		return m.HostComputationtimeStdDeviation
	}
	return 0
}

func (m *CNETMsg_Tick) GetHostFramestarttimeStdDeviation() uint32 {
	if m != nil {
		return m.HostFramestarttimeStdDeviation
	}
	return 0
}

func (m *CNETMsg_Tick) GetHltvReplayFlags() uint32 {
	if m != nil {
		return m.HltvReplayFlags
	}
	return 0
}

type CNETMsg_StringCmd struct {
	Command string `protobuf:"bytes,1,opt,name=command" json:"command"`
}

func (m *CNETMsg_StringCmd) Reset()         { *m = CNETMsg_StringCmd{} }
func (m *CNETMsg_StringCmd) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_StringCmd) ProtoMessage()    {}
func (*CNETMsg_StringCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{5}
}
func (m *CNETMsg_StringCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_StringCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_StringCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_StringCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_StringCmd.Merge(m, src)
}
func (m *CNETMsg_StringCmd) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_StringCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_StringCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_StringCmd proto.InternalMessageInfo

func (m *CNETMsg_StringCmd) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

type CNETMsg_SignonState struct {
	SignonState       uint32   `protobuf:"varint,1,opt,name=signon_state,json=signonState" json:"signon_state"`
	SpawnCount        uint32   `protobuf:"varint,2,opt,name=spawn_count,json=spawnCount" json:"spawn_count"`
	NumServerPlayers  uint32   `protobuf:"varint,3,opt,name=num_server_players,json=numServerPlayers" json:"num_server_players"`
	PlayersNetworkids []string `protobuf:"bytes,4,rep,name=players_networkids,json=playersNetworkids" json:"players_networkids,omitempty"`
	MapName           string   `protobuf:"bytes,5,opt,name=map_name,json=mapName" json:"map_name"`
}

func (m *CNETMsg_SignonState) Reset()         { *m = CNETMsg_SignonState{} }
func (m *CNETMsg_SignonState) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_SignonState) ProtoMessage()    {}
func (*CNETMsg_SignonState) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{6}
}
func (m *CNETMsg_SignonState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_SignonState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_SignonState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_SignonState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_SignonState.Merge(m, src)
}
func (m *CNETMsg_SignonState) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_SignonState) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_SignonState.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_SignonState proto.InternalMessageInfo

func (m *CNETMsg_SignonState) GetSignonState() uint32 {
	if m != nil {
		return m.SignonState
	}
	return 0
}

func (m *CNETMsg_SignonState) GetSpawnCount() uint32 {
	if m != nil {
		return m.SpawnCount
	}
	return 0
}

func (m *CNETMsg_SignonState) GetNumServerPlayers() uint32 {
	if m != nil {
		return m.NumServerPlayers
	}
	return 0
}

func (m *CNETMsg_SignonState) GetPlayersNetworkids() []string {
	if m != nil {
		return m.PlayersNetworkids
	}
	return nil
}

func (m *CNETMsg_SignonState) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

type CMsg_CVars struct {
	Cvars []*CMsg_CVars_CVar `protobuf:"bytes,1,rep,name=cvars" json:"cvars,omitempty"`
}

func (m *CMsg_CVars) Reset()         { *m = CMsg_CVars{} }
func (m *CMsg_CVars) String() string { return proto.CompactTextString(m) }
func (*CMsg_CVars) ProtoMessage()    {}
func (*CMsg_CVars) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{7}
}
func (m *CMsg_CVars) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsg_CVars) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsg_CVars.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsg_CVars) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsg_CVars.Merge(m, src)
}
func (m *CMsg_CVars) XXX_Size() int {
	return m.Size()
}
func (m *CMsg_CVars) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsg_CVars.DiscardUnknown(m)
}

var xxx_messageInfo_CMsg_CVars proto.InternalMessageInfo

func (m *CMsg_CVars) GetCvars() []*CMsg_CVars_CVar {
	if m != nil {
		return m.Cvars
	}
	return nil
}

type CMsg_CVars_CVar struct {
	Name           string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value          string `protobuf:"bytes,2,opt,name=value" json:"value"`
	DictionaryName uint32 `protobuf:"varint,3,opt,name=dictionary_name,json=dictionaryName" json:"dictionary_name"`
}

func (m *CMsg_CVars_CVar) Reset()         { *m = CMsg_CVars_CVar{} }
func (m *CMsg_CVars_CVar) String() string { return proto.CompactTextString(m) }
func (*CMsg_CVars_CVar) ProtoMessage()    {}
func (*CMsg_CVars_CVar) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{7, 0}
}
func (m *CMsg_CVars_CVar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CMsg_CVars_CVar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CMsg_CVars_CVar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CMsg_CVars_CVar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CMsg_CVars_CVar.Merge(m, src)
}
func (m *CMsg_CVars_CVar) XXX_Size() int {
	return m.Size()
}
func (m *CMsg_CVars_CVar) XXX_DiscardUnknown() {
	xxx_messageInfo_CMsg_CVars_CVar.DiscardUnknown(m)
}

var xxx_messageInfo_CMsg_CVars_CVar proto.InternalMessageInfo

func (m *CMsg_CVars_CVar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsg_CVars_CVar) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *CMsg_CVars_CVar) GetDictionaryName() uint32 {
	if m != nil {
		return m.DictionaryName
	}
	return 0
}

type CNETMsg_SetConVar struct {
	Convars *CMsg_CVars `protobuf:"bytes,1,opt,name=convars" json:"convars,omitempty"`
}

func (m *CNETMsg_SetConVar) Reset()         { *m = CNETMsg_SetConVar{} }
func (m *CNETMsg_SetConVar) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_SetConVar) ProtoMessage()    {}
func (*CNETMsg_SetConVar) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{8}
}
func (m *CNETMsg_SetConVar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_SetConVar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_SetConVar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_SetConVar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_SetConVar.Merge(m, src)
}
func (m *CNETMsg_SetConVar) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_SetConVar) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_SetConVar.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_SetConVar proto.InternalMessageInfo

func (m *CNETMsg_SetConVar) GetConvars() *CMsg_CVars {
	if m != nil {
		return m.Convars
	}
	return nil
}

type CNETMsg_NOP struct {
}

func (m *CNETMsg_NOP) Reset()         { *m = CNETMsg_NOP{} }
func (m *CNETMsg_NOP) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_NOP) ProtoMessage()    {}
func (*CNETMsg_NOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{9}
}
func (m *CNETMsg_NOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_NOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_NOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_NOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_NOP.Merge(m, src)
}
func (m *CNETMsg_NOP) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_NOP) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_NOP.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_NOP proto.InternalMessageInfo

type CNETMsg_Disconnect struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text"`
}

func (m *CNETMsg_Disconnect) Reset()         { *m = CNETMsg_Disconnect{} }
func (m *CNETMsg_Disconnect) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_Disconnect) ProtoMessage()    {}
func (*CNETMsg_Disconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{10}
}
func (m *CNETMsg_Disconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_Disconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_Disconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_Disconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_Disconnect.Merge(m, src)
}
func (m *CNETMsg_Disconnect) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_Disconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_Disconnect.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_Disconnect proto.InternalMessageInfo

func (m *CNETMsg_Disconnect) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CNETMsg_File struct {
	TransferId       int32  `protobuf:"varint,1,opt,name=transfer_id,json=transferId" json:"transfer_id"`
	FileName         string `protobuf:"bytes,2,opt,name=file_name,json=fileName" json:"file_name"`
	IsReplayDemoFile bool   `protobuf:"varint,3,opt,name=is_replay_demo_file,json=isReplayDemoFile" json:"is_replay_demo_file"`
	Deny             bool   `protobuf:"varint,4,opt,name=deny" json:"deny"`
}

func (m *CNETMsg_File) Reset()         { *m = CNETMsg_File{} }
func (m *CNETMsg_File) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_File) ProtoMessage()    {}
func (*CNETMsg_File) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{11}
}
func (m *CNETMsg_File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_File.Merge(m, src)
}
func (m *CNETMsg_File) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_File) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_File.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_File proto.InternalMessageInfo

func (m *CNETMsg_File) GetTransferId() int32 {
	if m != nil {
		return m.TransferId
	}
	return 0
}

func (m *CNETMsg_File) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *CNETMsg_File) GetIsReplayDemoFile() bool {
	if m != nil {
		return m.IsReplayDemoFile
	}
	return false
}

func (m *CNETMsg_File) GetDeny() bool {
	if m != nil {
		return m.Deny
	}
	return false
}

type CNETMsg_SplitScreenUser struct {
	Slot int32 `protobuf:"varint,1,opt,name=slot" json:"slot"`
}

func (m *CNETMsg_SplitScreenUser) Reset()         { *m = CNETMsg_SplitScreenUser{} }
func (m *CNETMsg_SplitScreenUser) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_SplitScreenUser) ProtoMessage()    {}
func (*CNETMsg_SplitScreenUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{12}
}
func (m *CNETMsg_SplitScreenUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_SplitScreenUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_SplitScreenUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_SplitScreenUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_SplitScreenUser.Merge(m, src)
}
func (m *CNETMsg_SplitScreenUser) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_SplitScreenUser) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_SplitScreenUser.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_SplitScreenUser proto.InternalMessageInfo

func (m *CNETMsg_SplitScreenUser) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

type CNETMsg_PlayerAvatarData struct {
	Accountid uint32 `protobuf:"varint,1,opt,name=accountid" json:"accountid"`
	Rgb       []byte `protobuf:"bytes,2,opt,name=rgb" json:"rgb"`
}

func (m *CNETMsg_PlayerAvatarData) Reset()         { *m = CNETMsg_PlayerAvatarData{} }
func (m *CNETMsg_PlayerAvatarData) String() string { return proto.CompactTextString(m) }
func (*CNETMsg_PlayerAvatarData) ProtoMessage()    {}
func (*CNETMsg_PlayerAvatarData) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{13}
}
func (m *CNETMsg_PlayerAvatarData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNETMsg_PlayerAvatarData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNETMsg_PlayerAvatarData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNETMsg_PlayerAvatarData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNETMsg_PlayerAvatarData.Merge(m, src)
}
func (m *CNETMsg_PlayerAvatarData) XXX_Size() int {
	return m.Size()
}
func (m *CNETMsg_PlayerAvatarData) XXX_DiscardUnknown() {
	xxx_messageInfo_CNETMsg_PlayerAvatarData.DiscardUnknown(m)
}

var xxx_messageInfo_CNETMsg_PlayerAvatarData proto.InternalMessageInfo

func (m *CNETMsg_PlayerAvatarData) GetAccountid() uint32 {
	if m != nil {
		return m.Accountid
	}
	return 0
}

func (m *CNETMsg_PlayerAvatarData) GetRgb() []byte {
	if m != nil {
		return m.Rgb
	}
	return nil
}

type CCLCMsg_ClientInfo struct {
	SendTableCrc uint32   `protobuf:"fixed32,1,opt,name=send_table_crc,json=sendTableCrc" json:"send_table_crc"`
	ServerCount  uint32   `protobuf:"varint,2,opt,name=server_count,json=serverCount" json:"server_count"`
	IsHltv       bool     `protobuf:"varint,3,opt,name=is_hltv,json=isHltv" json:"is_hltv"`
	IsReplay     bool     `protobuf:"varint,4,opt,name=is_replay,json=isReplay" json:"is_replay"`
	FriendsId    uint32   `protobuf:"varint,5,opt,name=friends_id,json=friendsId" json:"friends_id"`
	FriendsName  string   `protobuf:"bytes,6,opt,name=friends_name,json=friendsName" json:"friends_name"`
	CustomFiles  []uint32 `protobuf:"fixed32,7,rep,name=custom_files,json=customFiles" json:"custom_files,omitempty"`
}

func (m *CCLCMsg_ClientInfo) Reset()         { *m = CCLCMsg_ClientInfo{} }
func (m *CCLCMsg_ClientInfo) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_ClientInfo) ProtoMessage()    {}
func (*CCLCMsg_ClientInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{14}
}
func (m *CCLCMsg_ClientInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_ClientInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_ClientInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_ClientInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_ClientInfo.Merge(m, src)
}
func (m *CCLCMsg_ClientInfo) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_ClientInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_ClientInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_ClientInfo proto.InternalMessageInfo

func (m *CCLCMsg_ClientInfo) GetSendTableCrc() uint32 {
	if m != nil {
		return m.SendTableCrc
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetServerCount() uint32 {
	if m != nil {
		return m.ServerCount
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetIsHltv() bool {
	if m != nil {
		return m.IsHltv
	}
	return false
}

func (m *CCLCMsg_ClientInfo) GetIsReplay() bool {
	if m != nil {
		return m.IsReplay
	}
	return false
}

func (m *CCLCMsg_ClientInfo) GetFriendsId() uint32 {
	if m != nil {
		return m.FriendsId
	}
	return 0
}

func (m *CCLCMsg_ClientInfo) GetFriendsName() string {
	if m != nil {
		return m.FriendsName
	}
	return ""
}

func (m *CCLCMsg_ClientInfo) GetCustomFiles() []uint32 {
	if m != nil {
		return m.CustomFiles
	}
	return nil
}

type CCLCMsg_Move struct {
	NumBackupCommands uint32 `protobuf:"varint,1,opt,name=num_backup_commands,json=numBackupCommands" json:"num_backup_commands"`
	NumNewCommands    uint32 `protobuf:"varint,2,opt,name=num_new_commands,json=numNewCommands" json:"num_new_commands"`
	Data              []byte `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *CCLCMsg_Move) Reset()         { *m = CCLCMsg_Move{} }
func (m *CCLCMsg_Move) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_Move) ProtoMessage()    {}
func (*CCLCMsg_Move) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{15}
}
func (m *CCLCMsg_Move) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_Move) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_Move.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_Move) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_Move.Merge(m, src)
}
func (m *CCLCMsg_Move) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_Move) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_Move.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_Move proto.InternalMessageInfo

func (m *CCLCMsg_Move) GetNumBackupCommands() uint32 {
	if m != nil {
		return m.NumBackupCommands
	}
	return 0
}

func (m *CCLCMsg_Move) GetNumNewCommands() uint32 {
	if m != nil {
		return m.NumNewCommands
	}
	return 0
}

func (m *CCLCMsg_Move) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CCLCMsg_VoiceData struct {
	Data                     []byte            `protobuf:"bytes,1,opt,name=data" json:"data"`
	Xuid                     uint64            `protobuf:"fixed64,2,opt,name=xuid" json:"xuid"`
	Format                   *VoiceDataFormatT `protobuf:"varint,3,opt,name=format,enum=VoiceDataFormatT,def=1" json:"format,omitempty"`
	SequenceBytes            int32             `protobuf:"varint,4,opt,name=sequence_bytes,json=sequenceBytes" json:"sequence_bytes"`
	SectionNumber            uint32            `protobuf:"varint,5,opt,name=section_number,json=sectionNumber" json:"section_number"`
	UncompressedSampleOffset uint32            `protobuf:"varint,6,opt,name=uncompressed_sample_offset,json=uncompressedSampleOffset" json:"uncompressed_sample_offset"`
}

func (m *CCLCMsg_VoiceData) Reset()         { *m = CCLCMsg_VoiceData{} }
func (m *CCLCMsg_VoiceData) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_VoiceData) ProtoMessage()    {}
func (*CCLCMsg_VoiceData) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{16}
}
func (m *CCLCMsg_VoiceData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_VoiceData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_VoiceData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_VoiceData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_VoiceData.Merge(m, src)
}
func (m *CCLCMsg_VoiceData) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_VoiceData) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_VoiceData.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_VoiceData proto.InternalMessageInfo

const Default_CCLCMsg_VoiceData_Format VoiceDataFormatT = VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE

func (m *CCLCMsg_VoiceData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CCLCMsg_VoiceData) GetXuid() uint64 {
	if m != nil {
		return m.Xuid
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetFormat() VoiceDataFormatT {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return Default_CCLCMsg_VoiceData_Format
}

func (m *CCLCMsg_VoiceData) GetSequenceBytes() int32 {
	if m != nil {
		return m.SequenceBytes
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetSectionNumber() uint32 {
	if m != nil {
		return m.SectionNumber
	}
	return 0
}

func (m *CCLCMsg_VoiceData) GetUncompressedSampleOffset() uint32 {
	if m != nil {
		return m.UncompressedSampleOffset
	}
	return 0
}

type CCLCMsg_BaselineAck struct {
	BaselineTick int32 `protobuf:"varint,1,opt,name=baseline_tick,json=baselineTick" json:"baseline_tick"`
	BaselineNr   int32 `protobuf:"varint,2,opt,name=baseline_nr,json=baselineNr" json:"baseline_nr"`
}

func (m *CCLCMsg_BaselineAck) Reset()         { *m = CCLCMsg_BaselineAck{} }
func (m *CCLCMsg_BaselineAck) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_BaselineAck) ProtoMessage()    {}
func (*CCLCMsg_BaselineAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{17}
}
func (m *CCLCMsg_BaselineAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_BaselineAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_BaselineAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_BaselineAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_BaselineAck.Merge(m, src)
}
func (m *CCLCMsg_BaselineAck) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_BaselineAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_BaselineAck.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_BaselineAck proto.InternalMessageInfo

func (m *CCLCMsg_BaselineAck) GetBaselineTick() int32 {
	if m != nil {
		return m.BaselineTick
	}
	return 0
}

func (m *CCLCMsg_BaselineAck) GetBaselineNr() int32 {
	if m != nil {
		return m.BaselineNr
	}
	return 0
}

type CCLCMsg_ListenEvents struct {
	EventMask []uint32 `protobuf:"fixed32,1,rep,name=event_mask,json=eventMask" json:"event_mask,omitempty"`
}

func (m *CCLCMsg_ListenEvents) Reset()         { *m = CCLCMsg_ListenEvents{} }
func (m *CCLCMsg_ListenEvents) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_ListenEvents) ProtoMessage()    {}
func (*CCLCMsg_ListenEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{18}
}
func (m *CCLCMsg_ListenEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_ListenEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_ListenEvents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_ListenEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_ListenEvents.Merge(m, src)
}
func (m *CCLCMsg_ListenEvents) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_ListenEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_ListenEvents.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_ListenEvents proto.InternalMessageInfo

func (m *CCLCMsg_ListenEvents) GetEventMask() []uint32 {
	if m != nil {
		return m.EventMask
	}
	return nil
}

type CCLCMsg_RespondCvarValue struct {
	Cookie     int32  `protobuf:"varint,1,opt,name=cookie" json:"cookie"`
	StatusCode int32  `protobuf:"varint,2,opt,name=status_code,json=statusCode" json:"status_code"`
	Name       string `protobuf:"bytes,3,opt,name=name" json:"name"`
	Value      string `protobuf:"bytes,4,opt,name=value" json:"value"`
}

func (m *CCLCMsg_RespondCvarValue) Reset()         { *m = CCLCMsg_RespondCvarValue{} }
func (m *CCLCMsg_RespondCvarValue) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_RespondCvarValue) ProtoMessage()    {}
func (*CCLCMsg_RespondCvarValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{19}
}
func (m *CCLCMsg_RespondCvarValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_RespondCvarValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_RespondCvarValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_RespondCvarValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_RespondCvarValue.Merge(m, src)
}
func (m *CCLCMsg_RespondCvarValue) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_RespondCvarValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_RespondCvarValue.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_RespondCvarValue proto.InternalMessageInfo

func (m *CCLCMsg_RespondCvarValue) GetCookie() int32 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *CCLCMsg_RespondCvarValue) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *CCLCMsg_RespondCvarValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CCLCMsg_RespondCvarValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CCLCMsg_FileCRCCheck struct {
	CodePath       int32  `protobuf:"varint,1,opt,name=code_path,json=codePath" json:"code_path"`
	Path           string `protobuf:"bytes,2,opt,name=path" json:"path"`
	CodeFilename   int32  `protobuf:"varint,3,opt,name=code_filename,json=codeFilename" json:"code_filename"`
	Filename       string `protobuf:"bytes,4,opt,name=filename" json:"filename"`
	FileFraction   int32  `protobuf:"varint,5,opt,name=file_fraction,json=fileFraction" json:"file_fraction"`
	Md5            []byte `protobuf:"bytes,6,opt,name=md5" json:"md5"`
	Crc            uint32 `protobuf:"varint,7,opt,name=crc" json:"crc"`
	FileHashType   int32  `protobuf:"varint,8,opt,name=file_hash_type,json=fileHashType" json:"file_hash_type"`
	FileLen        int32  `protobuf:"varint,9,opt,name=file_len,json=fileLen" json:"file_len"`
	PackFileId     int32  `protobuf:"varint,10,opt,name=pack_file_id,json=packFileId" json:"pack_file_id"`
	PackFileNumber int32  `protobuf:"varint,11,opt,name=pack_file_number,json=packFileNumber" json:"pack_file_number"`
}

func (m *CCLCMsg_FileCRCCheck) Reset()         { *m = CCLCMsg_FileCRCCheck{} }
func (m *CCLCMsg_FileCRCCheck) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_FileCRCCheck) ProtoMessage()    {}
func (*CCLCMsg_FileCRCCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{20}
}
func (m *CCLCMsg_FileCRCCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_FileCRCCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_FileCRCCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_FileCRCCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_FileCRCCheck.Merge(m, src)
}
func (m *CCLCMsg_FileCRCCheck) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_FileCRCCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_FileCRCCheck.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_FileCRCCheck proto.InternalMessageInfo

func (m *CCLCMsg_FileCRCCheck) GetCodePath() int32 {
	if m != nil {
		return m.CodePath
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *CCLCMsg_FileCRCCheck) GetCodeFilename() int32 {
	if m != nil {
		return m.CodeFilename
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *CCLCMsg_FileCRCCheck) GetFileFraction() int32 {
	if m != nil {
		return m.FileFraction
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *CCLCMsg_FileCRCCheck) GetCrc() uint32 {
	if m != nil {
		return m.Crc
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFileHashType() int32 {
	if m != nil {
		return m.FileHashType
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetFileLen() int32 {
	if m != nil {
		return m.FileLen
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPackFileId() int32 {
	if m != nil {
		return m.PackFileId
	}
	return 0
}

func (m *CCLCMsg_FileCRCCheck) GetPackFileNumber() int32 {
	if m != nil {
		return m.PackFileNumber
	}
	return 0
}

type CCLCMsg_LoadingProgress struct {
	Progress int32 `protobuf:"varint,1,opt,name=progress" json:"progress"`
}

func (m *CCLCMsg_LoadingProgress) Reset()         { *m = CCLCMsg_LoadingProgress{} }
func (m *CCLCMsg_LoadingProgress) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_LoadingProgress) ProtoMessage()    {}
func (*CCLCMsg_LoadingProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{21}
}
func (m *CCLCMsg_LoadingProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_LoadingProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_LoadingProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_LoadingProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_LoadingProgress.Merge(m, src)
}
func (m *CCLCMsg_LoadingProgress) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_LoadingProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_LoadingProgress.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_LoadingProgress proto.InternalMessageInfo

func (m *CCLCMsg_LoadingProgress) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type CCLCMsg_SplitPlayerConnect struct {
	Convars *CMsg_CVars `protobuf:"bytes,1,opt,name=convars" json:"convars,omitempty"`
}

func (m *CCLCMsg_SplitPlayerConnect) Reset()         { *m = CCLCMsg_SplitPlayerConnect{} }
func (m *CCLCMsg_SplitPlayerConnect) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_SplitPlayerConnect) ProtoMessage()    {}
func (*CCLCMsg_SplitPlayerConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{22}
}
func (m *CCLCMsg_SplitPlayerConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_SplitPlayerConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_SplitPlayerConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_SplitPlayerConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_SplitPlayerConnect.Merge(m, src)
}
func (m *CCLCMsg_SplitPlayerConnect) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_SplitPlayerConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_SplitPlayerConnect.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_SplitPlayerConnect proto.InternalMessageInfo

func (m *CCLCMsg_SplitPlayerConnect) GetConvars() *CMsg_CVars {
	if m != nil {
		return m.Convars
	}
	return nil
}

type CCLCMsg_CmdKeyValues struct {
	Keyvalues []byte `protobuf:"bytes,1,opt,name=keyvalues" json:"keyvalues"`
}

func (m *CCLCMsg_CmdKeyValues) Reset()         { *m = CCLCMsg_CmdKeyValues{} }
func (m *CCLCMsg_CmdKeyValues) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_CmdKeyValues) ProtoMessage()    {}
func (*CCLCMsg_CmdKeyValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{23}
}
func (m *CCLCMsg_CmdKeyValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_CmdKeyValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_CmdKeyValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_CmdKeyValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_CmdKeyValues.Merge(m, src)
}
func (m *CCLCMsg_CmdKeyValues) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_CmdKeyValues) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_CmdKeyValues.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_CmdKeyValues proto.InternalMessageInfo

func (m *CCLCMsg_CmdKeyValues) GetKeyvalues() []byte {
	if m != nil {
		return m.Keyvalues
	}
	return nil
}

type CSVCMsg_ServerInfo struct {
	Protocol                  int32   `protobuf:"varint,1,opt,name=protocol" json:"protocol"`
	ServerCount               int32   `protobuf:"varint,2,opt,name=server_count,json=serverCount" json:"server_count"`
	IsDedicated               bool    `protobuf:"varint,3,opt,name=is_dedicated,json=isDedicated" json:"is_dedicated"`
	IsOfficialValveServer     bool    `protobuf:"varint,4,opt,name=is_official_valve_server,json=isOfficialValveServer" json:"is_official_valve_server"`
	IsHltv                    bool    `protobuf:"varint,5,opt,name=is_hltv,json=isHltv" json:"is_hltv"`
	IsReplay                  bool    `protobuf:"varint,6,opt,name=is_replay,json=isReplay" json:"is_replay"`
	IsRedirectingToProxyRelay bool    `protobuf:"varint,21,opt,name=is_redirecting_to_proxy_relay,json=isRedirectingToProxyRelay" json:"is_redirecting_to_proxy_relay"`
	COs                       int32   `protobuf:"varint,7,opt,name=c_os,json=cOs" json:"c_os"`
	MapCrc                    uint32  `protobuf:"fixed32,8,opt,name=map_crc,json=mapCrc" json:"map_crc"`
	ClientCrc                 uint32  `protobuf:"fixed32,9,opt,name=client_crc,json=clientCrc" json:"client_crc"`
	StringTableCrc            uint32  `protobuf:"fixed32,10,opt,name=string_table_crc,json=stringTableCrc" json:"string_table_crc"`
	MaxClients                int32   `protobuf:"varint,11,opt,name=max_clients,json=maxClients" json:"max_clients"`
	MaxClasses                int32   `protobuf:"varint,12,opt,name=max_classes,json=maxClasses" json:"max_classes"`
	PlayerSlot                int32   `protobuf:"varint,13,opt,name=player_slot,json=playerSlot" json:"player_slot"`
	TickInterval              float32 `protobuf:"fixed32,14,opt,name=tick_interval,json=tickInterval" json:"tick_interval"`
	GameDir                   string  `protobuf:"bytes,15,opt,name=game_dir,json=gameDir" json:"game_dir"`
	MapName                   string  `protobuf:"bytes,16,opt,name=map_name,json=mapName" json:"map_name"`
	MapGroupName              string  `protobuf:"bytes,17,opt,name=map_group_name,json=mapGroupName" json:"map_group_name"`
	SkyName                   string  `protobuf:"bytes,18,opt,name=sky_name,json=skyName" json:"sky_name"`
	HostName                  string  `protobuf:"bytes,19,opt,name=host_name,json=hostName" json:"host_name"`
	PublicIp                  uint32  `protobuf:"varint,20,opt,name=public_ip,json=publicIp" json:"public_ip"`
	UgcMapId                  uint64  `protobuf:"varint,22,opt,name=ugc_map_id,json=ugcMapId" json:"ugc_map_id"`
}

func (m *CSVCMsg_ServerInfo) Reset()         { *m = CSVCMsg_ServerInfo{} }
func (m *CSVCMsg_ServerInfo) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_ServerInfo) ProtoMessage()    {}
func (*CSVCMsg_ServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{24}
}
func (m *CSVCMsg_ServerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_ServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_ServerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_ServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_ServerInfo.Merge(m, src)
}
func (m *CSVCMsg_ServerInfo) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_ServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_ServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_ServerInfo proto.InternalMessageInfo

func (m *CSVCMsg_ServerInfo) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetServerCount() int32 {
	if m != nil {
		return m.ServerCount
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetIsDedicated() bool {
	if m != nil {
		return m.IsDedicated
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsOfficialValveServer() bool {
	if m != nil {
		return m.IsOfficialValveServer
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsHltv() bool {
	if m != nil {
		return m.IsHltv
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsReplay() bool {
	if m != nil {
		return m.IsReplay
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetIsRedirectingToProxyRelay() bool {
	if m != nil {
		return m.IsRedirectingToProxyRelay
	}
	return false
}

func (m *CSVCMsg_ServerInfo) GetCOs() int32 {
	if m != nil {
		return m.COs
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMapCrc() uint32 {
	if m != nil {
		return m.MapCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetClientCrc() uint32 {
	if m != nil {
		return m.ClientCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetStringTableCrc() uint32 {
	if m != nil {
		return m.StringTableCrc
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMaxClients() int32 {
	if m != nil {
		return m.MaxClients
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetMaxClasses() int32 {
	if m != nil {
		return m.MaxClasses
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetPlayerSlot() int32 {
	if m != nil {
		return m.PlayerSlot
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetTickInterval() float32 {
	if m != nil {
		return m.TickInterval
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetGameDir() string {
	if m != nil {
		return m.GameDir
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetMapGroupName() string {
	if m != nil {
		return m.MapGroupName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetSkyName() string {
	if m != nil {
		return m.SkyName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CSVCMsg_ServerInfo) GetPublicIp() uint32 {
	if m != nil {
		return m.PublicIp
	}
	return 0
}

func (m *CSVCMsg_ServerInfo) GetUgcMapId() uint64 {
	if m != nil {
		return m.UgcMapId
	}
	return 0
}

type CSVCMsg_ClassInfo struct {
	CreateOnClient bool                       `protobuf:"varint,1,opt,name=create_on_client,json=createOnClient" json:"create_on_client"`
	Classes        []*CSVCMsg_ClassInfoClassT `protobuf:"bytes,2,rep,name=classes" json:"classes,omitempty"`
}

func (m *CSVCMsg_ClassInfo) Reset()         { *m = CSVCMsg_ClassInfo{} }
func (m *CSVCMsg_ClassInfo) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_ClassInfo) ProtoMessage()    {}
func (*CSVCMsg_ClassInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{25}
}
func (m *CSVCMsg_ClassInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_ClassInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_ClassInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_ClassInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_ClassInfo.Merge(m, src)
}
func (m *CSVCMsg_ClassInfo) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_ClassInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_ClassInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_ClassInfo proto.InternalMessageInfo

func (m *CSVCMsg_ClassInfo) GetCreateOnClient() bool {
	if m != nil {
		return m.CreateOnClient
	}
	return false
}

func (m *CSVCMsg_ClassInfo) GetClasses() []*CSVCMsg_ClassInfoClassT {
	if m != nil {
		return m.Classes
	}
	return nil
}

type CSVCMsg_ClassInfoClassT struct {
	ClassId       int32  `protobuf:"varint,1,opt,name=class_id,json=classId" json:"class_id"`
	DataTableName string `protobuf:"bytes,2,opt,name=data_table_name,json=dataTableName" json:"data_table_name"`
	ClassName     string `protobuf:"bytes,3,opt,name=class_name,json=className" json:"class_name"`
}

func (m *CSVCMsg_ClassInfoClassT) Reset()         { *m = CSVCMsg_ClassInfoClassT{} }
func (m *CSVCMsg_ClassInfoClassT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_ClassInfoClassT) ProtoMessage()    {}
func (*CSVCMsg_ClassInfoClassT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{25, 0}
}
func (m *CSVCMsg_ClassInfoClassT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_ClassInfoClassT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_ClassInfoClassT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_ClassInfoClassT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_ClassInfoClassT.Merge(m, src)
}
func (m *CSVCMsg_ClassInfoClassT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_ClassInfoClassT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_ClassInfoClassT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_ClassInfoClassT proto.InternalMessageInfo

func (m *CSVCMsg_ClassInfoClassT) GetClassId() int32 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *CSVCMsg_ClassInfoClassT) GetDataTableName() string {
	if m != nil {
		return m.DataTableName
	}
	return ""
}

func (m *CSVCMsg_ClassInfoClassT) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

type CSVCMsg_SendTable struct {
	IsEnd        bool                          `protobuf:"varint,1,opt,name=is_end,json=isEnd" json:"is_end"`
	NetTableName string                        `protobuf:"bytes,2,opt,name=net_table_name,json=netTableName" json:"net_table_name"`
	NeedsDecoder bool                          `protobuf:"varint,3,opt,name=needs_decoder,json=needsDecoder" json:"needs_decoder"`
	Props        []*CSVCMsg_SendTableSendpropT `protobuf:"bytes,4,rep,name=props" json:"props,omitempty"`
}

func (m *CSVCMsg_SendTable) Reset()         { *m = CSVCMsg_SendTable{} }
func (m *CSVCMsg_SendTable) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SendTable) ProtoMessage()    {}
func (*CSVCMsg_SendTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{26}
}
func (m *CSVCMsg_SendTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SendTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SendTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SendTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SendTable.Merge(m, src)
}
func (m *CSVCMsg_SendTable) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SendTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SendTable.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SendTable proto.InternalMessageInfo

func (m *CSVCMsg_SendTable) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *CSVCMsg_SendTable) GetNetTableName() string {
	if m != nil {
		return m.NetTableName
	}
	return ""
}

func (m *CSVCMsg_SendTable) GetNeedsDecoder() bool {
	if m != nil {
		return m.NeedsDecoder
	}
	return false
}

func (m *CSVCMsg_SendTable) GetProps() []*CSVCMsg_SendTableSendpropT {
	if m != nil {
		return m.Props
	}
	return nil
}

type CSVCMsg_SendTableSendpropT struct {
	Type        int32   `protobuf:"varint,1,opt,name=type" json:"type"`
	VarName     string  `protobuf:"bytes,2,opt,name=var_name,json=varName" json:"var_name"`
	Flags       int32   `protobuf:"varint,3,opt,name=flags" json:"flags"`
	Priority    int32   `protobuf:"varint,4,opt,name=priority" json:"priority"`
	DtName      string  `protobuf:"bytes,5,opt,name=dt_name,json=dtName" json:"dt_name"`
	NumElements int32   `protobuf:"varint,6,opt,name=num_elements,json=numElements" json:"num_elements"`
	LowValue    float32 `protobuf:"fixed32,7,opt,name=low_value,json=lowValue" json:"low_value"`
	HighValue   float32 `protobuf:"fixed32,8,opt,name=high_value,json=highValue" json:"high_value"`
	NumBits     int32   `protobuf:"varint,9,opt,name=num_bits,json=numBits" json:"num_bits"`
}

func (m *CSVCMsg_SendTableSendpropT) Reset()         { *m = CSVCMsg_SendTableSendpropT{} }
func (m *CSVCMsg_SendTableSendpropT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SendTableSendpropT) ProtoMessage()    {}
func (*CSVCMsg_SendTableSendpropT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{26, 0}
}
func (m *CSVCMsg_SendTableSendpropT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SendTableSendpropT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SendTableSendpropT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SendTableSendpropT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SendTableSendpropT.Merge(m, src)
}
func (m *CSVCMsg_SendTableSendpropT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SendTableSendpropT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SendTableSendpropT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SendTableSendpropT proto.InternalMessageInfo

func (m *CSVCMsg_SendTableSendpropT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetVarName() string {
	if m != nil {
		return m.VarName
	}
	return ""
}

func (m *CSVCMsg_SendTableSendpropT) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetDtName() string {
	if m != nil {
		return m.DtName
	}
	return ""
}

func (m *CSVCMsg_SendTableSendpropT) GetNumElements() int32 {
	if m != nil {
		return m.NumElements
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetLowValue() float32 {
	if m != nil {
		return m.LowValue
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetHighValue() float32 {
	if m != nil {
		return m.HighValue
	}
	return 0
}

func (m *CSVCMsg_SendTableSendpropT) GetNumBits() int32 {
	if m != nil {
		return m.NumBits
	}
	return 0
}

type CSVCMsg_Print struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text"`
}

func (m *CSVCMsg_Print) Reset()         { *m = CSVCMsg_Print{} }
func (m *CSVCMsg_Print) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Print) ProtoMessage()    {}
func (*CSVCMsg_Print) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{27}
}
func (m *CSVCMsg_Print) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_Print) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_Print.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_Print) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_Print.Merge(m, src)
}
func (m *CSVCMsg_Print) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_Print) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_Print.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_Print proto.InternalMessageInfo

func (m *CSVCMsg_Print) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CSVCMsg_SetPause struct {
	Paused bool `protobuf:"varint,1,opt,name=paused" json:"paused"`
}

func (m *CSVCMsg_SetPause) Reset()         { *m = CSVCMsg_SetPause{} }
func (m *CSVCMsg_SetPause) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SetPause) ProtoMessage()    {}
func (*CSVCMsg_SetPause) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{28}
}
func (m *CSVCMsg_SetPause) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SetPause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SetPause.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SetPause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SetPause.Merge(m, src)
}
func (m *CSVCMsg_SetPause) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SetPause) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SetPause.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SetPause proto.InternalMessageInfo

func (m *CSVCMsg_SetPause) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

type CSVCMsg_SetView struct {
	EntityIndex int32 `protobuf:"varint,1,opt,name=entity_index,json=entityIndex" json:"entity_index"`
}

func (m *CSVCMsg_SetView) Reset()         { *m = CSVCMsg_SetView{} }
func (m *CSVCMsg_SetView) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SetView) ProtoMessage()    {}
func (*CSVCMsg_SetView) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{29}
}
func (m *CSVCMsg_SetView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SetView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SetView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SetView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SetView.Merge(m, src)
}
func (m *CSVCMsg_SetView) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SetView) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SetView.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SetView proto.InternalMessageInfo

func (m *CSVCMsg_SetView) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

type CSVCMsg_CreateStringTable struct {
	Name              string `protobuf:"bytes,1,opt,name=name" json:"name"`
	MaxEntries        int32  `protobuf:"varint,2,opt,name=max_entries,json=maxEntries" json:"max_entries"`
	NumEntries        int32  `protobuf:"varint,3,opt,name=num_entries,json=numEntries" json:"num_entries"`
	UserDataFixedSize bool   `protobuf:"varint,4,opt,name=user_data_fixed_size,json=userDataFixedSize" json:"user_data_fixed_size"`
	UserDataSize      int32  `protobuf:"varint,5,opt,name=user_data_size,json=userDataSize" json:"user_data_size"`
	UserDataSizeBits  int32  `protobuf:"varint,6,opt,name=user_data_size_bits,json=userDataSizeBits" json:"user_data_size_bits"`
	Flags             int32  `protobuf:"varint,7,opt,name=flags" json:"flags"`
	StringData        []byte `protobuf:"bytes,8,opt,name=string_data,json=stringData" json:"string_data"`
}

func (m *CSVCMsg_CreateStringTable) Reset()         { *m = CSVCMsg_CreateStringTable{} }
func (m *CSVCMsg_CreateStringTable) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_CreateStringTable) ProtoMessage()    {}
func (*CSVCMsg_CreateStringTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{30}
}
func (m *CSVCMsg_CreateStringTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_CreateStringTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_CreateStringTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_CreateStringTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_CreateStringTable.Merge(m, src)
}
func (m *CSVCMsg_CreateStringTable) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_CreateStringTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_CreateStringTable.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_CreateStringTable proto.InternalMessageInfo

func (m *CSVCMsg_CreateStringTable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSVCMsg_CreateStringTable) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetNumEntries() int32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetUserDataFixedSize() bool {
	if m != nil {
		return m.UserDataFixedSize
	}
	return false
}

func (m *CSVCMsg_CreateStringTable) GetUserDataSize() int32 {
	if m != nil {
		return m.UserDataSize
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetUserDataSizeBits() int32 {
	if m != nil {
		return m.UserDataSizeBits
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_CreateStringTable) GetStringData() []byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

type CSVCMsg_UpdateStringTable struct {
	TableId           int32  `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	NumChangedEntries int32  `protobuf:"varint,2,opt,name=num_changed_entries,json=numChangedEntries" json:"num_changed_entries"`
	StringData        []byte `protobuf:"bytes,3,opt,name=string_data,json=stringData" json:"string_data"`
}

func (m *CSVCMsg_UpdateStringTable) Reset()         { *m = CSVCMsg_UpdateStringTable{} }
func (m *CSVCMsg_UpdateStringTable) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_UpdateStringTable) ProtoMessage()    {}
func (*CSVCMsg_UpdateStringTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{31}
}
func (m *CSVCMsg_UpdateStringTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_UpdateStringTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_UpdateStringTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_UpdateStringTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_UpdateStringTable.Merge(m, src)
}
func (m *CSVCMsg_UpdateStringTable) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_UpdateStringTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_UpdateStringTable.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_UpdateStringTable proto.InternalMessageInfo

func (m *CSVCMsg_UpdateStringTable) GetTableId() int32 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *CSVCMsg_UpdateStringTable) GetNumChangedEntries() int32 {
	if m != nil {
		return m.NumChangedEntries
	}
	return 0
}

func (m *CSVCMsg_UpdateStringTable) GetStringData() []byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

type CSVCMsg_VoiceInit struct {
	Quality int32  `protobuf:"varint,1,opt,name=quality" json:"quality"`
	Codec   string `protobuf:"bytes,2,opt,name=codec" json:"codec"`
	Version *int32 `protobuf:"varint,3,opt,name=version,def=0" json:"version,omitempty"`
}

func (m *CSVCMsg_VoiceInit) Reset()         { *m = CSVCMsg_VoiceInit{} }
func (m *CSVCMsg_VoiceInit) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_VoiceInit) ProtoMessage()    {}
func (*CSVCMsg_VoiceInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{32}
}
func (m *CSVCMsg_VoiceInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_VoiceInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_VoiceInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_VoiceInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_VoiceInit.Merge(m, src)
}
func (m *CSVCMsg_VoiceInit) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_VoiceInit) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_VoiceInit.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_VoiceInit proto.InternalMessageInfo

const Default_CSVCMsg_VoiceInit_Version int32 = 0

func (m *CSVCMsg_VoiceInit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *CSVCMsg_VoiceInit) GetCodec() string {
	if m != nil {
		return m.Codec
	}
	return ""
}

func (m *CSVCMsg_VoiceInit) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_CSVCMsg_VoiceInit_Version
}

type CSVCMsg_VoiceData struct {
	Client                   int32             `protobuf:"varint,1,opt,name=client" json:"client"`
	Proximity                bool              `protobuf:"varint,2,opt,name=proximity" json:"proximity"`
	Xuid                     uint64            `protobuf:"fixed64,3,opt,name=xuid" json:"xuid"`
	AudibleMask              int32             `protobuf:"varint,4,opt,name=audible_mask,json=audibleMask" json:"audible_mask"`
	VoiceData                []byte            `protobuf:"bytes,5,opt,name=voice_data,json=voiceData" json:"voice_data"`
	Caster                   bool              `protobuf:"varint,6,opt,name=caster" json:"caster"`
	Format                   *VoiceDataFormatT `protobuf:"varint,7,opt,name=format,enum=VoiceDataFormatT,def=1" json:"format,omitempty"`
	SequenceBytes            int32             `protobuf:"varint,8,opt,name=sequence_bytes,json=sequenceBytes" json:"sequence_bytes"`
	SectionNumber            uint32            `protobuf:"varint,9,opt,name=section_number,json=sectionNumber" json:"section_number"`
	UncompressedSampleOffset uint32            `protobuf:"varint,10,opt,name=uncompressed_sample_offset,json=uncompressedSampleOffset" json:"uncompressed_sample_offset"`
}

func (m *CSVCMsg_VoiceData) Reset()         { *m = CSVCMsg_VoiceData{} }
func (m *CSVCMsg_VoiceData) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_VoiceData) ProtoMessage()    {}
func (*CSVCMsg_VoiceData) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{33}
}
func (m *CSVCMsg_VoiceData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_VoiceData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_VoiceData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_VoiceData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_VoiceData.Merge(m, src)
}
func (m *CSVCMsg_VoiceData) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_VoiceData) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_VoiceData.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_VoiceData proto.InternalMessageInfo

const Default_CSVCMsg_VoiceData_Format VoiceDataFormatT = VoiceDataFormatT_VOICEDATA_FORMAT_ENGINE

func (m *CSVCMsg_VoiceData) GetClient() int32 {
	if m != nil {
		return m.Client
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetProximity() bool {
	if m != nil {
		return m.Proximity
	}
	return false
}

func (m *CSVCMsg_VoiceData) GetXuid() uint64 {
	if m != nil {
		return m.Xuid
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetAudibleMask() int32 {
	if m != nil {
		return m.AudibleMask
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetVoiceData() []byte {
	if m != nil {
		return m.VoiceData
	}
	return nil
}

func (m *CSVCMsg_VoiceData) GetCaster() bool {
	if m != nil {
		return m.Caster
	}
	return false
}

func (m *CSVCMsg_VoiceData) GetFormat() VoiceDataFormatT {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return Default_CSVCMsg_VoiceData_Format
}

func (m *CSVCMsg_VoiceData) GetSequenceBytes() int32 {
	if m != nil {
		return m.SequenceBytes
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetSectionNumber() uint32 {
	if m != nil {
		return m.SectionNumber
	}
	return 0
}

func (m *CSVCMsg_VoiceData) GetUncompressedSampleOffset() uint32 {
	if m != nil {
		return m.UncompressedSampleOffset
	}
	return 0
}

type CSVCMsg_FixAngle struct {
	Relative bool        `protobuf:"varint,1,opt,name=relative" json:"relative"`
	Angle    *CMsgQAngle `protobuf:"bytes,2,opt,name=angle" json:"angle,omitempty"`
}

func (m *CSVCMsg_FixAngle) Reset()         { *m = CSVCMsg_FixAngle{} }
func (m *CSVCMsg_FixAngle) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_FixAngle) ProtoMessage()    {}
func (*CSVCMsg_FixAngle) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{34}
}
func (m *CSVCMsg_FixAngle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_FixAngle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_FixAngle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_FixAngle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_FixAngle.Merge(m, src)
}
func (m *CSVCMsg_FixAngle) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_FixAngle) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_FixAngle.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_FixAngle proto.InternalMessageInfo

func (m *CSVCMsg_FixAngle) GetRelative() bool {
	if m != nil {
		return m.Relative
	}
	return false
}

func (m *CSVCMsg_FixAngle) GetAngle() *CMsgQAngle {
	if m != nil {
		return m.Angle
	}
	return nil
}

type CSVCMsg_CrosshairAngle struct {
	Angle *CMsgQAngle `protobuf:"bytes,1,opt,name=angle" json:"angle,omitempty"`
}

func (m *CSVCMsg_CrosshairAngle) Reset()         { *m = CSVCMsg_CrosshairAngle{} }
func (m *CSVCMsg_CrosshairAngle) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_CrosshairAngle) ProtoMessage()    {}
func (*CSVCMsg_CrosshairAngle) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{35}
}
func (m *CSVCMsg_CrosshairAngle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_CrosshairAngle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_CrosshairAngle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_CrosshairAngle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_CrosshairAngle.Merge(m, src)
}
func (m *CSVCMsg_CrosshairAngle) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_CrosshairAngle) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_CrosshairAngle.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_CrosshairAngle proto.InternalMessageInfo

func (m *CSVCMsg_CrosshairAngle) GetAngle() *CMsgQAngle {
	if m != nil {
		return m.Angle
	}
	return nil
}

type CSVCMsg_Prefetch struct {
	SoundIndex int32 `protobuf:"varint,1,opt,name=sound_index,json=soundIndex" json:"sound_index"`
}

func (m *CSVCMsg_Prefetch) Reset()         { *m = CSVCMsg_Prefetch{} }
func (m *CSVCMsg_Prefetch) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Prefetch) ProtoMessage()    {}
func (*CSVCMsg_Prefetch) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{36}
}
func (m *CSVCMsg_Prefetch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_Prefetch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_Prefetch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_Prefetch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_Prefetch.Merge(m, src)
}
func (m *CSVCMsg_Prefetch) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_Prefetch) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_Prefetch.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_Prefetch proto.InternalMessageInfo

func (m *CSVCMsg_Prefetch) GetSoundIndex() int32 {
	if m != nil {
		return m.SoundIndex
	}
	return 0
}

type CSVCMsg_BSPDecal struct {
	Pos               *CMsgVector `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	DecalTextureIndex int32       `protobuf:"varint,2,opt,name=decal_texture_index,json=decalTextureIndex" json:"decal_texture_index"`
	EntityIndex       int32       `protobuf:"varint,3,opt,name=entity_index,json=entityIndex" json:"entity_index"`
	ModelIndex        int32       `protobuf:"varint,4,opt,name=model_index,json=modelIndex" json:"model_index"`
	LowPriority       bool        `protobuf:"varint,5,opt,name=low_priority,json=lowPriority" json:"low_priority"`
}

func (m *CSVCMsg_BSPDecal) Reset()         { *m = CSVCMsg_BSPDecal{} }
func (m *CSVCMsg_BSPDecal) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_BSPDecal) ProtoMessage()    {}
func (*CSVCMsg_BSPDecal) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{37}
}
func (m *CSVCMsg_BSPDecal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_BSPDecal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_BSPDecal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_BSPDecal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_BSPDecal.Merge(m, src)
}
func (m *CSVCMsg_BSPDecal) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_BSPDecal) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_BSPDecal.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_BSPDecal proto.InternalMessageInfo

func (m *CSVCMsg_BSPDecal) GetPos() *CMsgVector {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CSVCMsg_BSPDecal) GetDecalTextureIndex() int32 {
	if m != nil {
		return m.DecalTextureIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetModelIndex() int32 {
	if m != nil {
		return m.ModelIndex
	}
	return 0
}

func (m *CSVCMsg_BSPDecal) GetLowPriority() bool {
	if m != nil {
		return m.LowPriority
	}
	return false
}

type CSVCMsg_SplitScreen struct {
	Type        *ESplitScreenMessageType `protobuf:"varint,1,opt,name=type,enum=ESplitScreenMessageType,def=0" json:"type,omitempty"`
	Slot        int32                    `protobuf:"varint,2,opt,name=slot" json:"slot"`
	PlayerIndex int32                    `protobuf:"varint,3,opt,name=player_index,json=playerIndex" json:"player_index"`
}

func (m *CSVCMsg_SplitScreen) Reset()         { *m = CSVCMsg_SplitScreen{} }
func (m *CSVCMsg_SplitScreen) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SplitScreen) ProtoMessage()    {}
func (*CSVCMsg_SplitScreen) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{38}
}
func (m *CSVCMsg_SplitScreen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SplitScreen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SplitScreen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SplitScreen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SplitScreen.Merge(m, src)
}
func (m *CSVCMsg_SplitScreen) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SplitScreen) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SplitScreen.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SplitScreen proto.InternalMessageInfo

const Default_CSVCMsg_SplitScreen_Type ESplitScreenMessageType = ESplitScreenMessageType_MSG_SPLITSCREEN_ADDUSER

func (m *CSVCMsg_SplitScreen) GetType() ESplitScreenMessageType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_CSVCMsg_SplitScreen_Type
}

func (m *CSVCMsg_SplitScreen) GetSlot() int32 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *CSVCMsg_SplitScreen) GetPlayerIndex() int32 {
	if m != nil {
		return m.PlayerIndex
	}
	return 0
}

type CSVCMsg_GetCvarValue struct {
	Cookie   int32  `protobuf:"varint,1,opt,name=cookie" json:"cookie"`
	CvarName string `protobuf:"bytes,2,opt,name=cvar_name,json=cvarName" json:"cvar_name"`
}

func (m *CSVCMsg_GetCvarValue) Reset()         { *m = CSVCMsg_GetCvarValue{} }
func (m *CSVCMsg_GetCvarValue) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GetCvarValue) ProtoMessage()    {}
func (*CSVCMsg_GetCvarValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{39}
}
func (m *CSVCMsg_GetCvarValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GetCvarValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GetCvarValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GetCvarValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GetCvarValue.Merge(m, src)
}
func (m *CSVCMsg_GetCvarValue) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GetCvarValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GetCvarValue.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GetCvarValue proto.InternalMessageInfo

func (m *CSVCMsg_GetCvarValue) GetCookie() int32 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *CSVCMsg_GetCvarValue) GetCvarName() string {
	if m != nil {
		return m.CvarName
	}
	return ""
}

type CSVCMsg_Menu struct {
	DialogType    int32  `protobuf:"varint,1,opt,name=dialog_type,json=dialogType" json:"dialog_type"`
	MenuKeyValues []byte `protobuf:"bytes,2,opt,name=menu_key_values,json=menuKeyValues" json:"menu_key_values"`
}

func (m *CSVCMsg_Menu) Reset()         { *m = CSVCMsg_Menu{} }
func (m *CSVCMsg_Menu) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Menu) ProtoMessage()    {}
func (*CSVCMsg_Menu) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{40}
}
func (m *CSVCMsg_Menu) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_Menu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_Menu.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_Menu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_Menu.Merge(m, src)
}
func (m *CSVCMsg_Menu) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_Menu) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_Menu.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_Menu proto.InternalMessageInfo

func (m *CSVCMsg_Menu) GetDialogType() int32 {
	if m != nil {
		return m.DialogType
	}
	return 0
}

func (m *CSVCMsg_Menu) GetMenuKeyValues() []byte {
	if m != nil {
		return m.MenuKeyValues
	}
	return nil
}

type CSVCMsg_UserMessage struct {
	MsgType     int32  `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	MsgData     []byte `protobuf:"bytes,2,opt,name=msg_data,json=msgData" json:"msg_data"`
	Passthrough int32  `protobuf:"varint,3,opt,name=passthrough" json:"passthrough"`
}

func (m *CSVCMsg_UserMessage) Reset()         { *m = CSVCMsg_UserMessage{} }
func (m *CSVCMsg_UserMessage) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_UserMessage) ProtoMessage()    {}
func (*CSVCMsg_UserMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{41}
}
func (m *CSVCMsg_UserMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_UserMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_UserMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_UserMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_UserMessage.Merge(m, src)
}
func (m *CSVCMsg_UserMessage) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_UserMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_UserMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_UserMessage proto.InternalMessageInfo

func (m *CSVCMsg_UserMessage) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CSVCMsg_UserMessage) GetMsgData() []byte {
	if m != nil {
		return m.MsgData
	}
	return nil
}

func (m *CSVCMsg_UserMessage) GetPassthrough() int32 {
	if m != nil {
		return m.Passthrough
	}
	return 0
}

type CSVCMsg_PaintmapData struct {
	Paintmap []byte `protobuf:"bytes,1,opt,name=paintmap" json:"paintmap"`
}

func (m *CSVCMsg_PaintmapData) Reset()         { *m = CSVCMsg_PaintmapData{} }
func (m *CSVCMsg_PaintmapData) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_PaintmapData) ProtoMessage()    {}
func (*CSVCMsg_PaintmapData) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{42}
}
func (m *CSVCMsg_PaintmapData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_PaintmapData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_PaintmapData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_PaintmapData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_PaintmapData.Merge(m, src)
}
func (m *CSVCMsg_PaintmapData) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_PaintmapData) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_PaintmapData.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_PaintmapData proto.InternalMessageInfo

func (m *CSVCMsg_PaintmapData) GetPaintmap() []byte {
	if m != nil {
		return m.Paintmap
	}
	return nil
}

type CSVCMsg_GameEvent struct {
	EventName   string                   `protobuf:"bytes,1,opt,name=event_name,json=eventName" json:"event_name"`
	Eventid     int32                    `protobuf:"varint,2,opt,name=eventid" json:"eventid"`
	Keys        []*CSVCMsg_GameEventKeyT `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	Passthrough int32                    `protobuf:"varint,4,opt,name=passthrough" json:"passthrough"`
}

func (m *CSVCMsg_GameEvent) Reset()         { *m = CSVCMsg_GameEvent{} }
func (m *CSVCMsg_GameEvent) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEvent) ProtoMessage()    {}
func (*CSVCMsg_GameEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{43}
}
func (m *CSVCMsg_GameEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GameEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GameEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GameEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GameEvent.Merge(m, src)
}
func (m *CSVCMsg_GameEvent) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GameEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GameEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GameEvent proto.InternalMessageInfo

func (m *CSVCMsg_GameEvent) GetEventName() string {
	if m != nil {
		return m.EventName
	}
	return ""
}

func (m *CSVCMsg_GameEvent) GetEventid() int32 {
	if m != nil {
		return m.Eventid
	}
	return 0
}

func (m *CSVCMsg_GameEvent) GetKeys() []*CSVCMsg_GameEventKeyT {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CSVCMsg_GameEvent) GetPassthrough() int32 {
	if m != nil {
		return m.Passthrough
	}
	return 0
}

type CSVCMsg_GameEventKeyT struct {
	Type       int32   `protobuf:"varint,1,opt,name=type" json:"type"`
	ValString  string  `protobuf:"bytes,2,opt,name=val_string,json=valString" json:"val_string"`
	ValFloat   float32 `protobuf:"fixed32,3,opt,name=val_float,json=valFloat" json:"val_float"`
	ValLong    int32   `protobuf:"varint,4,opt,name=val_long,json=valLong" json:"val_long"`
	ValShort   int32   `protobuf:"varint,5,opt,name=val_short,json=valShort" json:"val_short"`
	ValByte    int32   `protobuf:"varint,6,opt,name=val_byte,json=valByte" json:"val_byte"`
	ValBool    bool    `protobuf:"varint,7,opt,name=val_bool,json=valBool" json:"val_bool"`
	ValUint64  uint64  `protobuf:"varint,8,opt,name=val_uint64,json=valUint64" json:"val_uint64"`
	ValWstring []byte  `protobuf:"bytes,9,opt,name=val_wstring,json=valWstring" json:"val_wstring"`
}

func (m *CSVCMsg_GameEventKeyT) Reset()         { *m = CSVCMsg_GameEventKeyT{} }
func (m *CSVCMsg_GameEventKeyT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventKeyT) ProtoMessage()    {}
func (*CSVCMsg_GameEventKeyT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{43, 0}
}
func (m *CSVCMsg_GameEventKeyT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GameEventKeyT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GameEventKeyT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GameEventKeyT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GameEventKeyT.Merge(m, src)
}
func (m *CSVCMsg_GameEventKeyT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GameEventKeyT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GameEventKeyT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GameEventKeyT proto.InternalMessageInfo

func (m *CSVCMsg_GameEventKeyT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValString() string {
	if m != nil {
		return m.ValString
	}
	return ""
}

func (m *CSVCMsg_GameEventKeyT) GetValFloat() float32 {
	if m != nil {
		return m.ValFloat
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValLong() int32 {
	if m != nil {
		return m.ValLong
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValShort() int32 {
	if m != nil {
		return m.ValShort
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValByte() int32 {
	if m != nil {
		return m.ValByte
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValBool() bool {
	if m != nil {
		return m.ValBool
	}
	return false
}

func (m *CSVCMsg_GameEventKeyT) GetValUint64() uint64 {
	if m != nil {
		return m.ValUint64
	}
	return 0
}

func (m *CSVCMsg_GameEventKeyT) GetValWstring() []byte {
	if m != nil {
		return m.ValWstring
	}
	return nil
}

type CSVCMsg_GameEventList struct {
	Descriptors []*CSVCMsg_GameEventListDescriptorT `protobuf:"bytes,1,rep,name=descriptors" json:"descriptors,omitempty"`
}

func (m *CSVCMsg_GameEventList) Reset()         { *m = CSVCMsg_GameEventList{} }
func (m *CSVCMsg_GameEventList) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventList) ProtoMessage()    {}
func (*CSVCMsg_GameEventList) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{44}
}
func (m *CSVCMsg_GameEventList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GameEventList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GameEventList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GameEventList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GameEventList.Merge(m, src)
}
func (m *CSVCMsg_GameEventList) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GameEventList) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GameEventList.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GameEventList proto.InternalMessageInfo

func (m *CSVCMsg_GameEventList) GetDescriptors() []*CSVCMsg_GameEventListDescriptorT {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

type CSVCMsg_GameEventListKeyT struct {
	Type int32  `protobuf:"varint,1,opt,name=type" json:"type"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
}

func (m *CSVCMsg_GameEventListKeyT) Reset()         { *m = CSVCMsg_GameEventListKeyT{} }
func (m *CSVCMsg_GameEventListKeyT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventListKeyT) ProtoMessage()    {}
func (*CSVCMsg_GameEventListKeyT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{44, 0}
}
func (m *CSVCMsg_GameEventListKeyT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GameEventListKeyT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GameEventListKeyT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GameEventListKeyT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GameEventListKeyT.Merge(m, src)
}
func (m *CSVCMsg_GameEventListKeyT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GameEventListKeyT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GameEventListKeyT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GameEventListKeyT proto.InternalMessageInfo

func (m *CSVCMsg_GameEventListKeyT) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CSVCMsg_GameEventListKeyT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CSVCMsg_GameEventListDescriptorT struct {
	Eventid int32                        `protobuf:"varint,1,opt,name=eventid" json:"eventid"`
	Name    string                       `protobuf:"bytes,2,opt,name=name" json:"name"`
	Keys    []*CSVCMsg_GameEventListKeyT `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
}

func (m *CSVCMsg_GameEventListDescriptorT) Reset()         { *m = CSVCMsg_GameEventListDescriptorT{} }
func (m *CSVCMsg_GameEventListDescriptorT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_GameEventListDescriptorT) ProtoMessage()    {}
func (*CSVCMsg_GameEventListDescriptorT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{44, 1}
}
func (m *CSVCMsg_GameEventListDescriptorT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_GameEventListDescriptorT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_GameEventListDescriptorT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_GameEventListDescriptorT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_GameEventListDescriptorT.Merge(m, src)
}
func (m *CSVCMsg_GameEventListDescriptorT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_GameEventListDescriptorT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_GameEventListDescriptorT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_GameEventListDescriptorT proto.InternalMessageInfo

func (m *CSVCMsg_GameEventListDescriptorT) GetEventid() int32 {
	if m != nil {
		return m.Eventid
	}
	return 0
}

func (m *CSVCMsg_GameEventListDescriptorT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSVCMsg_GameEventListDescriptorT) GetKeys() []*CSVCMsg_GameEventListKeyT {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CSVCMsg_TempEntities struct {
	Reliable   bool   `protobuf:"varint,1,opt,name=reliable" json:"reliable"`
	NumEntries int32  `protobuf:"varint,2,opt,name=num_entries,json=numEntries" json:"num_entries"`
	EntityData []byte `protobuf:"bytes,3,opt,name=entity_data,json=entityData" json:"entity_data"`
}

func (m *CSVCMsg_TempEntities) Reset()         { *m = CSVCMsg_TempEntities{} }
func (m *CSVCMsg_TempEntities) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_TempEntities) ProtoMessage()    {}
func (*CSVCMsg_TempEntities) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{45}
}
func (m *CSVCMsg_TempEntities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_TempEntities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_TempEntities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_TempEntities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_TempEntities.Merge(m, src)
}
func (m *CSVCMsg_TempEntities) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_TempEntities) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_TempEntities.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_TempEntities proto.InternalMessageInfo

func (m *CSVCMsg_TempEntities) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *CSVCMsg_TempEntities) GetNumEntries() int32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

func (m *CSVCMsg_TempEntities) GetEntityData() []byte {
	if m != nil {
		return m.EntityData
	}
	return nil
}

type CSVCMsg_PacketEntities struct {
	MaxEntries     int32  `protobuf:"varint,1,opt,name=max_entries,json=maxEntries" json:"max_entries"`
	UpdatedEntries int32  `protobuf:"varint,2,opt,name=updated_entries,json=updatedEntries" json:"updated_entries"`
	IsDelta        bool   `protobuf:"varint,3,opt,name=is_delta,json=isDelta" json:"is_delta"`
	UpdateBaseline bool   `protobuf:"varint,4,opt,name=update_baseline,json=updateBaseline" json:"update_baseline"`
	Baseline       int32  `protobuf:"varint,5,opt,name=baseline" json:"baseline"`
	DeltaFrom      int32  `protobuf:"varint,6,opt,name=delta_from,json=deltaFrom" json:"delta_from"`
	EntityData     []byte `protobuf:"bytes,7,opt,name=entity_data,json=entityData" json:"entity_data"`
}

func (m *CSVCMsg_PacketEntities) Reset()         { *m = CSVCMsg_PacketEntities{} }
func (m *CSVCMsg_PacketEntities) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_PacketEntities) ProtoMessage()    {}
func (*CSVCMsg_PacketEntities) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{46}
}
func (m *CSVCMsg_PacketEntities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_PacketEntities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_PacketEntities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_PacketEntities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_PacketEntities.Merge(m, src)
}
func (m *CSVCMsg_PacketEntities) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_PacketEntities) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_PacketEntities.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_PacketEntities proto.InternalMessageInfo

func (m *CSVCMsg_PacketEntities) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetUpdatedEntries() int32 {
	if m != nil {
		return m.UpdatedEntries
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetIsDelta() bool {
	if m != nil {
		return m.IsDelta
	}
	return false
}

func (m *CSVCMsg_PacketEntities) GetUpdateBaseline() bool {
	if m != nil {
		return m.UpdateBaseline
	}
	return false
}

func (m *CSVCMsg_PacketEntities) GetBaseline() int32 {
	if m != nil {
		return m.Baseline
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetDeltaFrom() int32 {
	if m != nil {
		return m.DeltaFrom
	}
	return 0
}

func (m *CSVCMsg_PacketEntities) GetEntityData() []byte {
	if m != nil {
		return m.EntityData
	}
	return nil
}

type CSVCMsg_Sounds struct {
	ReliableSound bool                        `protobuf:"varint,1,opt,name=reliable_sound,json=reliableSound" json:"reliable_sound"`
	Sounds        []*CSVCMsg_SoundsSounddataT `protobuf:"bytes,2,rep,name=sounds" json:"sounds,omitempty"`
}

func (m *CSVCMsg_Sounds) Reset()         { *m = CSVCMsg_Sounds{} }
func (m *CSVCMsg_Sounds) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Sounds) ProtoMessage()    {}
func (*CSVCMsg_Sounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{47}
}
func (m *CSVCMsg_Sounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_Sounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_Sounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_Sounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_Sounds.Merge(m, src)
}
func (m *CSVCMsg_Sounds) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_Sounds) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_Sounds.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_Sounds proto.InternalMessageInfo

func (m *CSVCMsg_Sounds) GetReliableSound() bool {
	if m != nil {
		return m.ReliableSound
	}
	return false
}

func (m *CSVCMsg_Sounds) GetSounds() []*CSVCMsg_SoundsSounddataT {
	if m != nil {
		return m.Sounds
	}
	return nil
}

type CSVCMsg_SoundsSounddataT struct {
	OriginX        int32   `protobuf:"zigzag32,1,opt,name=origin_x,json=originX" json:"origin_x"`
	OriginY        int32   `protobuf:"zigzag32,2,opt,name=origin_y,json=originY" json:"origin_y"`
	OriginZ        int32   `protobuf:"zigzag32,3,opt,name=origin_z,json=originZ" json:"origin_z"`
	Volume         uint32  `protobuf:"varint,4,opt,name=volume" json:"volume"`
	DelayValue     float32 `protobuf:"fixed32,5,opt,name=delay_value,json=delayValue" json:"delay_value"`
	SequenceNumber int32   `protobuf:"varint,6,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number"`
	EntityIndex    int32   `protobuf:"varint,7,opt,name=entity_index,json=entityIndex" json:"entity_index"`
	Channel        int32   `protobuf:"varint,8,opt,name=channel" json:"channel"`
	Pitch          int32   `protobuf:"varint,9,opt,name=pitch" json:"pitch"`
	Flags          int32   `protobuf:"varint,10,opt,name=flags" json:"flags"`
	SoundNum       uint32  `protobuf:"varint,11,opt,name=sound_num,json=soundNum" json:"sound_num"`
	SoundNumHandle uint32  `protobuf:"fixed32,12,opt,name=sound_num_handle,json=soundNumHandle" json:"sound_num_handle"`
	SpeakerEntity  int32   `protobuf:"varint,13,opt,name=speaker_entity,json=speakerEntity" json:"speaker_entity"`
	RandomSeed     int32   `protobuf:"varint,14,opt,name=random_seed,json=randomSeed" json:"random_seed"`
	SoundLevel     int32   `protobuf:"varint,15,opt,name=sound_level,json=soundLevel" json:"sound_level"`
	IsSentence     bool    `protobuf:"varint,16,opt,name=is_sentence,json=isSentence" json:"is_sentence"`
	IsAmbient      bool    `protobuf:"varint,17,opt,name=is_ambient,json=isAmbient" json:"is_ambient"`
}

func (m *CSVCMsg_SoundsSounddataT) Reset()         { *m = CSVCMsg_SoundsSounddataT{} }
func (m *CSVCMsg_SoundsSounddataT) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_SoundsSounddataT) ProtoMessage()    {}
func (*CSVCMsg_SoundsSounddataT) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{47, 0}
}
func (m *CSVCMsg_SoundsSounddataT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_SoundsSounddataT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_SoundsSounddataT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_SoundsSounddataT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_SoundsSounddataT.Merge(m, src)
}
func (m *CSVCMsg_SoundsSounddataT) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_SoundsSounddataT) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_SoundsSounddataT.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_SoundsSounddataT proto.InternalMessageInfo

func (m *CSVCMsg_SoundsSounddataT) GetOriginX() int32 {
	if m != nil {
		return m.OriginX
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetOriginY() int32 {
	if m != nil {
		return m.OriginY
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetOriginZ() int32 {
	if m != nil {
		return m.OriginZ
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetVolume() uint32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetDelayValue() float32 {
	if m != nil {
		return m.DelayValue
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetEntityIndex() int32 {
	if m != nil {
		return m.EntityIndex
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetPitch() int32 {
	if m != nil {
		return m.Pitch
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundNum() uint32 {
	if m != nil {
		return m.SoundNum
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundNumHandle() uint32 {
	if m != nil {
		return m.SoundNumHandle
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSpeakerEntity() int32 {
	if m != nil {
		return m.SpeakerEntity
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetRandomSeed() int32 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetSoundLevel() int32 {
	if m != nil {
		return m.SoundLevel
	}
	return 0
}

func (m *CSVCMsg_SoundsSounddataT) GetIsSentence() bool {
	if m != nil {
		return m.IsSentence
	}
	return false
}

func (m *CSVCMsg_SoundsSounddataT) GetIsAmbient() bool {
	if m != nil {
		return m.IsAmbient
	}
	return false
}

type CSVCMsg_EntityMsg struct {
	EntIndex int32  `protobuf:"varint,1,opt,name=ent_index,json=entIndex" json:"ent_index"`
	ClassId  int32  `protobuf:"varint,2,opt,name=class_id,json=classId" json:"class_id"`
	EntData  []byte `protobuf:"bytes,3,opt,name=ent_data,json=entData" json:"ent_data"`
}

func (m *CSVCMsg_EntityMsg) Reset()         { *m = CSVCMsg_EntityMsg{} }
func (m *CSVCMsg_EntityMsg) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_EntityMsg) ProtoMessage()    {}
func (*CSVCMsg_EntityMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{48}
}
func (m *CSVCMsg_EntityMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_EntityMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_EntityMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_EntityMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_EntityMsg.Merge(m, src)
}
func (m *CSVCMsg_EntityMsg) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_EntityMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_EntityMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_EntityMsg proto.InternalMessageInfo

func (m *CSVCMsg_EntityMsg) GetEntIndex() int32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *CSVCMsg_EntityMsg) GetClassId() int32 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *CSVCMsg_EntityMsg) GetEntData() []byte {
	if m != nil {
		return m.EntData
	}
	return nil
}

type CSVCMsg_CmdKeyValues struct {
	Keyvalues []byte `protobuf:"bytes,1,opt,name=keyvalues" json:"keyvalues"`
}

func (m *CSVCMsg_CmdKeyValues) Reset()         { *m = CSVCMsg_CmdKeyValues{} }
func (m *CSVCMsg_CmdKeyValues) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_CmdKeyValues) ProtoMessage()    {}
func (*CSVCMsg_CmdKeyValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{49}
}
func (m *CSVCMsg_CmdKeyValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_CmdKeyValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_CmdKeyValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_CmdKeyValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_CmdKeyValues.Merge(m, src)
}
func (m *CSVCMsg_CmdKeyValues) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_CmdKeyValues) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_CmdKeyValues.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_CmdKeyValues proto.InternalMessageInfo

func (m *CSVCMsg_CmdKeyValues) GetKeyvalues() []byte {
	if m != nil {
		return m.Keyvalues
	}
	return nil
}

type CSVCMsg_EncryptedData struct {
	Encrypted []byte `protobuf:"bytes,1,opt,name=encrypted" json:"encrypted"`
	KeyType   int32  `protobuf:"varint,2,opt,name=key_type,json=keyType" json:"key_type"`
}

func (m *CSVCMsg_EncryptedData) Reset()         { *m = CSVCMsg_EncryptedData{} }
func (m *CSVCMsg_EncryptedData) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_EncryptedData) ProtoMessage()    {}
func (*CSVCMsg_EncryptedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{50}
}
func (m *CSVCMsg_EncryptedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_EncryptedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_EncryptedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_EncryptedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_EncryptedData.Merge(m, src)
}
func (m *CSVCMsg_EncryptedData) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_EncryptedData) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_EncryptedData.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_EncryptedData proto.InternalMessageInfo

func (m *CSVCMsg_EncryptedData) GetEncrypted() []byte {
	if m != nil {
		return m.Encrypted
	}
	return nil
}

func (m *CSVCMsg_EncryptedData) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

type CSVCMsg_HltvReplay struct {
	Delay               int32   `protobuf:"varint,1,opt,name=delay" json:"delay"`
	PrimaryTarget       int32   `protobuf:"varint,2,opt,name=primary_target,json=primaryTarget" json:"primary_target"`
	ReplayStopAt        int32   `protobuf:"varint,3,opt,name=replay_stop_at,json=replayStopAt" json:"replay_stop_at"`
	ReplayStartAt       int32   `protobuf:"varint,4,opt,name=replay_start_at,json=replayStartAt" json:"replay_start_at"`
	ReplaySlowdownBegin int32   `protobuf:"varint,5,opt,name=replay_slowdown_begin,json=replaySlowdownBegin" json:"replay_slowdown_begin"`
	ReplaySlowdownEnd   int32   `protobuf:"varint,6,opt,name=replay_slowdown_end,json=replaySlowdownEnd" json:"replay_slowdown_end"`
	ReplaySlowdownRate  float32 `protobuf:"fixed32,7,opt,name=replay_slowdown_rate,json=replaySlowdownRate" json:"replay_slowdown_rate"`
}

func (m *CSVCMsg_HltvReplay) Reset()         { *m = CSVCMsg_HltvReplay{} }
func (m *CSVCMsg_HltvReplay) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_HltvReplay) ProtoMessage()    {}
func (*CSVCMsg_HltvReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{51}
}
func (m *CSVCMsg_HltvReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_HltvReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_HltvReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_HltvReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_HltvReplay.Merge(m, src)
}
func (m *CSVCMsg_HltvReplay) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_HltvReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_HltvReplay.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_HltvReplay proto.InternalMessageInfo

func (m *CSVCMsg_HltvReplay) GetDelay() int32 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetPrimaryTarget() int32 {
	if m != nil {
		return m.PrimaryTarget
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplayStopAt() int32 {
	if m != nil {
		return m.ReplayStopAt
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplayStartAt() int32 {
	if m != nil {
		return m.ReplayStartAt
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownBegin() int32 {
	if m != nil {
		return m.ReplaySlowdownBegin
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownEnd() int32 {
	if m != nil {
		return m.ReplaySlowdownEnd
	}
	return 0
}

func (m *CSVCMsg_HltvReplay) GetReplaySlowdownRate() float32 {
	if m != nil {
		return m.ReplaySlowdownRate
	}
	return 0
}

type CCLCMsg_HltvReplay struct {
	Request               int32   `protobuf:"varint,1,opt,name=request" json:"request"`
	SlowdownLength        float32 `protobuf:"fixed32,2,opt,name=slowdown_length,json=slowdownLength" json:"slowdown_length"`
	SlowdownRate          float32 `protobuf:"fixed32,3,opt,name=slowdown_rate,json=slowdownRate" json:"slowdown_rate"`
	PrimaryTargetEntIndex int32   `protobuf:"varint,4,opt,name=primary_target_ent_index,json=primaryTargetEntIndex" json:"primary_target_ent_index"`
	EventTime             float32 `protobuf:"fixed32,5,opt,name=event_time,json=eventTime" json:"event_time"`
}

func (m *CCLCMsg_HltvReplay) Reset()         { *m = CCLCMsg_HltvReplay{} }
func (m *CCLCMsg_HltvReplay) String() string { return proto.CompactTextString(m) }
func (*CCLCMsg_HltvReplay) ProtoMessage()    {}
func (*CCLCMsg_HltvReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{52}
}
func (m *CCLCMsg_HltvReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCLCMsg_HltvReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCLCMsg_HltvReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCLCMsg_HltvReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCLCMsg_HltvReplay.Merge(m, src)
}
func (m *CCLCMsg_HltvReplay) XXX_Size() int {
	return m.Size()
}
func (m *CCLCMsg_HltvReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_CCLCMsg_HltvReplay.DiscardUnknown(m)
}

var xxx_messageInfo_CCLCMsg_HltvReplay proto.InternalMessageInfo

func (m *CCLCMsg_HltvReplay) GetRequest() int32 {
	if m != nil {
		return m.Request
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetSlowdownLength() float32 {
	if m != nil {
		return m.SlowdownLength
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetSlowdownRate() float32 {
	if m != nil {
		return m.SlowdownRate
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetPrimaryTargetEntIndex() int32 {
	if m != nil {
		return m.PrimaryTargetEntIndex
	}
	return 0
}

func (m *CCLCMsg_HltvReplay) GetEventTime() float32 {
	if m != nil {
		return m.EventTime
	}
	return 0
}

type CSVCMsg_Broadcast_Command struct {
	Cmd string `protobuf:"bytes,1,opt,name=cmd" json:"cmd"`
}

func (m *CSVCMsg_Broadcast_Command) Reset()         { *m = CSVCMsg_Broadcast_Command{} }
func (m *CSVCMsg_Broadcast_Command) String() string { return proto.CompactTextString(m) }
func (*CSVCMsg_Broadcast_Command) ProtoMessage()    {}
func (*CSVCMsg_Broadcast_Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_52cbc162d33bb4fa, []int{53}
}
func (m *CSVCMsg_Broadcast_Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVCMsg_Broadcast_Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSVCMsg_Broadcast_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSVCMsg_Broadcast_Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVCMsg_Broadcast_Command.Merge(m, src)
}
func (m *CSVCMsg_Broadcast_Command) XXX_Size() int {
	return m.Size()
}
func (m *CSVCMsg_Broadcast_Command) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVCMsg_Broadcast_Command.DiscardUnknown(m)
}

var xxx_messageInfo_CSVCMsg_Broadcast_Command proto.InternalMessageInfo

func (m *CSVCMsg_Broadcast_Command) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

func init() {
	proto.RegisterEnum("NET_Messages", NET_Messages_name, NET_Messages_value)
	proto.RegisterEnum("CLC_Messages", CLC_Messages_name, CLC_Messages_value)
	proto.RegisterEnum("VoiceDataFormatT", VoiceDataFormatT_name, VoiceDataFormatT_value)
	proto.RegisterEnum("ESplitScreenMessageType", ESplitScreenMessageType_name, ESplitScreenMessageType_value)
	proto.RegisterEnum("SVC_Messages", SVC_Messages_name, SVC_Messages_value)
	proto.RegisterEnum("ReplayEventTypeT", ReplayEventTypeT_name, ReplayEventTypeT_value)
	proto.RegisterType((*CMsgVector)(nil), "CMsgVector")
	proto.RegisterType((*CMsgVector2D)(nil), "CMsgVector2D")
	proto.RegisterType((*CMsgQAngle)(nil), "CMsgQAngle")
	proto.RegisterType((*CMsgRGBA)(nil), "CMsgRGBA")
	proto.RegisterType((*CNETMsg_Tick)(nil), "CNETMsg_Tick")
	proto.RegisterType((*CNETMsg_StringCmd)(nil), "CNETMsg_StringCmd")
	proto.RegisterType((*CNETMsg_SignonState)(nil), "CNETMsg_SignonState")
	proto.RegisterType((*CMsg_CVars)(nil), "CMsg_CVars")
	proto.RegisterType((*CMsg_CVars_CVar)(nil), "CMsg_CVars.CVar")
	proto.RegisterType((*CNETMsg_SetConVar)(nil), "CNETMsg_SetConVar")
	proto.RegisterType((*CNETMsg_NOP)(nil), "CNETMsg_NOP")
	proto.RegisterType((*CNETMsg_Disconnect)(nil), "CNETMsg_Disconnect")
	proto.RegisterType((*CNETMsg_File)(nil), "CNETMsg_File")
	proto.RegisterType((*CNETMsg_SplitScreenUser)(nil), "CNETMsg_SplitScreenUser")
	proto.RegisterType((*CNETMsg_PlayerAvatarData)(nil), "CNETMsg_PlayerAvatarData")
	proto.RegisterType((*CCLCMsg_ClientInfo)(nil), "CCLCMsg_ClientInfo")
	proto.RegisterType((*CCLCMsg_Move)(nil), "CCLCMsg_Move")
	proto.RegisterType((*CCLCMsg_VoiceData)(nil), "CCLCMsg_VoiceData")
	proto.RegisterType((*CCLCMsg_BaselineAck)(nil), "CCLCMsg_BaselineAck")
	proto.RegisterType((*CCLCMsg_ListenEvents)(nil), "CCLCMsg_ListenEvents")
	proto.RegisterType((*CCLCMsg_RespondCvarValue)(nil), "CCLCMsg_RespondCvarValue")
	proto.RegisterType((*CCLCMsg_FileCRCCheck)(nil), "CCLCMsg_FileCRCCheck")
	proto.RegisterType((*CCLCMsg_LoadingProgress)(nil), "CCLCMsg_LoadingProgress")
	proto.RegisterType((*CCLCMsg_SplitPlayerConnect)(nil), "CCLCMsg_SplitPlayerConnect")
	proto.RegisterType((*CCLCMsg_CmdKeyValues)(nil), "CCLCMsg_CmdKeyValues")
	proto.RegisterType((*CSVCMsg_ServerInfo)(nil), "CSVCMsg_ServerInfo")
	proto.RegisterType((*CSVCMsg_ClassInfo)(nil), "CSVCMsg_ClassInfo")
	proto.RegisterType((*CSVCMsg_ClassInfoClassT)(nil), "CSVCMsg_ClassInfo.class_t")
	proto.RegisterType((*CSVCMsg_SendTable)(nil), "CSVCMsg_SendTable")
	proto.RegisterType((*CSVCMsg_SendTableSendpropT)(nil), "CSVCMsg_SendTable.sendprop_t")
	proto.RegisterType((*CSVCMsg_Print)(nil), "CSVCMsg_Print")
	proto.RegisterType((*CSVCMsg_SetPause)(nil), "CSVCMsg_SetPause")
	proto.RegisterType((*CSVCMsg_SetView)(nil), "CSVCMsg_SetView")
	proto.RegisterType((*CSVCMsg_CreateStringTable)(nil), "CSVCMsg_CreateStringTable")
	proto.RegisterType((*CSVCMsg_UpdateStringTable)(nil), "CSVCMsg_UpdateStringTable")
	proto.RegisterType((*CSVCMsg_VoiceInit)(nil), "CSVCMsg_VoiceInit")
	proto.RegisterType((*CSVCMsg_VoiceData)(nil), "CSVCMsg_VoiceData")
	proto.RegisterType((*CSVCMsg_FixAngle)(nil), "CSVCMsg_FixAngle")
	proto.RegisterType((*CSVCMsg_CrosshairAngle)(nil), "CSVCMsg_CrosshairAngle")
	proto.RegisterType((*CSVCMsg_Prefetch)(nil), "CSVCMsg_Prefetch")
	proto.RegisterType((*CSVCMsg_BSPDecal)(nil), "CSVCMsg_BSPDecal")
	proto.RegisterType((*CSVCMsg_SplitScreen)(nil), "CSVCMsg_SplitScreen")
	proto.RegisterType((*CSVCMsg_GetCvarValue)(nil), "CSVCMsg_GetCvarValue")
	proto.RegisterType((*CSVCMsg_Menu)(nil), "CSVCMsg_Menu")
	proto.RegisterType((*CSVCMsg_UserMessage)(nil), "CSVCMsg_UserMessage")
	proto.RegisterType((*CSVCMsg_PaintmapData)(nil), "CSVCMsg_PaintmapData")
	proto.RegisterType((*CSVCMsg_GameEvent)(nil), "CSVCMsg_GameEvent")
	proto.RegisterType((*CSVCMsg_GameEventKeyT)(nil), "CSVCMsg_GameEvent.key_t")
	proto.RegisterType((*CSVCMsg_GameEventList)(nil), "CSVCMsg_GameEventList")
	proto.RegisterType((*CSVCMsg_GameEventListKeyT)(nil), "CSVCMsg_GameEventList.key_t")
	proto.RegisterType((*CSVCMsg_GameEventListDescriptorT)(nil), "CSVCMsg_GameEventList.descriptor_t")
	proto.RegisterType((*CSVCMsg_TempEntities)(nil), "CSVCMsg_TempEntities")
	proto.RegisterType((*CSVCMsg_PacketEntities)(nil), "CSVCMsg_PacketEntities")
	proto.RegisterType((*CSVCMsg_Sounds)(nil), "CSVCMsg_Sounds")
	proto.RegisterType((*CSVCMsg_SoundsSounddataT)(nil), "CSVCMsg_Sounds.sounddata_t")
	proto.RegisterType((*CSVCMsg_EntityMsg)(nil), "CSVCMsg_EntityMsg")
	proto.RegisterType((*CSVCMsg_CmdKeyValues)(nil), "CSVCMsg_CmdKeyValues")
	proto.RegisterType((*CSVCMsg_EncryptedData)(nil), "CSVCMsg_EncryptedData")
	proto.RegisterType((*CSVCMsg_HltvReplay)(nil), "CSVCMsg_HltvReplay")
	proto.RegisterType((*CCLCMsg_HltvReplay)(nil), "CCLCMsg_HltvReplay")
	proto.RegisterType((*CSVCMsg_Broadcast_Command)(nil), "CSVCMsg_Broadcast_Command")
}

func init() { proto.RegisterFile("netmessages.proto", fileDescriptor_52cbc162d33bb4fa) }

var fileDescriptor_52cbc162d33bb4fa = []byte{
	// 4373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x7a, 0x4d, 0x6c, 0x24, 0x49,
	0x56, 0x7f, 0x57, 0xf9, 0xa3, 0xca, 0x51, 0x65, 0x3b, 0x1d, 0xee, 0x8f, 0x1a, 0xcf, 0xb6, 0xbb,
	0x3b, 0xfb, 0x3f, 0x33, 0x3d, 0xfd, 0x9f, 0xf1, 0x8e, 0xba, 0x67, 0x86, 0xa5, 0x47, 0x7b, 0xb0,
	0xcb, 0xe5, 0x6e, 0x6b, 0x6d, 0xb7, 0xb7, 0xaa, 0xda, 0xc3, 0x8c, 0x90, 0x42, 0xe1, 0xcc, 0x70,
	0x39, 0xe5, 0xfc, 0xa8, 0xcd, 0x88, 0x2a, 0xbb, 0x46, 0x42, 0x70, 0x82, 0x1b, 0xe2, 0x00, 0x42,
	0x48, 0x48, 0xc0, 0x09, 0x09, 0x71, 0x06, 0x21, 0x24, 0xce, 0x7b, 0xdc, 0x23, 0xa7, 0x65, 0x35,
	0x73, 0x42, 0xe2, 0x84, 0x40, 0x70, 0x03, 0xbd, 0x17, 0x19, 0x99, 0x91, 0x55, 0xf6, 0xec, 0x2c,
	0x70, 0xb1, 0x5c, 0xbf, 0xf7, 0x8b, 0xc8, 0x88, 0x17, 0x2f, 0xde, 0x57, 0x26, 0x59, 0x8b, 0x85,
	0x8a, 0x84, 0x94, 0x7c, 0x20, 0xe4, 0xd6, 0x30, 0x4d, 0x54, 0xb2, 0xf1, 0x70, 0x90, 0x24, 0x83,
	0x50, 0x7c, 0x1f, 0x7f, 0x9d, 0x8e, 0xce, 0xbe, 0xef, 0x0b, 0xe9, 0xa5, 0xc1, 0x50, 0x25, 0xa9,
	0x66, 0xb8, 0xaf, 0x08, 0x69, 0x1f, 0xca, 0xc1, 0x89, 0xf0, 0x54, 0x92, 0x52, 0x4a, 0x2a, 0x57,
	0xad, 0xca, 0xc3, 0xca, 0x93, 0xea, 0xce, 0xfc, 0x4f, 0x7f, 0xfe, 0xe0, 0x56, 0xb7, 0x72, 0x05,
	0xd8, 0xa4, 0x55, 0xb5, 0xb1, 0x09, 0x60, 0x5f, 0xb5, 0xe6, 0x6c, 0xec, 0x2b, 0xf7, 0x53, 0xd2,
	0x2c, 0x66, 0x7a, 0xb6, 0xfb, 0x5d, 0xe7, 0x32, 0x2b, 0xf8, 0xf1, 0x76, 0x3c, 0x08, 0xc5, 0xff,
	0x6a, 0x05, 0x5f, 0x92, 0x3a, 0xcc, 0xd4, 0x7d, 0xb9, 0xb3, 0x0d, 0xf2, 0x14, 0xe7, 0x59, 0x30,
	0x72, 0xdc, 0xdd, 0x00, 0xe7, 0xc9, 0xb1, 0x01, 0x60, 0xa7, 0x38, 0x4f, 0x8e, 0x9d, 0x02, 0xc6,
	0x5b, 0xf3, 0x36, 0xc6, 0xdd, 0xbf, 0xad, 0x92, 0x66, 0xfb, 0xa8, 0xd3, 0x3f, 0x94, 0x03, 0xd6,
	0x0f, 0xbc, 0x0b, 0xda, 0x22, 0xf3, 0x2a, 0xf0, 0x2e, 0xf0, 0x19, 0xcb, 0x19, 0x0f, 0x11, 0xfa,
	0x6b, 0xe4, 0xf6, 0x79, 0x22, 0x15, 0xf3, 0x92, 0x68, 0x38, 0x52, 0x5c, 0x05, 0x49, 0xac, 0x82,
	0x48, 0xe0, 0x8c, 0x86, 0xb9, 0x0e, 0x8c, 0x76, 0x99, 0x40, 0x7f, 0x4c, 0xdc, 0xeb, 0x06, 0x32,
	0xa9, 0x7c, 0xe6, 0x8b, 0x71, 0x80, 0x48, 0x6b, 0xc1, 0x9a, 0xe6, 0xc1, 0x35, 0xd3, 0xf4, 0x94,
	0xbf, 0x6b, 0xc8, 0xf4, 0x35, 0x79, 0x84, 0x53, 0x9e, 0xa5, 0x3c, 0x12, 0x52, 0xf1, 0x54, 0x5d,
	0x33, 0xe3, 0xa2, 0x35, 0xe3, 0x26, 0xd0, 0xf7, 0x4a, 0xec, 0xd2, 0x84, 0x1f, 0x91, 0xb5, 0xf3,
	0x50, 0x8d, 0x59, 0x2a, 0x86, 0x21, 0x9f, 0xb0, 0xb3, 0x90, 0x0f, 0x64, 0xab, 0x66, 0x4d, 0xb0,
	0x0a, 0xe2, 0x2e, 0x4a, 0xf7, 0x40, 0xe8, 0x3e, 0x27, 0x6b, 0x46, 0x71, 0x3d, 0x95, 0x06, 0xf1,
	0xa0, 0x1d, 0xf9, 0x74, 0x93, 0xd4, 0xbc, 0x24, 0x8a, 0x78, 0xec, 0xa3, 0x02, 0x97, 0xb2, 0xc1,
	0x06, 0x74, 0xff, 0xb9, 0x42, 0xd6, 0xf3, 0x51, 0xc1, 0x20, 0x4e, 0xe2, 0x9e, 0xe2, 0x4a, 0xd0,
	0xf7, 0x48, 0x53, 0xe2, 0x4f, 0x26, 0xe1, 0x77, 0x49, 0xfb, 0x0d, 0x69, 0x11, 0xdf, 0x21, 0x0d,
	0x39, 0xe4, 0x97, 0x31, 0xf3, 0x92, 0x51, 0xac, 0xf0, 0xd4, 0x0d, 0x8f, 0xa0, 0xa0, 0x0d, 0x38,
	0x7d, 0x46, 0x68, 0x3c, 0x8a, 0x98, 0x14, 0xe9, 0x58, 0xa4, 0x0c, 0x16, 0x2d, 0x52, 0x89, 0xf6,
	0x60, 0xd8, 0x4e, 0x3c, 0x8a, 0x7a, 0x28, 0x3e, 0xd6, 0x52, 0xfa, 0x21, 0xa1, 0x19, 0x91, 0xc5,
	0x42, 0x5d, 0x26, 0xe9, 0x45, 0xe0, 0xcb, 0xd6, 0xfc, 0xc3, 0xb9, 0x27, 0x4b, 0xdd, 0xb5, 0x4c,
	0x72, 0x94, 0x0b, 0xe8, 0x03, 0x52, 0x8f, 0xf8, 0x90, 0xc5, 0x3c, 0x12, 0x78, 0x76, 0xf9, 0x5e,
	0x23, 0x3e, 0x3c, 0xe2, 0x91, 0x70, 0xff, 0xa2, 0xa2, 0x6f, 0x00, 0x6b, 0x9f, 0xf0, 0x54, 0xd2,
	0x77, 0xc9, 0x82, 0x37, 0xe6, 0xa9, 0x6c, 0x55, 0x1e, 0xce, 0x3d, 0x69, 0x3c, 0x73, 0xb6, 0x0a,
	0xd9, 0x16, 0xfc, 0xed, 0x6a, 0xf1, 0xc6, 0x05, 0x99, 0x87, 0x9f, 0x60, 0x88, 0x38, 0xb7, 0xad,
	0x47, 0x44, 0xe8, 0x06, 0x59, 0x18, 0xf3, 0x70, 0x24, 0x70, 0xf7, 0x46, 0xa4, 0x21, 0xfa, 0x21,
	0x59, 0xf5, 0x03, 0x0f, 0x8e, 0x94, 0xa7, 0x13, 0xbd, 0x38, 0x7b, 0xd7, 0x2b, 0x85, 0x10, 0xd7,
	0xf8, 0xc2, 0x3a, 0x44, 0xa1, 0xda, 0x49, 0x0c, 0x4f, 0x7e, 0x07, 0x0e, 0x31, 0xce, 0xd6, 0x5a,
	0x79, 0xd2, 0x78, 0xd6, 0xb0, 0xd6, 0xda, 0x35, 0x32, 0x77, 0x99, 0x34, 0xcc, 0xd8, 0xa3, 0xd7,
	0xc7, 0xee, 0x16, 0xa1, 0xe6, 0xe7, 0x6e, 0x20, 0xbd, 0x24, 0x8e, 0x85, 0xa7, 0xf0, 0x3a, 0x89,
	0x2b, 0x55, 0xde, 0x05, 0x20, 0xee, 0x5f, 0x56, 0x8a, 0x9b, 0xb7, 0x17, 0x84, 0x78, 0xb4, 0x2a,
	0xe5, 0xb1, 0x3c, 0x13, 0x29, 0x0b, 0xfc, 0xd2, 0x25, 0x27, 0x46, 0xb0, 0xef, 0xd3, 0x47, 0x64,
	0xe9, 0x2c, 0x08, 0x85, 0xde, 0x9b, 0xad, 0x81, 0x3a, 0xc0, 0xb0, 0x2b, 0xfa, 0x9c, 0xac, 0x07,
	0xd2, 0x98, 0xb2, 0x2f, 0xa2, 0x84, 0x81, 0x08, 0x15, 0x51, 0x37, 0xc7, 0x1f, 0x48, 0x6d, 0xcc,
	0xbb, 0x22, 0x4a, 0xf0, 0xf1, 0x2d, 0x32, 0xef, 0x8b, 0x78, 0x82, 0xd7, 0xd9, 0xb0, 0x10, 0x71,
	0x9f, 0x93, 0x7b, 0xb9, 0x92, 0x86, 0x61, 0xa0, 0x7a, 0x5e, 0x2a, 0x44, 0xfc, 0x46, 0x0a, 0x3c,
	0x24, 0x19, 0x26, 0xaa, 0xb4, 0x58, 0x44, 0xdc, 0x13, 0xd2, 0x32, 0x83, 0xb4, 0x81, 0x6d, 0x8f,
	0xb9, 0xe2, 0xe9, 0x2e, 0x57, 0x9c, 0xba, 0x64, 0x89, 0x7b, 0x68, 0xc0, 0xd9, 0x3e, 0xcd, 0xf1,
	0x14, 0x30, 0xbd, 0x4b, 0xe6, 0xd2, 0xc1, 0x29, 0x6e, 0xb0, 0x99, 0x49, 0x01, 0x70, 0xff, 0xb4,
	0x4a, 0x68, 0xbb, 0x7d, 0xa0, 0x0f, 0x24, 0x0c, 0x44, 0xac, 0xf6, 0xe3, 0xb3, 0x84, 0x3e, 0x25,
	0x2b, 0x52, 0xc4, 0x3e, 0x53, 0xfc, 0x34, 0x14, 0xcc, 0x4b, 0x3d, 0x9c, 0xb7, 0x96, 0x8d, 0x6c,
	0x82, 0xac, 0x0f, 0xa2, 0x76, 0xea, 0xe1, 0x65, 0xd3, 0x17, 0x63, 0xf6, 0x12, 0x35, 0xb4, 0x44,
	0xdf, 0xa2, 0xfb, 0xa4, 0x16, 0x48, 0x06, 0x17, 0xbf, 0xa4, 0xbb, 0xc5, 0x40, 0xbe, 0x0a, 0xd5,
	0x18, 0x4e, 0x22, 0x57, 0x73, 0x49, 0x6d, 0x75, 0xa3, 0x5c, 0xfa, 0x98, 0x90, 0xb3, 0x34, 0x10,
	0xb1, 0x2f, 0xe1, 0x48, 0x6d, 0x17, 0xb7, 0x94, 0xe1, 0xfb, 0x3e, 0xac, 0xc7, 0x90, 0xf0, 0x50,
	0x17, 0xad, 0x43, 0x6d, 0x64, 0x12, 0x3c, 0xd7, 0x47, 0xa4, 0xe9, 0x8d, 0xa4, 0x4a, 0x22, 0x3c,
	0x4f, 0xf0, 0x4f, 0x73, 0x4f, 0x6a, 0xdd, 0x86, 0xc6, 0xe0, 0x10, 0xa5, 0xfb, 0xfb, 0x60, 0x55,
	0x99, 0x7a, 0x0e, 0x93, 0xb1, 0xa0, 0x1f, 0x93, 0x75, 0xf0, 0x04, 0xa7, 0xdc, 0xbb, 0x18, 0x0d,
	0x59, 0xe6, 0x87, 0x64, 0x49, 0xeb, 0x6b, 0xf1, 0x28, 0xda, 0x41, 0x79, 0x3b, 0x13, 0xd3, 0x2d,
	0x02, 0xfe, 0x81, 0xc5, 0xe2, 0xb2, 0x18, 0x62, 0xab, 0x69, 0x25, 0x1e, 0x45, 0x47, 0xe2, 0x32,
	0xe7, 0x83, 0xf1, 0x70, 0xc5, 0x51, 0x4d, 0xcd, 0xdc, 0x78, 0xb8, 0xe2, 0xee, 0x5f, 0x55, 0xc9,
	0x9a, 0x59, 0xd0, 0x49, 0x12, 0x78, 0x02, 0x2d, 0xc0, 0xf0, 0x2b, 0xd3, 0x7c, 0x90, 0x5c, 0x8d,
	0x02, 0x1f, 0x9f, 0xb6, 0x68, 0x24, 0x80, 0xd0, 0x36, 0x59, 0x3c, 0x4b, 0xd2, 0x88, 0x2b, 0x7c,
	0xca, 0xca, 0x33, 0xba, 0x95, 0xcf, 0xb7, 0x87, 0x38, 0x53, 0x2f, 0xee, 0x9d, 0xbc, 0xde, 0x6f,
	0x77, 0x76, 0xb7, 0xfb, 0xdb, 0x6c, 0xef, 0x75, 0xf7, 0x70, 0xbb, 0xcf, 0x3a, 0x47, 0x2f, 0xf7,
	0x8f, 0x3a, 0xdd, 0x6c, 0x28, 0xfd, 0xff, 0x60, 0x27, 0x3f, 0x19, 0x89, 0xd8, 0x13, 0xec, 0x74,
	0xa2, 0x84, 0x2c, 0x05, 0xc4, 0x65, 0x23, 0xdb, 0x01, 0x91, 0x26, 0xa3, 0xbf, 0x60, 0xf1, 0x28,
	0x3a, 0x15, 0x69, 0xe9, 0x04, 0x97, 0x33, 0xd9, 0x11, 0x8a, 0xe8, 0x0e, 0xd9, 0x18, 0xc5, 0x10,
	0xe2, 0x52, 0x21, 0xa5, 0xf0, 0x99, 0xe4, 0xd1, 0x30, 0x14, 0x2c, 0x39, 0x3b, 0x93, 0x42, 0x95,
	0x62, 0x51, 0xcb, 0xe6, 0xf5, 0x90, 0xf6, 0x1a, 0x59, 0xee, 0x80, 0xac, 0x1b, 0x5d, 0xed, 0x70,
	0x29, 0xc2, 0x20, 0x16, 0xdb, 0xde, 0x05, 0x7d, 0x9f, 0x2c, 0x9f, 0x66, 0x3f, 0x59, 0x1e, 0x9c,
	0xcd, 0x9a, 0x9b, 0x46, 0x84, 0xe1, 0xfb, 0x1d, 0xd2, 0xc8, 0xa9, 0x71, 0x5a, 0xca, 0x0a, 0x88,
	0x11, 0x1c, 0xa5, 0xee, 0x27, 0xe4, 0xb6, 0x79, 0xd0, 0x41, 0x20, 0x95, 0x88, 0x3b, 0x63, 0x11,
	0x2b, 0x49, 0xef, 0x13, 0x22, 0xe0, 0x3f, 0x16, 0x71, 0x79, 0x81, 0x9e, 0xba, 0xd6, 0x5d, 0x42,
	0xe4, 0x90, 0xcb, 0x0b, 0xf7, 0x8f, 0x2a, 0xa4, 0x65, 0xc6, 0x75, 0x85, 0x1c, 0x26, 0xb1, 0xdf,
	0x1e, 0xf3, 0xf4, 0x04, 0x5d, 0xef, 0xf7, 0xc8, 0xa2, 0x97, 0x24, 0x17, 0x81, 0x28, 0x2d, 0x2f,
	0xc3, 0x30, 0x70, 0x29, 0xae, 0x46, 0x92, 0x79, 0x89, 0x2f, 0xca, 0x0b, 0xd3, 0x82, 0x76, 0xe2,
	0x8b, 0xdc, 0xeb, 0xcf, 0xdd, 0xec, 0xf5, 0xe7, 0x67, 0xbc, 0xbe, 0xfb, 0xe7, 0x73, 0xc5, 0x7e,
	0xe0, 0x1e, 0xb4, 0xbb, 0xed, 0xf6, 0xb9, 0xf0, 0x2e, 0xe0, 0x8a, 0xc2, 0xe3, 0xd8, 0x90, 0xab,
	0xf3, 0xd2, 0xb2, 0xea, 0x00, 0x1f, 0x73, 0x75, 0x0e, 0x4f, 0x44, 0xa9, 0xed, 0x4a, 0x11, 0x01,
	0xb5, 0xe3, 0x60, 0xb8, 0x6c, 0xf9, 0xa2, 0x72, 0xb5, 0x83, 0x68, 0x2f, 0x93, 0xd0, 0x87, 0xa4,
	0x9e, 0xb3, 0xe6, 0xa7, 0x7d, 0x32, 0x32, 0xde, 0x27, 0xcb, 0xe8, 0xb6, 0xcf, 0x52, 0xee, 0xe5,
	0xf9, 0x4e, 0x3e, 0x19, 0x88, 0xf6, 0x32, 0x09, 0xb8, 0xbe, 0xc8, 0xff, 0x04, 0x4d, 0x26, 0x77,
	0x7d, 0x91, 0xff, 0x09, 0xe0, 0xe0, 0xd8, 0xec, 0xac, 0x04, 0x00, 0xf0, 0x7d, 0x38, 0xf5, 0x39,
	0x97, 0xe7, 0x4c, 0x4d, 0x86, 0xa2, 0x55, 0x9f, 0x9e, 0xfb, 0x15, 0x97, 0xe7, 0xfd, 0xc9, 0x50,
	0x40, 0xd4, 0x46, 0x6e, 0x28, 0xe2, 0xd6, 0x92, 0xc5, 0xaa, 0x01, 0x7a, 0x20, 0x62, 0xfa, 0x2e,
	0x69, 0x0e, 0xb9, 0x77, 0x81, 0x9b, 0x06, 0x9f, 0x45, 0xec, 0x83, 0x02, 0x09, 0xec, 0x79, 0xdf,
	0x07, 0x0f, 0x51, 0xf0, 0xb2, 0xdb, 0xd1, 0xb0, 0xb8, 0x2b, 0x86, 0xab, 0xaf, 0x87, 0xfb, 0x19,
	0xb9, 0x97, 0x5b, 0x5c, 0xc2, 0xfd, 0x20, 0x1e, 0x1c, 0xa7, 0xc9, 0x00, 0xee, 0x00, 0x28, 0x6f,
	0x98, 0xfd, 0x5f, 0x3e, 0x23, 0x83, 0xba, 0x6d, 0xb2, 0x61, 0x06, 0x63, 0x04, 0xd2, 0x11, 0xa5,
	0x9d, 0xc5, 0xd8, 0xef, 0x18, 0xaf, 0x5f, 0x14, 0x36, 0xd2, 0x8e, 0xfc, 0x1f, 0x89, 0x09, 0x9a,
	0xad, 0x84, 0x68, 0x74, 0x21, 0x26, 0x68, 0x48, 0xb2, 0xe4, 0x90, 0x0a, 0xd8, 0xfd, 0x8f, 0x45,
	0x42, 0xdb, 0xbd, 0x13, 0xbd, 0x02, 0x8c, 0x10, 0x18, 0x75, 0xf4, 0xca, 0x55, 0xe2, 0x25, 0xe1,
	0xcc, 0xca, 0x11, 0xbd, 0x36, 0xd6, 0x2c, 0x5c, 0x17, 0x6b, 0xde, 0x23, 0xcd, 0x40, 0x32, 0x5f,
	0xf8, 0x81, 0xc7, 0x95, 0xf0, 0x4b, 0x01, 0xa7, 0x11, 0xc8, 0x5d, 0x23, 0xa0, 0x3f, 0x24, 0xad,
	0x40, 0x82, 0x5b, 0x09, 0xbc, 0x80, 0x87, 0x6c, 0xcc, 0xc3, 0xb1, 0xc8, 0x12, 0xbd, 0x52, 0x10,
	0xba, 0x13, 0xc8, 0xd7, 0x19, 0xe9, 0x04, 0x38, 0x7a, 0xd9, 0x76, 0x4c, 0x5b, 0xf8, 0x65, 0x31,
	0x6d, 0xf1, 0xda, 0x98, 0xb6, 0x47, 0xee, 0x23, 0xc5, 0x0f, 0x52, 0x70, 0x80, 0xf1, 0x80, 0xa9,
	0x84, 0x0d, 0xd3, 0xe4, 0x6a, 0xc2, 0x52, 0x01, 0xc3, 0xee, 0x58, 0xc3, 0xde, 0x82, 0x61, 0x39,
	0xb3, 0x9f, 0x1c, 0x03, 0xaf, 0x0b, 0x34, 0x7a, 0x8f, 0xcc, 0x7b, 0x2c, 0xd1, 0x59, 0xf6, 0x42,
	0x6e, 0xcf, 0xaf, 0xc1, 0x09, 0x41, 0x0e, 0x89, 0x41, 0xbc, 0x6e, 0x05, 0xf1, 0xc5, 0x88, 0x0f,
	0x21, 0x7c, 0x3f, 0x26, 0xc4, 0xc3, 0xc0, 0x8f, 0x8c, 0x25, 0x8b, 0xb1, 0xa4, 0x71, 0x20, 0x6d,
	0x11, 0x47, 0x62, 0x56, 0x6e, 0x65, 0x04, 0xc4, 0xa2, 0xae, 0x68, 0x69, 0x9e, 0x13, 0xbc, 0x43,
	0x1a, 0x11, 0xbf, 0x62, 0x7a, 0x02, 0x59, 0xb2, 0x64, 0x12, 0xf1, 0x2b, 0x9d, 0x69, 0xc8, 0x82,
	0xc6, 0xa5, 0x14, 0xb2, 0xd5, 0x9c, 0xa1, 0x21, 0x0e, 0x34, 0x9d, 0x30, 0x33, 0xcc, 0x8e, 0x96,
	0x4b, 0x77, 0x08, 0x05, 0xbd, 0x30, 0x51, 0xe0, 0x13, 0xc0, 0x9d, 0xb3, 0x20, 0x56, 0x22, 0x1d,
	0xf3, 0xb0, 0xb5, 0x62, 0x15, 0x7e, 0x4d, 0x10, 0xed, 0x67, 0x12, 0xb8, 0xb7, 0x03, 0x1e, 0x09,
	0xe6, 0x07, 0x69, 0x6b, 0xd5, 0xce, 0xb6, 0x01, 0xdd, 0x0d, 0xd2, 0x52, 0x3a, 0xee, 0x5c, 0x93,
	0x8e, 0x83, 0x97, 0x00, 0xc2, 0x20, 0x4d, 0x46, 0x19, 0x6d, 0xcd, 0xa2, 0x35, 0x23, 0x3e, 0x7c,
	0x09, 0x22, 0xe4, 0x3e, 0x20, 0x75, 0x79, 0x91, 0xa5, 0xcf, 0xd4, 0x9e, 0x4c, 0x5e, 0x4c, 0xb2,
	0x4c, 0x64, 0x09, 0xeb, 0x2f, 0x64, 0xac, 0xdb, 0x0e, 0x0f, 0x60, 0x43, 0x19, 0x8e, 0x4e, 0xc3,
	0xc0, 0x63, 0xc1, 0xb0, 0x75, 0xdb, 0xf2, 0x59, 0x75, 0x0d, 0xef, 0x0f, 0xa9, 0x4b, 0xc8, 0x68,
	0xe0, 0x31, 0x58, 0x56, 0xe0, 0xb7, 0xee, 0x3e, 0xac, 0x3c, 0x99, 0x37, 0x9c, 0xd1, 0xc0, 0x3b,
	0xe4, 0xc3, 0x7d, 0xdf, 0xfd, 0xcf, 0x0a, 0x59, 0x33, 0x37, 0x0f, 0xd5, 0x8b, 0x17, 0x6f, 0x8b,
	0x38, 0x5e, 0x2a, 0xb8, 0x12, 0x2c, 0x89, 0xb3, 0x43, 0xc3, 0x0b, 0x68, 0xcc, 0x6e, 0x45, 0x4b,
	0x5f, 0xc7, 0xfa, 0xe0, 0xe8, 0xc7, 0xa4, 0x66, 0xce, 0xac, 0x8a, 0xe5, 0xc7, 0xc6, 0xd6, 0xcc,
	0xa4, 0x5b, 0xc8, 0x60, 0xaa, 0x6b, 0xa8, 0x1b, 0xbf, 0x95, 0x8d, 0x62, 0x0a, 0x34, 0xa2, 0xff,
	0x9d, 0xca, 0xcc, 0x35, 0x61, 0xdf, 0xa7, 0x1f, 0x90, 0x55, 0xc8, 0x5f, 0x32, 0x73, 0x9b, 0x49,
	0xce, 0x97, 0x41, 0x88, 0xd6, 0x86, 0xca, 0x41, 0x1b, 0x86, 0xe9, 0x66, 0x82, 0xdd, 0x12, 0xe2,
	0x58, 0x9c, 0xfc, 0xfb, 0x5c, 0xb1, 0xf5, 0x9e, 0x49, 0x60, 0xe9, 0xdb, 0x64, 0x31, 0x90, 0x4c,
	0x64, 0x15, 0xa6, 0xd9, 0xf0, 0x42, 0x20, 0x3b, 0xb1, 0x0f, 0x87, 0x1c, 0x0b, 0x75, 0xd3, 0x22,
	0x9a, 0xb1, 0x50, 0xc5, 0x1a, 0xde, 0x27, 0xcb, 0xb1, 0x10, 0x3e, 0x38, 0x1d, 0x88, 0x65, 0x69,
	0xc9, 0xe5, 0x34, 0x51, 0xb4, 0xab, 0x25, 0xf4, 0x39, 0x59, 0x18, 0xa6, 0xc9, 0x50, 0x57, 0x83,
	0x8d, 0x67, 0xf7, 0xb7, 0x66, 0x96, 0xb5, 0x05, 0x19, 0x36, 0x70, 0x98, 0xea, 0x6a, 0xee, 0xc6,
	0xdf, 0x54, 0x09, 0x29, 0x50, 0xac, 0x84, 0x20, 0x36, 0x95, 0x4a, 0x05, 0x95, 0xc5, 0xa4, 0x31,
	0x4f, 0x67, 0x97, 0x5b, 0x1b, 0xf3, 0xf4, 0x28, 0x0b, 0xfd, 0xba, 0x20, 0xb7, 0x03, 0xb0, 0x86,
	0xb4, 0x0b, 0x0e, 0x92, 0x34, 0x50, 0x93, 0x52, 0x2a, 0x97, 0xa3, 0xe0, 0x4e, 0x7c, 0x35, 0x5b,
	0xa7, 0x2e, 0xfa, 0xda, 0x4e, 0xdf, 0x23, 0x4d, 0x48, 0x75, 0x45, 0x28, 0x22, 0xbc, 0xfa, 0x8b,
	0xb6, 0x87, 0x8e, 0x47, 0x51, 0x27, 0x13, 0x80, 0x41, 0x87, 0xc9, 0x25, 0xd3, 0x49, 0x48, 0xcd,
	0xba, 0xa9, 0xf5, 0x30, 0xb9, 0xd4, 0x29, 0xd0, 0x63, 0x42, 0xce, 0x83, 0xc1, 0x79, 0xc6, 0xa9,
	0x5b, 0x9c, 0x25, 0xc0, 0x35, 0xe9, 0x01, 0xa9, 0x63, 0x46, 0x1e, 0x28, 0x59, 0x0e, 0xc1, 0x90,
	0x86, 0x07, 0x4a, 0xba, 0xef, 0x93, 0x65, 0xa3, 0xdf, 0xe3, 0x34, 0x88, 0xbf, 0xad, 0x88, 0xfc,
	0x88, 0x38, 0xc5, 0x51, 0xa8, 0x63, 0x3e, 0x92, 0x98, 0x87, 0x0d, 0xe1, 0x9f, 0xb2, 0x81, 0x64,
	0x98, 0xfb, 0x82, 0xac, 0x5a, 0x23, 0x4e, 0x02, 0x71, 0x09, 0x1a, 0x10, 0xb1, 0x0a, 0xd4, 0x84,
	0x05, 0xb1, 0x2f, 0xae, 0x4a, 0x27, 0xd4, 0xd0, 0x92, 0x7d, 0x10, 0xb8, 0x3f, 0xaf, 0x92, 0xb7,
	0xf2, 0x6b, 0x83, 0x17, 0xac, 0x57, 0x78, 0xd1, 0x6f, 0x29, 0xd8, 0x33, 0xaf, 0x29, 0x62, 0x95,
	0x06, 0x42, 0x96, 0x73, 0xbf, 0x88, 0x5f, 0x75, 0x34, 0x0e, 0x34, 0x3c, 0x89, 0x8c, 0x66, 0x1f,
	0x36, 0x81, 0x83, 0xc8, 0x68, 0x9f, 0x90, 0xdb, 0x23, 0x29, 0x52, 0x86, 0xd7, 0xed, 0x2c, 0xb8,
	0x82, 0x5c, 0x3b, 0xf8, 0x4a, 0x94, 0x82, 0xdf, 0x1a, 0x30, 0xb0, 0x32, 0x00, 0x79, 0x2f, 0xf8,
	0x0a, 0xfd, 0x5f, 0x31, 0x0c, 0x07, 0x94, 0x32, 0x30, 0x33, 0x00, 0xb9, 0xcf, 0xc9, 0x7a, 0x99,
	0xab, 0x4f, 0xcb, 0x36, 0x0d, 0xc7, 0x1e, 0x00, 0xc7, 0x56, 0x58, 0x69, 0x6d, 0xd6, 0x4a, 0x31,
	0xfb, 0xc5, 0x70, 0x84, 0x65, 0x4f, 0xdd, 0xca, 0x32, 0x88, 0x16, 0xc0, 0x54, 0xee, 0x9f, 0x54,
	0x0a, 0x05, 0xbf, 0x19, 0xfa, 0x53, 0x0a, 0x7e, 0x40, 0xea, 0xfa, 0x62, 0x4f, 0xfb, 0x20, 0x44,
	0xf7, 0x7d, 0x53, 0xeb, 0x79, 0xe7, 0x3c, 0x1e, 0x08, 0xff, 0x5a, 0x7d, 0x43, 0xad, 0xd7, 0xd6,
	0x72, 0x4b, 0xed, 0xf6, 0xda, 0xe6, 0x6e, 0x58, 0x5b, 0x58, 0x38, 0x23, 0xac, 0xbb, 0xf6, 0xe3,
	0x40, 0xd1, 0x4d, 0x52, 0xfb, 0xc9, 0x88, 0x87, 0x70, 0xf9, 0x4a, 0x2b, 0xca, 0x40, 0xd0, 0x09,
	0x78, 0x10, 0xaf, 0xdc, 0xaa, 0x41, 0x88, 0xbe, 0x4d, 0x6a, 0x63, 0x91, 0x4a, 0xc8, 0x85, 0xf1,
	0xa8, 0x5f, 0x54, 0x3e, 0xea, 0x1a, 0xc4, 0xfd, 0x87, 0xb9, 0xa9, 0xc7, 0x61, 0xd9, 0x08, 0x25,
	0x46, 0xe1, 0xec, 0x8b, 0x12, 0x43, 0x3b, 0x79, 0x97, 0x2c, 0x41, 0x1a, 0x12, 0x44, 0xb0, 0x9c,
	0xaa, 0x65, 0x0d, 0x05, 0x9c, 0x97, 0x97, 0x73, 0x33, 0xe5, 0xe5, 0x7b, 0xa4, 0xc9, 0x47, 0x7e,
	0x00, 0xfa, 0xc5, 0xe2, 0xc7, 0x76, 0x26, 0x8d, 0x4c, 0x02, 0x45, 0x10, 0x5c, 0xf2, 0x31, 0xac,
	0x48, 0xab, 0x6b, 0xc1, 0x4e, 0x18, 0xc7, 0xa5, 0x95, 0x72, 0xa9, 0x44, 0x5a, 0x4a, 0xa2, 0x32,
	0xcc, 0x2a, 0x65, 0x6b, 0xff, 0x97, 0xa5, 0x6c, 0xfd, 0x57, 0x29, 0x65, 0x97, 0xfe, 0xa7, 0xa5,
	0x2c, 0xf9, 0x4e, 0xa5, 0xec, 0xe7, 0x85, 0x67, 0xda, 0x0b, 0xae, 0x74, 0x13, 0xfc, 0x21, 0xa9,
	0x43, 0x86, 0xa8, 0x82, 0xb1, 0x28, 0xf9, 0xa6, 0x1c, 0xa5, 0x8f, 0xc8, 0x02, 0x07, 0x2a, 0x1e,
	0x9f, 0x49, 0xe4, 0x75, 0x0b, 0xbd, 0xab, 0x25, 0xee, 0x67, 0xe4, 0x6e, 0xe1, 0x83, 0x12, 0x29,
	0xcf, 0x79, 0x90, 0xea, 0xe9, 0xf3, 0xc1, 0x95, 0x1b, 0x07, 0xff, 0x7a, 0xb1, 0xaa, 0xe3, 0x54,
	0x9c, 0x09, 0xe5, 0x9d, 0xa3, 0xfd, 0x27, 0xa3, 0xd8, 0xbf, 0xc6, 0xfb, 0x11, 0x14, 0x68, 0xe7,
	0xf7, 0x8b, 0x4a, 0x31, 0x76, 0xa7, 0x77, 0xbc, 0x2b, 0x3c, 0x1e, 0xd2, 0xfb, 0x64, 0x6e, 0x98,
	0x94, 0xcb, 0x0e, 0xfd, 0xa2, 0xa0, 0x0b, 0x38, 0x5c, 0x48, 0x1f, 0x78, 0x0c, 0x9c, 0xf5, 0x28,
	0x15, 0xd9, 0x23, 0x4a, 0x17, 0x12, 0x09, 0x7d, 0x2d, 0xc7, 0x27, 0xcd, 0xf8, 0xe3, 0xb9, 0x1b,
	0xfc, 0x31, 0xfa, 0xd5, 0xc4, 0x17, 0x61, 0xc6, 0x9b, 0x2f, 0xf9, 0x55, 0x10, 0xe4, 0xf3, 0x41,
	0xe0, 0xca, 0xc3, 0xa4, 0x9d, 0xf7, 0x37, 0xc2, 0xe4, 0xf2, 0x38, 0x13, 0xb8, 0x7f, 0x56, 0x21,
	0xeb, 0x79, 0x70, 0x28, 0x3a, 0x7d, 0xb4, 0x63, 0x85, 0xee, 0x95, 0x67, 0xad, 0xad, 0x8e, 0x25,
	0x3c, 0xd4, 0x6f, 0x66, 0xa0, 0xb8, 0x7c, 0x71, 0xef, 0xb0, 0xf7, 0x92, 0xf5, 0x8e, 0x0f, 0xf6,
	0xfb, 0xbd, 0x76, 0xb7, 0xd3, 0x39, 0x62, 0xdb, 0xbb, 0xbb, 0x6f, 0x7a, 0x9d, 0x6e, 0x16, 0xe7,
	0x4d, 0xb3, 0xb0, 0x3a, 0xdd, 0x2c, 0x84, 0x15, 0x66, 0xf9, 0xf2, 0x35, 0x3b, 0xd6, 0x12, 0x7d,
	0x08, 0x9f, 0x93, 0xdb, 0x66, 0x81, 0x2f, 0x85, 0xfa, 0xae, 0xbd, 0x87, 0x47, 0x64, 0xc9, 0xbb,
	0x36, 0xc3, 0xa8, 0x7b, 0x59, 0x8a, 0xe1, 0x7a, 0xa4, 0x69, 0x26, 0x3e, 0x14, 0xf1, 0x08, 0x54,
	0xeb, 0x07, 0x3c, 0x4c, 0x06, 0x6c, 0x26, 0x69, 0x21, 0x5a, 0x80, 0xe5, 0xf4, 0x07, 0x64, 0x35,
	0x12, 0xf1, 0x88, 0x5d, 0x88, 0x09, 0xcb, 0x2a, 0x48, 0xbb, 0x63, 0xb9, 0x0c, 0xc2, 0xbc, 0xd2,
	0x74, 0x7f, 0xbb, 0x50, 0xef, 0x1b, 0x29, 0xd2, 0x4c, 0x75, 0x98, 0xba, 0xcb, 0x6b, 0x1e, 0x54,
	0x8b, 0xe4, 0xc0, 0x14, 0xed, 0x40, 0x40, 0x7f, 0x63, 0x4f, 0x0f, 0x04, 0xf4, 0x36, 0xef, 0x92,
	0xc6, 0x90, 0x4b, 0xa9, 0xce, 0xd3, 0x64, 0x34, 0x38, 0x9f, 0x52, 0x5f, 0x21, 0x70, 0x7f, 0x50,
	0xa8, 0xef, 0x98, 0x07, 0xb1, 0x8a, 0xf8, 0x10, 0xc7, 0x43, 0x12, 0x95, 0xfd, 0x2e, 0x55, 0xc0,
	0x39, 0xea, 0xfe, 0x8b, 0xe5, 0x8f, 0x5f, 0xf2, 0x48, 0x60, 0xbf, 0x08, 0x5c, 0xa1, 0x6e, 0x17,
	0xcd, 0x04, 0x7e, 0xdd, 0x34, 0xc2, 0x04, 0x6b, 0x93, 0xd4, 0xf0, 0x47, 0xd6, 0xd4, 0xcb, 0x77,
	0x97, 0x81, 0xf4, 0x03, 0x32, 0x7f, 0x21, 0x26, 0x10, 0xef, 0x21, 0xb7, 0x6c, 0x6d, 0xcd, 0x3c,
	0x66, 0x0b, 0xb4, 0xab, 0xba, 0xc8, 0x9a, 0xde, 0xea, 0xfc, 0x0d, 0x5b, 0xdd, 0xf8, 0xfb, 0x2a,
	0x59, 0xc0, 0x71, 0xdf, 0x92, 0x78, 0x82, 0x27, 0xe7, 0x21, 0xd3, 0x41, 0xae, 0x64, 0x18, 0x4b,
	0x63, 0x1e, 0xea, 0xd0, 0x0b, 0xc6, 0x03, 0xa4, 0xb3, 0x30, 0xc9, 0x3a, 0x8f, 0x79, 0xda, 0x37,
	0xe6, 0xe1, 0x1e, 0xa0, 0x3a, 0x81, 0x0d, 0x59, 0x98, 0xc4, 0x83, 0xd2, 0x82, 0x6a, 0x63, 0x1e,
	0x1e, 0x24, 0xc5, 0x1c, 0xf2, 0x3c, 0x49, 0x55, 0x29, 0xed, 0x80, 0x71, 0x3d, 0x40, 0xcd, 0x1c,
	0xe0, 0xc8, 0x4b, 0x79, 0x06, 0xcc, 0x01, 0x2e, 0x3c, 0x27, 0x24, 0x49, 0x88, 0x51, 0xa3, 0x6e,
	0x13, 0x92, 0x24, 0x34, 0xbb, 0x19, 0x05, 0xb1, 0xfa, 0xf4, 0x63, 0x8c, 0x05, 0xf3, 0xd6, 0x6e,
	0xde, 0x20, 0x0c, 0x76, 0x0d, 0xa4, 0xcb, 0x6c, 0xcf, 0x4b, 0x76, 0xb0, 0x1f, 0xf3, 0xf0, 0x73,
	0x8d, 0xbb, 0x7f, 0x5c, 0x25, 0x77, 0x66, 0xce, 0xe1, 0x20, 0x90, 0x8a, 0x76, 0x48, 0xa3, 0x78,
	0xd9, 0x6a, 0x5e, 0xe6, 0x3c, 0xde, 0xba, 0x96, 0xbc, 0x55, 0x30, 0x99, 0xea, 0xda, 0xe3, 0x36,
	0x3e, 0xfb, 0xe5, 0xa7, 0x63, 0xf2, 0xc9, 0xea, 0x74, 0x3e, 0xb9, 0xf1, 0x15, 0x69, 0xda, 0x33,
	0xdb, 0x16, 0x56, 0xb9, 0xce, 0xc2, 0x6e, 0x9c, 0x89, 0x7e, 0x54, 0xb2, 0xbd, 0xef, 0xdd, 0xb0,
	0x0d, 0xcb, 0xfe, 0xdc, 0xdf, 0xad, 0x14, 0x77, 0xa8, 0x2f, 0xa2, 0x61, 0x07, 0xfc, 0x31, 0xa4,
	0x51, 0x3a, 0xb8, 0x05, 0x90, 0x8a, 0xcd, 0x04, 0x37, 0x44, 0xa7, 0xf3, 0xdb, 0xea, 0x0d, 0xf9,
	0xed, 0x3b, 0x24, 0x73, 0xf2, 0xd7, 0xe4, 0x63, 0x5a, 0x80, 0xf9, 0xd8, 0x5f, 0x57, 0x8b, 0x40,
	0x78, 0xcc, 0xbd, 0x0b, 0xa1, 0xf2, 0xa5, 0x4c, 0xe5, 0xdb, 0x95, 0x1b, 0xf2, 0xed, 0x0f, 0xc9,
	0xea, 0x08, 0x93, 0xcc, 0xeb, 0x53, 0xc5, 0x95, 0x4c, 0x68, 0xe8, 0x0f, 0x48, 0x1d, 0x3b, 0x54,
	0x61, 0xb6, 0xa8, 0xdc, 0x00, 0x03, 0xb9, 0x0b, 0x60, 0x31, 0x1f, 0x33, 0x9d, 0xe6, 0x52, 0x4e,
	0x9e, 0xcd, 0x67, 0x1a, 0xdb, 0xa0, 0xb0, 0x9c, 0x57, 0xba, 0x13, 0x06, 0x05, 0x8b, 0xc6, 0xc7,
	0xb1, 0xb3, 0x34, 0x89, 0x4a, 0xb7, 0x62, 0x09, 0xf1, 0xbd, 0x34, 0x89, 0xa6, 0xd5, 0x55, 0xbb,
	0x41, 0x5d, 0xff, 0xb6, 0x40, 0x56, 0xf2, 0xd8, 0x06, 0x51, 0x1d, 0x73, 0x22, 0x73, 0x36, 0x0c,
	0x03, 0x7d, 0xe9, 0xdc, 0x96, 0x8d, 0x0c, 0xd9, 0xf4, 0x39, 0x59, 0x44, 0x8e, 0x69, 0x20, 0xbc,
	0xbd, 0x55, 0x9e, 0x6d, 0x0b, 0xa5, 0xba, 0x05, 0xd0, 0xcd, 0xa8, 0x1b, 0xff, 0x35, 0x9f, 0xe5,
	0x16, 0x1a, 0x07, 0x15, 0x26, 0x69, 0x30, 0x08, 0x62, 0xa6, 0xf3, 0x8c, 0x35, 0xa3, 0x42, 0x8d,
	0xfe, 0x86, 0x45, 0xd0, 0x19, 0xec, 0x14, 0xe1, 0x0b, 0x8b, 0xa0, 0x3f, 0x13, 0x98, 0x22, 0x7c,
	0x09, 0x91, 0x70, 0x9c, 0x84, 0xa3, 0xa9, 0xf7, 0xf2, 0x19, 0x86, 0x61, 0x4d, 0x84, 0x3c, 0x0b,
	0x56, 0xa8, 0xf6, 0x6a, 0x1e, 0xd6, 0x40, 0x70, 0x62, 0xde, 0xa2, 0xe6, 0xa9, 0x65, 0x96, 0x2e,
	0xda, 0xda, 0xcf, 0xf3, 0xce, 0x2c, 0x5f, 0x9c, 0x4e, 0x58, 0x6a, 0x37, 0x25, 0x2c, 0x9b, 0xa4,
	0x06, 0xc5, 0x49, 0x2c, 0xc2, 0x52, 0xae, 0x6a, 0x40, 0x28, 0x17, 0x86, 0x81, 0xf2, 0xce, 0x4b,
	0x75, 0xb1, 0x86, 0x8a, 0xf2, 0x8a, 0xcc, 0x96, 0x57, 0x8f, 0xc8, 0x92, 0x4e, 0xe1, 0xe2, 0x51,
	0x84, 0xbd, 0xbb, 0xbc, 0xd7, 0x84, 0xf0, 0xd1, 0x28, 0xc2, 0x86, 0xa0, 0xa1, 0xb0, 0x73, 0x1e,
	0xfb, 0xa1, 0xc0, 0xf6, 0x5d, 0xd1, 0x10, 0xcc, 0x98, 0xaf, 0x50, 0x86, 0x09, 0xf3, 0x50, 0xf0,
	0x0b, 0x91, 0x32, 0xbd, 0x83, 0x52, 0x17, 0x6f, 0x39, 0x93, 0xe1, 0x95, 0x9b, 0x80, 0x5a, 0x53,
	0x1e, 0xfb, 0x49, 0xc4, 0xa4, 0x10, 0x3e, 0xb6, 0xf1, 0xf2, 0x0b, 0xa7, 0x05, 0x3d, 0x21, 0xfc,
	0x22, 0xd3, 0x0c, 0xc5, 0x58, 0x84, 0xd8, 0xc7, 0x2b, 0x67, 0x9a, 0x07, 0x80, 0x03, 0x2d, 0x90,
	0x4c, 0x8a, 0x58, 0x81, 0x8e, 0xb1, 0x9b, 0x67, 0x8c, 0x92, 0x04, 0xb2, 0x97, 0xe1, 0x70, 0x3b,
	0x02, 0xc9, 0x78, 0x74, 0x8a, 0x05, 0xd1, 0x9a, 0x5d, 0xef, 0x04, 0x72, 0x5b, 0xc3, 0xee, 0x55,
	0x11, 0xb6, 0xf5, 0x5a, 0x0f, 0x25, 0x86, 0x23, 0x08, 0xda, 0xb3, 0xf9, 0x6e, 0x1d, 0x5f, 0xa7,
	0xc2, 0x49, 0xd9, 0xfd, 0xae, 0xea, 0x75, 0xfd, 0xae, 0x07, 0x04, 0xc8, 0xb3, 0x2e, 0xaa, 0x26,
	0x62, 0x85, 0x17, 0xee, 0x45, 0xe1, 0x27, 0x7f, 0xe5, 0x76, 0xfb, 0x6f, 0x16, 0xd1, 0xa7, 0x13,
	0x7b, 0xe9, 0x64, 0xa8, 0x84, 0x6f, 0xde, 0x1c, 0x0b, 0x03, 0x94, 0x07, 0xe7, 0x30, 0xac, 0x0c,
	0x1d, 0x36, 0x44, 0x95, 0xd2, 0xd2, 0x2f, 0xc4, 0x04, 0xd2, 0x29, 0xf7, 0x9f, 0xaa, 0x45, 0x33,
	0xff, 0x55, 0xfe, 0x55, 0x07, 0x18, 0x18, 0x5e, 0x81, 0x92, 0x46, 0x34, 0x04, 0xd6, 0x30, 0x4c,
	0x83, 0x88, 0xa7, 0x13, 0xa6, 0x78, 0x3a, 0x10, 0xe5, 0x24, 0x76, 0x39, 0x93, 0xf5, 0x51, 0x44,
	0x9f, 0x82, 0x5f, 0xc1, 0x77, 0xef, 0x52, 0x25, 0x43, 0x96, 0xa5, 0x0d, 0x79, 0xa7, 0x41, 0xcb,
	0x7a, 0x2a, 0x19, 0x6e, 0x2b, 0x48, 0x20, 0x73, 0x2e, 0x4f, 0x15, 0x90, 0x4b, 0x2f, 0x24, 0x0d,
	0x99, 0xa7, 0x6a, 0x5b, 0xd1, 0x1f, 0x90, 0x3b, 0x86, 0x1d, 0x26, 0x97, 0x7e, 0x72, 0x19, 0xb3,
	0x53, 0x31, 0x08, 0xca, 0x2f, 0x93, 0xd6, 0xb3, 0x31, 0x19, 0x63, 0x07, 0x08, 0x50, 0x89, 0x4c,
	0x8f, 0x14, 0xb1, 0x5f, 0xba, 0xd5, 0x6b, 0xe5, 0x71, 0x9d, 0xd8, 0xa7, 0x9f, 0x92, 0xdb, 0xd3,
	0xa3, 0x52, 0xae, 0xca, 0xdd, 0x2f, 0x5a, 0x1e, 0xd6, 0xe5, 0x4a, 0xb8, 0xff, 0x5a, 0x29, 0x5e,
	0xd2, 0x5b, 0x1a, 0xde, 0x24, 0xb5, 0x14, 0x3c, 0x87, 0x2c, 0xd7, 0xef, 0x06, 0x44, 0xb7, 0x63,
	0x9e, 0x13, 0x8a, 0x78, 0x90, 0xbd, 0x95, 0xab, 0xe6, 0x57, 0x34, 0x13, 0x1e, 0xa0, 0x8c, 0xbe,
	0x4f, 0x96, 0xcb, 0xcb, 0xb2, 0xb3, 0xb3, 0xa6, 0xb4, 0x16, 0x44, 0x7f, 0x48, 0x5a, 0xe5, 0xf3,
	0x63, 0xc5, 0x05, 0xb0, 0xf5, 0x7d, 0xa7, 0x74, 0x92, 0x1d, 0x73, 0x1b, 0xf2, 0x3c, 0x17, 0x3f,
	0x78, 0xb2, 0xbd, 0xa6, 0xce, 0x73, 0xfb, 0x41, 0x24, 0xdc, 0xe7, 0x45, 0xef, 0x66, 0x27, 0x4d,
	0xb8, 0x0f, 0xb5, 0x3e, 0xcb, 0xde, 0x90, 0xe3, 0xbb, 0xbb, 0xa8, 0xfc, 0x51, 0x10, 0x00, 0x4f,
	0xff, 0xae, 0x42, 0x9a, 0x47, 0x9d, 0x3e, 0xcb, 0x6a, 0x01, 0x49, 0x1b, 0xa4, 0x16, 0x0b, 0xc5,
	0x8e, 0x5e, 0x1f, 0x3b, 0xb7, 0x28, 0xd5, 0xed, 0xdc, 0xe2, 0x7b, 0x12, 0xa7, 0x42, 0x9b, 0xa4,
	0x0e, 0xd8, 0x5e, 0x10, 0x0a, 0xa7, 0x4a, 0xef, 0x91, 0x75, 0xf8, 0x35, 0xf5, 0x5d, 0x86, 0x33,
	0x67, 0x68, 0xfd, 0xc0, 0xbb, 0x70, 0xe6, 0xe9, 0x1a, 0x59, 0x46, 0x9a, 0xf9, 0x50, 0xc9, 0x59,
	0xc8, 0x21, 0xf3, 0xd9, 0x8b, 0xb3, 0x48, 0xd7, 0xc9, 0x2a, 0x42, 0xc5, 0xf7, 0x46, 0x4e, 0x8d,
	0xb6, 0xc8, 0x6d, 0x00, 0xa7, 0x3f, 0xe2, 0x70, 0xfc, 0xa7, 0x7f, 0x58, 0x25, 0xcd, 0xf6, 0x41,
	0xbb, 0x58, 0x3b, 0x25, 0x2b, 0x5e, 0xe8, 0x59, 0x9f, 0x65, 0x38, 0x75, 0x58, 0x07, 0x60, 0x87,
	0xc9, 0x58, 0x38, 0x4b, 0xf0, 0x50, 0xf8, 0x95, 0x77, 0x3b, 0x1c, 0x02, 0x0f, 0x05, 0xc8, 0x7a,
	0xdf, 0xed, 0x34, 0xe8, 0x6d, 0xe2, 0x00, 0x68, 0xbf, 0x9b, 0x76, 0x9a, 0xb0, 0x14, 0x40, 0xa7,
	0xdf, 0x3c, 0x3b, 0xcb, 0x86, 0x6f, 0xbf, 0xfb, 0x75, 0x56, 0x40, 0x39, 0x38, 0x4b, 0xf9, 0x7d,
	0xa3, 0xb3, 0x4a, 0x37, 0xc8, 0x5d, 0x10, 0xcc, 0xbe, 0x4b, 0x74, 0x1c, 0x7a, 0x87, 0xac, 0x15,
	0x9b, 0xc8, 0xb6, 0xe6, 0xac, 0x99, 0x27, 0xd8, 0xae, 0xcc, 0xa1, 0x66, 0xc7, 0x85, 0x8d, 0x3b,
	0xb7, 0x9f, 0x1e, 0x90, 0xb5, 0x99, 0x6e, 0x0e, 0x3c, 0x71, 0xa6, 0x9f, 0xd3, 0xeb, 0x77, 0xb6,
	0x0f, 0x9d, 0x5b, 0xf4, 0x6d, 0x72, 0x53, 0xaf, 0xc7, 0xa9, 0x3c, 0x9d, 0x90, 0x7b, 0x37, 0x94,
	0xdb, 0x30, 0xee, 0x86, 0x82, 0xdb, 0xb9, 0x45, 0x37, 0xc9, 0xc6, 0xb4, 0xb0, 0xdb, 0x39, 0x7c,
	0x7d, 0xd2, 0x41, 0x79, 0x85, 0xde, 0x27, 0x6f, 0x4d, 0xcb, 0xfb, 0x5f, 0x1c, 0x77, 0xd8, 0xce,
	0x7e, 0xbf, 0xe7, 0x54, 0x36, 0xaa, 0x4e, 0xe5, 0xe9, 0x37, 0xf3, 0xa4, 0xd9, 0x3b, 0x29, 0x9f,
	0xaf, 0x1c, 0x7b, 0xd6, 0x0b, 0x50, 0xa7, 0x0e, 0x27, 0xaa, 0xb1, 0xec, 0x45, 0x80, 0x3e, 0x64,
	0x80, 0xf2, 0x17, 0x2b, 0x0e, 0xa1, 0x0e, 0x69, 0x6a, 0x96, 0xee, 0x51, 0x3b, 0x0d, 0xfa, 0x16,
	0xb9, 0x83, 0xa4, 0xe9, 0x36, 0xb2, 0xd3, 0x34, 0xa2, 0x99, 0x06, 0xa8, 0xb3, 0x6c, 0xa6, 0xce,
	0x1b, 0x90, 0xce, 0x4a, 0x09, 0x42, 0x93, 0x5a, 0xa5, 0xcb, 0x64, 0x09, 0x20, 0x6c, 0x9e, 0x3b,
	0x0e, 0x5d, 0x21, 0x04, 0x1f, 0x8e, 0x39, 0x99, 0xb3, 0x46, 0x57, 0x49, 0x23, 0x5b, 0xcc, 0x49,
	0x20, 0x2e, 0x1d, 0x6a, 0x56, 0x67, 0xfa, 0x54, 0xce, 0x3a, 0xbd, 0x4b, 0xa8, 0x5e, 0x9d, 0xdd,
	0x60, 0x72, 0x6e, 0x1b, 0xa6, 0xe9, 0xff, 0x38, 0x77, 0xc0, 0x7c, 0x71, 0xb2, 0xe2, 0x88, 0x9c,
	0xbb, 0x06, 0xb4, 0x8a, 0x7c, 0xe7, 0x1e, 0x18, 0x16, 0x80, 0x59, 0x18, 0xce, 0xe0, 0x96, 0x59,
	0x7f, 0x5e, 0x71, 0x38, 0x6f, 0x99, 0xa7, 0x97, 0xb3, 0x7a, 0x67, 0x03, 0x6c, 0x10, 0x70, 0xbb,
	0xec, 0x70, 0xde, 0x36, 0x6b, 0x32, 0xfd, 0x2c, 0xe7, 0x7b, 0x70, 0xe7, 0x00, 0x39, 0x14, 0xf1,
	0xc8, 0xb9, 0x6f, 0x9e, 0x5b, 0x2a, 0x69, 0x9c, 0x4d, 0x33, 0x99, 0xdd, 0x46, 0x71, 0x1e, 0x18,
	0xd4, 0xee, 0x0e, 0x38, 0x8f, 0x0c, 0x5a, 0x32, 0x7e, 0xb7, 0xd8, 0x90, 0x15, 0xa1, 0x9d, 0xc7,
	0xc6, 0x4a, 0xac, 0x3b, 0xf1, 0xff, 0xcc, 0x91, 0xce, 0xf8, 0x45, 0xe7, 0xdd, 0xa7, 0xbf, 0x57,
	0x21, 0x6b, 0x9a, 0x87, 0xab, 0x03, 0xcb, 0x66, 0x0a, 0xae, 0x6e, 0xb7, 0x73, 0x7c, 0xb0, 0xfd,
	0x05, 0xeb, 0x9c, 0x74, 0x8e, 0xfa, 0xac, 0xbd, 0x7d, 0xd4, 0xee, 0x1c, 0x38, 0xb7, 0x40, 0x37,
	0x25, 0xc1, 0x6e, 0x67, 0xbb, 0xff, 0xca, 0xa9, 0x80, 0x6f, 0x28, 0xe1, 0x2f, 0x3b, 0x47, 0x9d,
	0xee, 0x7e, 0xdb, 0xa9, 0xd2, 0xf7, 0xc8, 0xe3, 0x92, 0xa4, 0xd7, 0x7f, 0xd3, 0xfe, 0x11, 0x3b,
	0xea, 0x74, 0x76, 0xd9, 0xde, 0x9b, 0x83, 0x03, 0xf6, 0xe6, 0x78, 0x77, 0xbb, 0xdf, 0x71, 0xe6,
	0x76, 0x1e, 0xfe, 0xf4, 0xeb, 0xcd, 0xca, 0xcf, 0xbe, 0xde, 0xac, 0xfc, 0xe2, 0xeb, 0xcd, 0xca,
	0x1f, 0x7c, 0xb3, 0x79, 0xeb, 0x67, 0xdf, 0x6c, 0xde, 0xfa, 0xc7, 0x6f, 0x36, 0x6f, 0x7d, 0x39,
	0x17, 0xc9, 0xc1, 0xef, 0x54, 0x6e, 0xfd, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe9, 0xa9, 0xb1,
	0xb6, 0x8b, 0x2c, 0x00, 0x00,
}

func (m *CMsgVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
	i += 4
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
	i += 4
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
	i += 4
	return i, nil
}

func (m *CMsgVector2D) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgVector2D) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
	i += 4
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
	i += 4
	return i, nil
}

func (m *CMsgQAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgQAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
	i += 4
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
	i += 4
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
	i += 4
	return i, nil
}

func (m *CMsgRGBA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgRGBA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.R))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.G))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.B))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.A))
	return i, nil
}

func (m *CNETMsg_Tick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_Tick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Tick))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostComputationtime))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostComputationtimeStdDeviation))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HostFramestarttimeStdDeviation))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.HltvReplayFlags))
	return i, nil
}

func (m *CNETMsg_StringCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_StringCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Command)))
	i += copy(dAtA[i:], m.Command)
	return i, nil
}

func (m *CNETMsg_SignonState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SignonState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SignonState))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SpawnCount))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumServerPlayers))
	if len(m.PlayersNetworkids) > 0 {
		for _, s := range m.PlayersNetworkids {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapName)))
	i += copy(dAtA[i:], m.MapName)
	return i, nil
}

func (m *CMsg_CVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsg_CVars) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cvars) > 0 {
		for _, msg := range m.Cvars {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsg_CVars_CVar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsg_CVars_CVar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DictionaryName))
	return i, nil
}

func (m *CNETMsg_SetConVar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SetConVar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Convars != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Convars.Size()))
		n1, err1 := m.Convars.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *CNETMsg_NOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_NOP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CNETMsg_Disconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_Disconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CNETMsg_File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.TransferId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.FileName)))
	i += copy(dAtA[i:], m.FileName)
	dAtA[i] = 0x18
	i++
	if m.IsReplayDemoFile {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.Deny {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CNETMsg_SplitScreenUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_SplitScreenUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Slot))
	return i, nil
}

func (m *CNETMsg_PlayerAvatarData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNETMsg_PlayerAvatarData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Accountid))
	if m.Rgb != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Rgb)))
		i += copy(dAtA[i:], m.Rgb)
	}
	return i, nil
}

func (m *CCLCMsg_ClientInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_ClientInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.SendTableCrc))
	i += 4
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ServerCount))
	dAtA[i] = 0x18
	i++
	if m.IsHltv {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.IsReplay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FriendsId))
	dAtA[i] = 0x32
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.FriendsName)))
	i += copy(dAtA[i:], m.FriendsName)
	if len(m.CustomFiles) > 0 {
		for _, num := range m.CustomFiles {
			dAtA[i] = 0x3d
			i++
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(num))
			i += 4
		}
	}
	return i, nil
}

func (m *CCLCMsg_Move) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_Move) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumBackupCommands))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumNewCommands))
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *CCLCMsg_VoiceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_VoiceData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x11
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Xuid))
	i += 8
	if m.Format != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Format))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceBytes))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SectionNumber))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UncompressedSampleOffset))
	return i, nil
}

func (m *CCLCMsg_BaselineAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_BaselineAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.BaselineTick))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.BaselineNr))
	return i, nil
}

func (m *CCLCMsg_ListenEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_ListenEvents) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventMask) > 0 {
		for _, num := range m.EventMask {
			dAtA[i] = 0xd
			i++
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(num))
			i += 4
		}
	}
	return i, nil
}

func (m *CCLCMsg_RespondCvarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_RespondCvarValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Cookie))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.StatusCode))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x22
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CCLCMsg_FileCRCCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_FileCRCCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.CodePath))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.CodeFilename))
	dAtA[i] = 0x22
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Filename)))
	i += copy(dAtA[i:], m.Filename)
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileFraction))
	if m.Md5 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Crc))
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileHashType))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.FileLen))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PackFileId))
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PackFileNumber))
	return i, nil
}

func (m *CCLCMsg_LoadingProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_LoadingProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Progress))
	return i, nil
}

func (m *CCLCMsg_SplitPlayerConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_SplitPlayerConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Convars != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Convars.Size()))
		n2, err2 := m.Convars.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *CCLCMsg_CmdKeyValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_CmdKeyValues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyvalues != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Keyvalues)))
		i += copy(dAtA[i:], m.Keyvalues)
	}
	return i, nil
}

func (m *CSVCMsg_ServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ServerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Protocol))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ServerCount))
	dAtA[i] = 0x18
	i++
	if m.IsDedicated {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.IsOfficialValveServer {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsHltv {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.IsReplay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.COs))
	dAtA[i] = 0x45
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.MapCrc))
	i += 4
	dAtA[i] = 0x4d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClientCrc))
	i += 4
	dAtA[i] = 0x55
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.StringTableCrc))
	i += 4
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxClients))
	dAtA[i] = 0x60
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxClasses))
	dAtA[i] = 0x68
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PlayerSlot))
	dAtA[i] = 0x75
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TickInterval))))
	i += 4
	dAtA[i] = 0x7a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.GameDir)))
	i += copy(dAtA[i:], m.GameDir)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapName)))
	i += copy(dAtA[i:], m.MapName)
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MapGroupName)))
	i += copy(dAtA[i:], m.MapGroupName)
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.SkyName)))
	i += copy(dAtA[i:], m.SkyName)
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.HostName)))
	i += copy(dAtA[i:], m.HostName)
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PublicIp))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsRedirectingToProxyRelay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xb0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UgcMapId))
	return i, nil
}

func (m *CSVCMsg_ClassInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ClassInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.CreateOnClient {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Classes) > 0 {
		for _, msg := range m.Classes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_ClassInfoClassT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_ClassInfoClassT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ClassId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.DataTableName)))
	i += copy(dAtA[i:], m.DataTableName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ClassName)))
	i += copy(dAtA[i:], m.ClassName)
	return i, nil
}

func (m *CSVCMsg_SendTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SendTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.IsEnd {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.NetTableName)))
	i += copy(dAtA[i:], m.NetTableName)
	dAtA[i] = 0x18
	i++
	if m.NeedsDecoder {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Props) > 0 {
		for _, msg := range m.Props {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_SendTableSendpropT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SendTableSendpropT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.VarName)))
	i += copy(dAtA[i:], m.VarName)
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Priority))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.DtName)))
	i += copy(dAtA[i:], m.DtName)
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumElements))
	dAtA[i] = 0x3d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LowValue))))
	i += 4
	dAtA[i] = 0x45
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HighValue))))
	i += 4
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumBits))
	return i, nil
}

func (m *CSVCMsg_Print) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Print) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CSVCMsg_SetPause) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SetPause) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Paused {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_SetView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SetView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	return i, nil
}

func (m *CSVCMsg_CreateStringTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CreateStringTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxEntries))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumEntries))
	dAtA[i] = 0x20
	i++
	if m.UserDataFixedSize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UserDataSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UserDataSizeBits))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	if m.StringData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.StringData)))
		i += copy(dAtA[i:], m.StringData)
	}
	return i, nil
}

func (m *CSVCMsg_UpdateStringTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_UpdateStringTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.TableId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumChangedEntries))
	if m.StringData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.StringData)))
		i += copy(dAtA[i:], m.StringData)
	}
	return i, nil
}

func (m *CSVCMsg_VoiceInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_VoiceInit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Quality))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Codec)))
	i += copy(dAtA[i:], m.Codec)
	if m.Version != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Version))
	}
	return i, nil
}

func (m *CSVCMsg_VoiceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_VoiceData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Client))
	dAtA[i] = 0x10
	i++
	if m.Proximity {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Xuid))
	i += 8
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.AudibleMask))
	if m.VoiceData != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.VoiceData)))
		i += copy(dAtA[i:], m.VoiceData)
	}
	dAtA[i] = 0x30
	i++
	if m.Caster {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Format != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Format))
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceBytes))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SectionNumber))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UncompressedSampleOffset))
	return i, nil
}

func (m *CSVCMsg_FixAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_FixAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Relative {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Angle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Angle.Size()))
		n3, err3 := m.Angle.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}

func (m *CSVCMsg_CrosshairAngle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CrosshairAngle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Angle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Angle.Size()))
		n4, err4 := m.Angle.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}

func (m *CSVCMsg_Prefetch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Prefetch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundIndex))
	return i, nil
}

func (m *CSVCMsg_BSPDecal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_BSPDecal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(m.Pos.Size()))
		n5, err5 := m.Pos.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DecalTextureIndex))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ModelIndex))
	dAtA[i] = 0x28
	i++
	if m.LowPriority {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_SplitScreen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SplitScreen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(*m.Type))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Slot))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PlayerIndex))
	return i, nil
}

func (m *CSVCMsg_GetCvarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GetCvarValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Cookie))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.CvarName)))
	i += copy(dAtA[i:], m.CvarName)
	return i, nil
}

func (m *CSVCMsg_Menu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Menu) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DialogType))
	if m.MenuKeyValues != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MenuKeyValues)))
		i += copy(dAtA[i:], m.MenuKeyValues)
	}
	return i, nil
}

func (m *CSVCMsg_UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MsgType))
	if m.MsgData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.MsgData)))
		i += copy(dAtA[i:], m.MsgData)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Passthrough))
	return i, nil
}

func (m *CSVCMsg_PaintmapData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_PaintmapData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Paintmap != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Paintmap)))
		i += copy(dAtA[i:], m.Paintmap)
	}
	return i, nil
}

func (m *CSVCMsg_GameEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EventName)))
	i += copy(dAtA[i:], m.EventName)
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Eventid))
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Passthrough))
	return i, nil
}

func (m *CSVCMsg_GameEventKeyT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventKeyT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ValString)))
	i += copy(dAtA[i:], m.ValString)
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ValFloat))))
	i += 4
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValLong))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValShort))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValByte))
	dAtA[i] = 0x38
	i++
	if m.ValBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ValUint64))
	if m.ValWstring != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.ValWstring)))
		i += copy(dAtA[i:], m.ValWstring)
	}
	return i, nil
}

func (m *CSVCMsg_GameEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, msg := range m.Descriptors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_GameEventListKeyT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventListKeyT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *CSVCMsg_GameEventListDescriptorT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_GameEventListDescriptorT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Eventid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_TempEntities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_TempEntities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Reliable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.NumEntries))
	if m.EntityData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntityData)))
		i += copy(dAtA[i:], m.EntityData)
	}
	return i, nil
}

func (m *CSVCMsg_PacketEntities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_PacketEntities) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.MaxEntries))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.UpdatedEntries))
	dAtA[i] = 0x18
	i++
	if m.IsDelta {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.UpdateBaseline {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Baseline))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.DeltaFrom))
	if m.EntityData != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntityData)))
		i += copy(dAtA[i:], m.EntityData)
	}
	return i, nil
}

func (m *CSVCMsg_Sounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Sounds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.ReliableSound {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Sounds) > 0 {
		for _, msg := range m.Sounds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CSVCMsg_SoundsSounddataT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_SoundsSounddataT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginX)<<1)^uint32((m.OriginX>>31))))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginY)<<1)^uint32((m.OriginY>>31))))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64((uint32(m.OriginZ)<<1)^uint32((m.OriginZ>>31))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Volume))
	dAtA[i] = 0x2d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DelayValue))))
	i += 4
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SequenceNumber))
	dAtA[i] = 0x38
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntityIndex))
	dAtA[i] = 0x40
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Channel))
	dAtA[i] = 0x48
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Pitch))
	dAtA[i] = 0x50
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x58
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundNum))
	dAtA[i] = 0x65
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.SoundNumHandle))
	i += 4
	dAtA[i] = 0x68
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SpeakerEntity))
	dAtA[i] = 0x70
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.RandomSeed))
	dAtA[i] = 0x78
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.SoundLevel))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	if m.IsSentence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.IsAmbient {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSVCMsg_EntityMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_EntityMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.EntIndex))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ClassId))
	if m.EntData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.EntData)))
		i += copy(dAtA[i:], m.EntData)
	}
	return i, nil
}

func (m *CSVCMsg_CmdKeyValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_CmdKeyValues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyvalues != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Keyvalues)))
		i += copy(dAtA[i:], m.Keyvalues)
	}
	return i, nil
}

func (m *CSVCMsg_EncryptedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_EncryptedData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encrypted != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Encrypted)))
		i += copy(dAtA[i:], m.Encrypted)
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.KeyType))
	return i, nil
}

func (m *CSVCMsg_HltvReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_HltvReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Delay))
	dAtA[i] = 0x10
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PrimaryTarget))
	dAtA[i] = 0x18
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplayStopAt))
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplayStartAt))
	dAtA[i] = 0x28
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplaySlowdownBegin))
	dAtA[i] = 0x30
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.ReplaySlowdownEnd))
	dAtA[i] = 0x3d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReplaySlowdownRate))))
	i += 4
	return i, nil
}

func (m *CCLCMsg_HltvReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCLCMsg_HltvReplay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.Request))
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SlowdownLength))))
	i += 4
	dAtA[i] = 0x1d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SlowdownRate))))
	i += 4
	dAtA[i] = 0x20
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(m.PrimaryTargetEntIndex))
	dAtA[i] = 0x2d
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EventTime))))
	i += 4
	return i, nil
}

func (m *CSVCMsg_Broadcast_Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVCMsg_Broadcast_Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintNetmessages(dAtA, i, uint64(len(m.Cmd)))
	i += copy(dAtA[i:], m.Cmd)
	return i, nil
}

func encodeVarintNetmessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	return n
}

func (m *CMsgVector2D) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func (m *CMsgQAngle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	return n
}

func (m *CMsgRGBA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.R))
	n += 1 + sovNetmessages(uint64(m.G))
	n += 1 + sovNetmessages(uint64(m.B))
	n += 1 + sovNetmessages(uint64(m.A))
	return n
}

func (m *CNETMsg_Tick) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Tick))
	n += 1 + sovNetmessages(uint64(m.HostComputationtime))
	n += 1 + sovNetmessages(uint64(m.HostComputationtimeStdDeviation))
	n += 1 + sovNetmessages(uint64(m.HostFramestarttimeStdDeviation))
	n += 1 + sovNetmessages(uint64(m.HltvReplayFlags))
	return n
}

func (m *CNETMsg_StringCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CNETMsg_SignonState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.SignonState))
	n += 1 + sovNetmessages(uint64(m.SpawnCount))
	n += 1 + sovNetmessages(uint64(m.NumServerPlayers))
	if len(m.PlayersNetworkids) > 0 {
		for _, s := range m.PlayersNetworkids {
			l = len(s)
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	l = len(m.MapName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CMsg_CVars) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cvars) > 0 {
		for _, e := range m.Cvars {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsg_CVars_CVar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.DictionaryName))
	return n
}

func (m *CNETMsg_SetConVar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Convars != nil {
		l = m.Convars.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CNETMsg_NOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CNETMsg_Disconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CNETMsg_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.TransferId))
	l = len(m.FileName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 2
	n += 2
	return n
}

func (m *CNETMsg_SplitScreenUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Slot))
	return n
}

func (m *CNETMsg_PlayerAvatarData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Accountid))
	if m.Rgb != nil {
		l = len(m.Rgb)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_ClientInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 1 + sovNetmessages(uint64(m.ServerCount))
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.FriendsId))
	l = len(m.FriendsName)
	n += 1 + l + sovNetmessages(uint64(l))
	if len(m.CustomFiles) > 0 {
		n += 5 * len(m.CustomFiles)
	}
	return n
}

func (m *CCLCMsg_Move) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.NumBackupCommands))
	n += 1 + sovNetmessages(uint64(m.NumNewCommands))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_VoiceData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 9
	if m.Format != nil {
		n += 1 + sovNetmessages(uint64(*m.Format))
	}
	n += 1 + sovNetmessages(uint64(m.SequenceBytes))
	n += 1 + sovNetmessages(uint64(m.SectionNumber))
	n += 1 + sovNetmessages(uint64(m.UncompressedSampleOffset))
	return n
}

func (m *CCLCMsg_BaselineAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.BaselineTick))
	n += 1 + sovNetmessages(uint64(m.BaselineNr))
	return n
}

func (m *CCLCMsg_ListenEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EventMask) > 0 {
		n += 5 * len(m.EventMask)
	}
	return n
}

func (m *CCLCMsg_RespondCvarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Cookie))
	n += 1 + sovNetmessages(uint64(m.StatusCode))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CCLCMsg_FileCRCCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.CodePath))
	l = len(m.Path)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.CodeFilename))
	l = len(m.Filename)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.FileFraction))
	if m.Md5 != nil {
		l = len(m.Md5)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.Crc))
	n += 1 + sovNetmessages(uint64(m.FileHashType))
	n += 1 + sovNetmessages(uint64(m.FileLen))
	n += 1 + sovNetmessages(uint64(m.PackFileId))
	n += 1 + sovNetmessages(uint64(m.PackFileNumber))
	return n
}

func (m *CCLCMsg_LoadingProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Progress))
	return n
}

func (m *CCLCMsg_SplitPlayerConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Convars != nil {
		l = m.Convars.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CCLCMsg_CmdKeyValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Keyvalues != nil {
		l = len(m.Keyvalues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_ServerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Protocol))
	n += 1 + sovNetmessages(uint64(m.ServerCount))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.COs))
	n += 5
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.MaxClients))
	n += 1 + sovNetmessages(uint64(m.MaxClasses))
	n += 1 + sovNetmessages(uint64(m.PlayerSlot))
	n += 5
	l = len(m.GameDir)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.MapName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.MapGroupName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.SkyName)
	n += 2 + l + sovNetmessages(uint64(l))
	l = len(m.HostName)
	n += 2 + l + sovNetmessages(uint64(l))
	n += 2 + sovNetmessages(uint64(m.PublicIp))
	n += 3
	n += 2 + sovNetmessages(uint64(m.UgcMapId))
	return n
}

func (m *CSVCMsg_ClassInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	if len(m.Classes) > 0 {
		for _, e := range m.Classes {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_ClassInfoClassT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.ClassId))
	l = len(m.DataTableName)
	n += 1 + l + sovNetmessages(uint64(l))
	l = len(m.ClassName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_SendTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	l = len(m.NetTableName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 2
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_SendTableSendpropT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.VarName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.Flags))
	n += 1 + sovNetmessages(uint64(m.Priority))
	l = len(m.DtName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.NumElements))
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.NumBits))
	return n
}

func (m *CSVCMsg_Print) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_SetPause) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *CSVCMsg_SetView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	return n
}

func (m *CSVCMsg_CreateStringTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.MaxEntries))
	n += 1 + sovNetmessages(uint64(m.NumEntries))
	n += 2
	n += 1 + sovNetmessages(uint64(m.UserDataSize))
	n += 1 + sovNetmessages(uint64(m.UserDataSizeBits))
	n += 1 + sovNetmessages(uint64(m.Flags))
	if m.StringData != nil {
		l = len(m.StringData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_UpdateStringTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.TableId))
	n += 1 + sovNetmessages(uint64(m.NumChangedEntries))
	if m.StringData != nil {
		l = len(m.StringData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_VoiceInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Quality))
	l = len(m.Codec)
	n += 1 + l + sovNetmessages(uint64(l))
	if m.Version != nil {
		n += 1 + sovNetmessages(uint64(*m.Version))
	}
	return n
}

func (m *CSVCMsg_VoiceData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Client))
	n += 2
	n += 9
	n += 1 + sovNetmessages(uint64(m.AudibleMask))
	if m.VoiceData != nil {
		l = len(m.VoiceData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 2
	if m.Format != nil {
		n += 1 + sovNetmessages(uint64(*m.Format))
	}
	n += 1 + sovNetmessages(uint64(m.SequenceBytes))
	n += 1 + sovNetmessages(uint64(m.SectionNumber))
	n += 1 + sovNetmessages(uint64(m.UncompressedSampleOffset))
	return n
}

func (m *CSVCMsg_FixAngle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	if m.Angle != nil {
		l = m.Angle.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_CrosshairAngle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Angle != nil {
		l = m.Angle.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_Prefetch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.SoundIndex))
	return n
}

func (m *CSVCMsg_BSPDecal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.DecalTextureIndex))
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	n += 1 + sovNetmessages(uint64(m.ModelIndex))
	n += 2
	return n
}

func (m *CSVCMsg_SplitScreen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovNetmessages(uint64(*m.Type))
	}
	n += 1 + sovNetmessages(uint64(m.Slot))
	n += 1 + sovNetmessages(uint64(m.PlayerIndex))
	return n
}

func (m *CSVCMsg_GetCvarValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Cookie))
	l = len(m.CvarName)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_Menu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.DialogType))
	if m.MenuKeyValues != nil {
		l = len(m.MenuKeyValues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_UserMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.MsgType))
	if m.MsgData != nil {
		l = len(m.MsgData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.Passthrough))
	return n
}

func (m *CSVCMsg_PaintmapData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Paintmap != nil {
		l = len(m.Paintmap)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_GameEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventName)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 1 + sovNetmessages(uint64(m.Eventid))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	n += 1 + sovNetmessages(uint64(m.Passthrough))
	return n
}

func (m *CSVCMsg_GameEventKeyT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.ValString)
	n += 1 + l + sovNetmessages(uint64(l))
	n += 5
	n += 1 + sovNetmessages(uint64(m.ValLong))
	n += 1 + sovNetmessages(uint64(m.ValShort))
	n += 1 + sovNetmessages(uint64(m.ValByte))
	n += 2
	n += 1 + sovNetmessages(uint64(m.ValUint64))
	if m.ValWstring != nil {
		l = len(m.ValWstring)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_GameEventList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_GameEventListKeyT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Type))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func (m *CSVCMsg_GameEventListDescriptorT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Eventid))
	l = len(m.Name)
	n += 1 + l + sovNetmessages(uint64(l))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_TempEntities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 1 + sovNetmessages(uint64(m.NumEntries))
	if m.EntityData != nil {
		l = len(m.EntityData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_PacketEntities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.MaxEntries))
	n += 1 + sovNetmessages(uint64(m.UpdatedEntries))
	n += 2
	n += 2
	n += 1 + sovNetmessages(uint64(m.Baseline))
	n += 1 + sovNetmessages(uint64(m.DeltaFrom))
	if m.EntityData != nil {
		l = len(m.EntityData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_Sounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	if len(m.Sounds) > 0 {
		for _, e := range m.Sounds {
			l = e.Size()
			n += 1 + l + sovNetmessages(uint64(l))
		}
	}
	return n
}

func (m *CSVCMsg_SoundsSounddataT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozNetmessages(uint64(m.OriginX))
	n += 1 + sozNetmessages(uint64(m.OriginY))
	n += 1 + sozNetmessages(uint64(m.OriginZ))
	n += 1 + sovNetmessages(uint64(m.Volume))
	n += 5
	n += 1 + sovNetmessages(uint64(m.SequenceNumber))
	n += 1 + sovNetmessages(uint64(m.EntityIndex))
	n += 1 + sovNetmessages(uint64(m.Channel))
	n += 1 + sovNetmessages(uint64(m.Pitch))
	n += 1 + sovNetmessages(uint64(m.Flags))
	n += 1 + sovNetmessages(uint64(m.SoundNum))
	n += 5
	n += 1 + sovNetmessages(uint64(m.SpeakerEntity))
	n += 1 + sovNetmessages(uint64(m.RandomSeed))
	n += 1 + sovNetmessages(uint64(m.SoundLevel))
	n += 3
	n += 3
	return n
}

func (m *CSVCMsg_EntityMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.EntIndex))
	n += 1 + sovNetmessages(uint64(m.ClassId))
	if m.EntData != nil {
		l = len(m.EntData)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_CmdKeyValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Keyvalues != nil {
		l = len(m.Keyvalues)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	return n
}

func (m *CSVCMsg_EncryptedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encrypted != nil {
		l = len(m.Encrypted)
		n += 1 + l + sovNetmessages(uint64(l))
	}
	n += 1 + sovNetmessages(uint64(m.KeyType))
	return n
}

func (m *CSVCMsg_HltvReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Delay))
	n += 1 + sovNetmessages(uint64(m.PrimaryTarget))
	n += 1 + sovNetmessages(uint64(m.ReplayStopAt))
	n += 1 + sovNetmessages(uint64(m.ReplayStartAt))
	n += 1 + sovNetmessages(uint64(m.ReplaySlowdownBegin))
	n += 1 + sovNetmessages(uint64(m.ReplaySlowdownEnd))
	n += 5
	return n
}

func (m *CCLCMsg_HltvReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNetmessages(uint64(m.Request))
	n += 5
	n += 5
	n += 1 + sovNetmessages(uint64(m.PrimaryTargetEntIndex))
	n += 5
	return n
}

func (m *CSVCMsg_Broadcast_Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cmd)
	n += 1 + l + sovNetmessages(uint64(l))
	return n
}

func sovNetmessages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNetmessages(x uint64) (n int) {
	return sovNetmessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgVector2D) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgVector2D: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgVector2D: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgQAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgQAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgQAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgRGBA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgRGBA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgRGBA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			m.R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.R |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			m.G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.G |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_Tick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_Tick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_Tick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tick", wireType)
			}
			m.Tick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tick |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostComputationtime", wireType)
			}
			m.HostComputationtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostComputationtime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostComputationtimeStdDeviation", wireType)
			}
			m.HostComputationtimeStdDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostComputationtimeStdDeviation |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostFramestarttimeStdDeviation", wireType)
			}
			m.HostFramestarttimeStdDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostFramestarttimeStdDeviation |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HltvReplayFlags", wireType)
			}
			m.HltvReplayFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HltvReplayFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_StringCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_StringCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_StringCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SignonState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SignonState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SignonState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignonState", wireType)
			}
			m.SignonState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignonState |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpawnCount", wireType)
			}
			m.SpawnCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpawnCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumServerPlayers", wireType)
			}
			m.NumServerPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumServerPlayers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayersNetworkids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayersNetworkids = append(m.PlayersNetworkids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsg_CVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsg_CVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsg_CVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cvars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cvars = append(m.Cvars, &CMsg_CVars_CVar{})
			if err := m.Cvars[len(m.Cvars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsg_CVars_CVar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DictionaryName", wireType)
			}
			m.DictionaryName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DictionaryName |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SetConVar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SetConVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SetConVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Convars == nil {
				m.Convars = &CMsg_CVars{}
			}
			if err := m.Convars.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_NOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_NOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_NOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_Disconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_Disconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_Disconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			m.TransferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplayDemoFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplayDemoFile = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deny", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deny = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_SplitScreenUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_SplitScreenUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_SplitScreenUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNETMsg_PlayerAvatarData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNETMsg_PlayerAvatarData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNETMsg_PlayerAvatarData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accountid", wireType)
			}
			m.Accountid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accountid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rgb", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rgb = append(m.Rgb[:0], dAtA[iNdEx:postIndex]...)
			if m.Rgb == nil {
				m.Rgb = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_ClientInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_ClientInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_ClientInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTableCrc", wireType)
			}
			m.SendTableCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.SendTableCrc = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCount", wireType)
			}
			m.ServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHltv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHltv = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplay = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendsId", wireType)
			}
			m.FriendsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendsId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.CustomFiles = append(m.CustomFiles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetmessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.CustomFiles) == 0 {
					m.CustomFiles = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.CustomFiles = append(m.CustomFiles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFiles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_Move) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_Move: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_Move: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBackupCommands", wireType)
			}
			m.NumBackupCommands = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBackupCommands |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNewCommands", wireType)
			}
			m.NumNewCommands = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNewCommands |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_VoiceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_VoiceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_VoiceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xuid", wireType)
			}
			m.Xuid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Xuid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var v VoiceDataFormatT
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= VoiceDataFormatT(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Format = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceBytes", wireType)
			}
			m.SequenceBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionNumber", wireType)
			}
			m.SectionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSampleOffset", wireType)
			}
			m.UncompressedSampleOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedSampleOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_BaselineAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_BaselineAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_BaselineAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineTick", wireType)
			}
			m.BaselineTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaselineTick |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaselineNr", wireType)
			}
			m.BaselineNr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaselineNr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_ListenEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_ListenEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_ListenEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.EventMask = append(m.EventMask, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetmessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.EventMask) == 0 {
					m.EventMask = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.EventMask = append(m.EventMask, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventMask", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_RespondCvarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_RespondCvarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_RespondCvarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_FileCRCCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_FileCRCCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_FileCRCCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodePath", wireType)
			}
			m.CodePath = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodePath |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeFilename", wireType)
			}
			m.CodeFilename = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeFilename |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFraction", wireType)
			}
			m.FileFraction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFraction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc", wireType)
			}
			m.Crc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashType", wireType)
			}
			m.FileHashType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHashType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLen", wireType)
			}
			m.FileLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackFileId", wireType)
			}
			m.PackFileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackFileId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackFileNumber", wireType)
			}
			m.PackFileNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackFileNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_LoadingProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_LoadingProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_LoadingProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_SplitPlayerConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_SplitPlayerConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_SplitPlayerConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Convars == nil {
				m.Convars = &CMsg_CVars{}
			}
			if err := m.Convars.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_CmdKeyValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_CmdKeyValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_CmdKeyValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyvalues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyvalues = append(m.Keyvalues[:0], dAtA[iNdEx:postIndex]...)
			if m.Keyvalues == nil {
				m.Keyvalues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_ServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_ServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCount", wireType)
			}
			m.ServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDedicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDedicated = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOfficialValveServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOfficialValveServer = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHltv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHltv = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReplay = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field COs", wireType)
			}
			m.COs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.COs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapCrc", wireType)
			}
			m.MapCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.MapCrc = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCrc", wireType)
			}
			m.ClientCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCrc = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTableCrc", wireType)
			}
			m.StringTableCrc = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.StringTableCrc = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClients", wireType)
			}
			m.MaxClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClients |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClasses", wireType)
			}
			m.MaxClasses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClasses |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerSlot", wireType)
			}
			m.PlayerSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerSlot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickInterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TickInterval = float32(math.Float32frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			m.PublicIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicIp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRedirectingToProxyRelay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRedirectingToProxyRelay = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UgcMapId", wireType)
			}
			m.UgcMapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UgcMapId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ClassInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_ClassInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_ClassInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOnClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateOnClient = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Classes = append(m.Classes, &CSVCMsg_ClassInfoClassT{})
			if err := m.Classes[len(m.Classes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_ClassInfoClassT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: class_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: class_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SendTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SendTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SendTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedsDecoder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedsDecoder = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &CSVCMsg_SendTableSendpropT{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SendTableSendpropT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendprop_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendprop_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VarName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VarName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumElements", wireType)
			}
			m.NumElements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumElements |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LowValue = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HighValue = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBits", wireType)
			}
			m.NumBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Print) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Print: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Print: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SetPause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SetPause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SetPause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SetView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SetView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SetView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CreateStringTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CreateStringTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CreateStringTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntries", wireType)
			}
			m.MaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataFixedSize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserDataFixedSize = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataSize", wireType)
			}
			m.UserDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserDataSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDataSizeBits", wireType)
			}
			m.UserDataSizeBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserDataSizeBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData[:0], dAtA[iNdEx:postIndex]...)
			if m.StringData == nil {
				m.StringData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_UpdateStringTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_UpdateStringTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_UpdateStringTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumChangedEntries", wireType)
			}
			m.NumChangedEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumChangedEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData[:0], dAtA[iNdEx:postIndex]...)
			if m.StringData == nil {
				m.StringData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_VoiceInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_VoiceInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_VoiceInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_VoiceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_VoiceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_VoiceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			m.Client = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Client |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proximity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proximity = bool(v != 0)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xuid", wireType)
			}
			m.Xuid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Xuid = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudibleMask", wireType)
			}
			m.AudibleMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudibleMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoiceData = append(m.VoiceData[:0], dAtA[iNdEx:postIndex]...)
			if m.VoiceData == nil {
				m.VoiceData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Caster = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var v VoiceDataFormatT
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= VoiceDataFormatT(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Format = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceBytes", wireType)
			}
			m.SequenceBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionNumber", wireType)
			}
			m.SectionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSampleOffset", wireType)
			}
			m.UncompressedSampleOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedSampleOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_FixAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_FixAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_FixAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Relative = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Angle == nil {
				m.Angle = &CMsgQAngle{}
			}
			if err := m.Angle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CrosshairAngle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CrosshairAngle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CrosshairAngle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Angle == nil {
				m.Angle = &CMsgQAngle{}
			}
			if err := m.Angle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Prefetch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Prefetch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Prefetch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundIndex", wireType)
			}
			m.SoundIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_BSPDecal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_BSPDecal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_BSPDecal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &CMsgVector{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecalTextureIndex", wireType)
			}
			m.DecalTextureIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecalTextureIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelIndex", wireType)
			}
			m.ModelIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowPriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowPriority = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SplitScreen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_SplitScreen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_SplitScreen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ESplitScreenMessageType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ESplitScreenMessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerIndex", wireType)
			}
			m.PlayerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GetCvarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GetCvarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GetCvarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvarName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CvarName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Menu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Menu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Menu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogType", wireType)
			}
			m.DialogType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DialogType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MenuKeyValues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MenuKeyValues = append(m.MenuKeyValues[:0], dAtA[iNdEx:postIndex]...)
			if m.MenuKeyValues == nil {
				m.MenuKeyValues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_UserMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgData = append(m.MsgData[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgData == nil {
				m.MsgData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passthrough", wireType)
			}
			m.Passthrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passthrough |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_PaintmapData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_PaintmapData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_PaintmapData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paintmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paintmap = append(m.Paintmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Paintmap == nil {
				m.Paintmap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GameEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GameEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eventid", wireType)
			}
			m.Eventid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Eventid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CSVCMsg_GameEventKeyT{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passthrough", wireType)
			}
			m.Passthrough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passthrough |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventKeyT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: key_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: key_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ValFloat = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValLong", wireType)
			}
			m.ValLong = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValLong |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValShort", wireType)
			}
			m.ValShort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValShort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValByte", wireType)
			}
			m.ValByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValByte |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValBool = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValUint64", wireType)
			}
			m.ValUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValUint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValWstring", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValWstring = append(m.ValWstring[:0], dAtA[iNdEx:postIndex]...)
			if m.ValWstring == nil {
				m.ValWstring = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_GameEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_GameEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, &CSVCMsg_GameEventListDescriptorT{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventListKeyT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: key_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: key_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_GameEventListDescriptorT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: descriptor_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: descriptor_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eventid", wireType)
			}
			m.Eventid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Eventid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CSVCMsg_GameEventListKeyT{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_TempEntities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_TempEntities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_TempEntities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEntries", wireType)
			}
			m.NumEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityData = append(m.EntityData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntityData == nil {
				m.EntityData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_PacketEntities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_PacketEntities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_PacketEntities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntries", wireType)
			}
			m.MaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedEntries", wireType)
			}
			m.UpdatedEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedEntries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelta", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDelta = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBaseline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBaseline = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baseline", wireType)
			}
			m.Baseline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baseline |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFrom", wireType)
			}
			m.DeltaFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeltaFrom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityData = append(m.EntityData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntityData == nil {
				m.EntityData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Sounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Sounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Sounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReliableSound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReliableSound = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sounds = append(m.Sounds, &CSVCMsg_SoundsSounddataT{})
			if err := m.Sounds[len(m.Sounds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_SoundsSounddataT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sounddata_t: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sounddata_t: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginX = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginY = v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginZ", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OriginZ = v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DelayValue = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityIndex", wireType)
			}
			m.EntityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pitch", wireType)
			}
			m.Pitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pitch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundNum", wireType)
			}
			m.SoundNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundNumHandle", wireType)
			}
			m.SoundNumHandle = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.SoundNumHandle = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeakerEntity", wireType)
			}
			m.SpeakerEntity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeakerEntity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			m.RandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomSeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundLevel", wireType)
			}
			m.SoundLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoundLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSentence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSentence = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAmbient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAmbient = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_EntityMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_EntityMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_EntityMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntData = append(m.EntData[:0], dAtA[iNdEx:postIndex]...)
			if m.EntData == nil {
				m.EntData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_CmdKeyValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_CmdKeyValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_CmdKeyValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyvalues", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyvalues = append(m.Keyvalues[:0], dAtA[iNdEx:postIndex]...)
			if m.Keyvalues == nil {
				m.Keyvalues = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_EncryptedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_EncryptedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_EncryptedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypted", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encrypted = append(m.Encrypted[:0], dAtA[iNdEx:postIndex]...)
			if m.Encrypted == nil {
				m.Encrypted = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_HltvReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_HltvReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_HltvReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryTarget", wireType)
			}
			m.PrimaryTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryTarget |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayStopAt", wireType)
			}
			m.ReplayStopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayStopAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayStartAt", wireType)
			}
			m.ReplayStartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayStartAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownBegin", wireType)
			}
			m.ReplaySlowdownBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaySlowdownBegin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownEnd", wireType)
			}
			m.ReplaySlowdownEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaySlowdownEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaySlowdownRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReplaySlowdownRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCLCMsg_HltvReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCLCMsg_HltvReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCLCMsg_HltvReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowdownLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SlowdownLength = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlowdownRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SlowdownRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryTargetEntIndex", wireType)
			}
			m.PrimaryTargetEntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryTargetEntIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EventTime = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVCMsg_Broadcast_Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVCMsg_Broadcast_Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVCMsg_Broadcast_Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetmessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetmessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetmessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNetmessages
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNetmessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNetmessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNetmessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNetmessages
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNetmessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetmessages   = fmt.Errorf("proto: integer overflow")
)
